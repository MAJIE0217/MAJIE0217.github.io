<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础(一)]]></title>
    <url>%2F2019%2F07%2F29%2Fjava%E5%9F%BA%E7%A1%80(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[本次主要记录的是基本数据类型、数据类型转换、基本运算符和进制表示四块块内容。 基本数据类型java中基本数据类型有八种基本类型，包括整数型、浮点型、字符型和布尔类型这几类。如有不足，多多指教。 整数类型java中整数类型有byte、short、int、long共四种。占八种基本数据类型的一半。 类型 范围 默认值 位 byte -128~127 0 8 short -32768~32767 0 16 int -2147483658~2147483657 0 32 long -2^31~2^31-1 0L 64 其中，整数的默认类型是int，所以使用long类型，由于数据范围比int大，要在其值后加上L/l,来表明它是long类型。但l和1(一)太相像，所以通常用大写的L。而byte和short就不需要类型转换，因为它们的数据范围本身比int小，自然不会超过int表示范围。 12345//这些都在自己的数据范围内byte a = 18; //输出 18short b = 1000; //输出 1000int c = 40000; //输出 40000long d = 3000000000L;; //输出 3000000000 而下面则是错误示范，还没运行，编译器自动提示错误：前两个是类型不匹配，无法从int转为byte/short，后两个都是超过int数据类型的范围。更能说明long的默认数据类型是int，因为他没超过long的数据范围。 浮点类型java中浮点类型有float和double共两种。 类型 范围 默认值 位 float 1.4E-45~3.4028235E38 0.0f 32 double 4.9E-324~1.7976931348623157E308 0.0d 64 浮点类型数据范围挺大的，但不太精确，做运算都有可能有误差。不过double则要比float类型精确些，而且在java中，浮点类型的默认类型是double。所以，我们通常用double更多。当然也可以使用float，不过要在其值加上f，否则编译器会报错。 12345678910//float使用float f1 = 1.2f; //f大小写都行//double使用double d1 = 1.5;double d2 = 1.7d; //可以在后面加d或D//使用科学计数法，以double为例double d3 = 314e-2; //输出 3.14double d4 = 314e2; //输出31400.0 以下是以doubl为例，进行的运算。 1234567891011double a = 12.3;double b = 12.3;double c = 24.6;double e = a + b;System.out.println(e);System.out.println(a == b);System.out.println(c == e);double d = a + c;double f = 36.9;System.out.println(d);System.out.println(d == f); 这是以加法为例，说明浮点类型在进行运算的不可靠。而可能这几行代码在你的电脑就全是true。当然这你可能会有疑惑，浮点计算不可靠，那银行算金额咋办，我觉得可能是他们内部自己用字符串转换成char数组，找到’.’的位置，在把数组每个值与另一个数组对应的值进行运算，这想想挺麻烦的，但其实java有自己的类进行浮点运算，那就是BigDecimal，它属于Math类中，以后讲常用类会提及。 字符类型java中字符类型是char表示，数据范围从0~65525，其默认值为\u0000, 在内存中占16位。 1234char c = &apos;A&apos;; //注意要打单引号，双引号就是字符串啦System.out.println(c); //输出 Aint a = 97; //也可以把整型强制转换成char类型，后面会提及类型转换System.out.println((char)a); //输出 a 布尔类型java中布尔用boolean表示， 它只有两个取值true和false。true为真，false为假，默认值为false。 在内存中占1位。 123456boolean flag = true;if(flag) &#123; //等价于 flag==true //if条件语句只有true时，才执行 System.out.println(&quot;flag为&quot; + flag);&#125;//输出 flag为true 数据类型转换数据转换分为两种，一种是自动转换，容量小的自动转换成容量大的，另一种是强制转换(强制把某种类型转换成另一种类型)，强转可能会出现精度损失。 什么是精度损失？比如1.9的浮点型，强制转为整型，就变成1，小数部分直接舍弃。 自动转换byte–&gt;short–&gt;char–&gt;int–&gt;long–&gt;float–&gt;double当然整型转换成浮点型，有可能会出现精度的损失。 123456789101112131415161718byte bt = 127;int bc = bt;System.out.println(bc); //输出 127int a = 12;double b = a;System.out.println(b); //输出 12.0long c = 1234567890123456789L;float d = c;double dou = c;//电脑不同，可能输出的结果也有一点点差别System.out.println(d); //输出 1.23456794E18System.out.println(dou); //输 1.23456789012345677E18char ch = &apos;\u0010&apos;; //可以看的出来是char占16位int ch2 = ch;System.out.println(ch2); //输出16 从代码中，这些都是自动转换，但也有人会问，为啥long都能自动转换为float，long占64位，float占32位，但java自动转换不是看谁在内存占的位数大就转谁，而是看容量。浮点型中，容量是不能直接算出来的，而float的最大值远远大于long的最大值，所以long能自动转换为float。但数值一大，就会出现精度损失。 强制转型一般把容量大的转换成容量小的，但转换的变量数据不能超过转换后的容量，虽然编译器不会报错，但输出结果可能是错误的。 以整型为例: 123456int a = 18;byte a1 = (byte)a; //把int型强制转换成byte型，并且18在byte范围内System.out.println(a1); //输出 18a = 128; //128已经超过byte数据范围a1 = (byte)a;System.out.println(a1); //输出 -128 可以看出强制转型一定要在合理范围内，比如说，两个杯子，一个大杯子是满的，另一个小杯子是空，我们无法把大杯子的水都倒在小杯子里。反过来我们可以把装满水的小杯子倒在空的大杯子，不过这是自动转型啦。 强制把浮点型转换成整型型，可能会出行精度损失。 1234double d = 1.9; //如果浮点本身是没有小数，转整型就不会出行精度损失int a = (int)d;System.out.println(a); //输出 1System.out.println(d); //输出1.9 转型是不改变原变量的值 基本运算符 运算符 名称 例子(int型) 结果 + 加法 a = 1+2 a = 3 - 减法 a = 2-1 a = 1 * 乘法 a = 5*2 a = 10 / 除法 a = 5/2 a = 2 % 求余/取模 a = 5%2 a = 1 ++ 自增 a1 = a2 = 2; b = a1++; c = ++a2 b = 2; c = 3 - - 自减 a1 = a2 = 2; b = a1- -; c = - -a2 b = 2; c = 1 &amp; 与 a = 5; b = 3; c = a&amp;b c = 1 | 或 a = 5; b = 3; c = a|b c = 7 ! 非 boolean flag = false;flag = !flag; flag = true &lt;&lt; 左移(*2) a = 1&lt;&lt;2 a = 4 &gt;&gt; 右移(/2) a = 8&gt;&gt;3 a = 1 以上就是java中最常用的运算符，加减乘数是基本的四则运算，整数和浮点型可以一起运算，但是，低的数据类型会向高的数据类型自动转换。如果不同类型进行运算，赋值的变量数据类型要是最大的那个。 四则运算123456789101112131415int a1 = 12;long a2 = 23; //23一开始是int型，赋值个a2变成了long型//a1 = a1+a2; //a1和a2相加向long类型转换，所以会报错//但我们可以进行下面这运算a1 += a2; //等价于 a1 =(int)(a1+a2); 把long型强制转换成int型//浮点型最注意除法运算double d = 1.2 + 5 / 2; //输出 3.2//在运算过程中,先/，5/2，两个都是整型，结果也是整型2，2+1.2就是结果，这里好像是转换成2.0+1.2//那怎么办，办法如下//把其中一个整型变成浮点型d = 1.2 + 5.0/2; //输出 3.2//d = 1.2 + (double)5/2; 这样也是可以的，但太麻烦，很少用吧...//d = 1.2 + (double)(5/2); ps:这是错误，和第8行运算一样的结果 求余% 就是求一个数除以另一个数得到它的余数，所以称为求余或取模。 123456int a = 10%3; //输出 1//注意，求余结果符号和除数用关a = -10%3; //输出 -1a = 10%-3; //输出 1a = -10%-3; //输出 -1 ++和- -自增是自己加1，自减是自己减1，但要注意放的位置。 123456//++和--都一样，以++为例int a1 = 2;int a2 = 2;int b1 = a1++; //b1 = 2 运算为 先b1 = a1, 然后a1 += 1int b2 = ++a2; //b2 = 3 运算为 先a += 1， 在b2 = a2 //最后结果a1和a2都为3 &amp;、|、！12345678910111213141516171819 int a1 = 5, b1 = 3; int c1 = a1&amp;b1; //输出1/* * 与运算是真真为真，一真一假为假，假假为假 * 而这里的真是二进制的1，假为二进制的0 * 5的二进制为 0101 * 3的二进制为 0011 * 进行与运算 0001 所以答案为1 */ int a2 = 5, b2 = 3; int c2 = a2|b2; //输出7/* * |运算是真真为真，一真一假为真，假假为假 * 所以5|3 为 0101 * 0011 * 0111 答案为7 */ boolean flag = false; //一开始flag为假(false） flag = !flag; //!flag意思是 不是假， 那么flag就是真(true) !有否定的意思 &lt;&lt;和&gt;&gt;左移一位是乘2，左移两位是乘4……以此类推。右移一位是除以2，右移两位是除以4……以此类推。通常在乘2或除以2，建议用&lt;&lt;和&gt;&gt;，效率上要比*和/快一点。 12345678910 int a = 1&lt;&lt;2; //输出 a为4/* * 1的二进制是0001，把1左移两位，变成0100，变成了4 */ int b = 8&gt;&gt;3; //同理，1000右移三位，变成0001 //当然不是移一个数，是整体的移动，下面以7为例 //0111&lt;&lt;1 ---&gt; 1110 变为 14 7*2=14 //0111&gt;&gt;1 ---&gt; 0011 变为 3 7/2=3 进制表示 “世界上只有10中人，一种是懂二进制，另一种是不懂二进制”。 二进制由0和1组成，而我们的代码最终也会变成二进制运行，计算机也是以二进制进行工作，网络信息也是以二进制在物理层传输。所以二进制对我们来不会很陌生。 初次之外，我们还有八进制、十六进制和常用的10进制，让我们用代码表示。 12345678910//都表示输入10这个数int a1 = 10; //写代码默认十进制 十进制:0 1 2 3 4 5 6 7 8 9int a2 = 0b1010; //二进制表示10，前面加0b/0B 二进制:0 1int a3 = 012; //八进制表示10, 前面加0就行 八进制:0 1 2 3 4 5 6 7 int a4 = 0xA; //十六进制表示10，前面加0x 十六进制:0 1 2 3 4 5 6 7 8 9 a b c d e f//那么如何输出各进制的10呢?System.out.println(Integer.toBinaryString(10)); //二进制System.out.println(Integer.toOctalString(10)); //八进制System.out.println(10); //额...十进制System.out.println(Integer.toHexString(10)); //十六进制 以上就是本次总结，本来还想写很多，把常用语句也记录上，那样就会太长了，只能等下一篇文章了。如有不足之处，请在下方评论区留言，谢谢您的来访~ ~ ~下次见。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客记]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[博客搭建好了，让我这个小萌新说点什么吧，如有不足，各位多多包涵 为什么要搭建博客搭建博客每个人都应该有自己的理由，我的理由是学的东西挺多了，时间一长就忘记了。不想在纸上做笔记，怕弄丢了，而且有新的发现不能在原有的基础上修改，越改越乱。在电脑上也写了一点代码，时间一长也不知道是干啥用的，有的还不容易找到。所有想写点博客，有思路的写，把学习过程写的明明白白。哈哈哈~。当然，也是为了提升自己嘛，耳边总会响起一句话：“你想成为什么样的人？”。我不知道会成为什么样的人，只要还是像当初那样热爱就行。 你要用这个博客干啥我还只是一个萌新，还有很多东西尚未了解，写不出大佬那样条条有序，严谨的代码。所以写写自己的学习笔记，一些对自己难题的解决分享，说通俗点就是随便写写，把自己的收获分享给大家，当然可能会出现很多错误，也希望各位大佬能严格指出。哈哈哈~。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
