<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安装Windows操作系统</title>
    <url>/2019/10/12/LoadingOS/</url>
    <content><![CDATA[<p>先放松一下，安装操作系统，本次以Windows为例。无图版。</p>
<a id="more"></a>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>一个至少8G的空U盘，一台电脑，一个网络。</p>
<h1 id="下载系统"><a href="#下载系统" class="headerlink" title="下载系统"></a>下载系统</h1><p>1.我们可以去官网下载：<a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener">https://www.microsoft.com/zh-cn/software-download/windows10</a></p>
<p>点击里面的立即下载工具，工具下载好后双击，有一步一步的选项，里面有32位和64位选择，家庭版还是专业版。直接把系统镜像直接下载到U盘。</p>
<p>2.我告诉你网站下载：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></p>
<p>这真的是一个网站，里面的操作系统都是纯净版的，可以选择自己想要的系统，win7、win10都行，32位还是64位。但要区分版本专业版(旗舰版)、家庭版、教育版还是企业版。不过要在迅雷下载，下载的时候请放到找的到的地方，不要下载到U盘里。</p>
<p>建议：</p>
<p>一般来说，建议下载专业版，因为家庭版的远程服务还有其它的一些功能用不了。</p>
<p>32位还是64位看自己内存的大小，一般4G内存以下建议32位。</p>
<p>什么你不会看内存有多大？天呢，我教你：</p>
<p>右键我的电脑—&gt;点击属性。</p>
<p>这里会显示你的CPU和内存，现在系统的版本，当然这方法仅限于本身就是win系统。 </p>
<p>说明：上面下载的方法都是正版，因为你没激活系统的话，会在你电脑右下角显示请激活系统的字样。</p>
<h1 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h1><p><strong>如果你是第一种方法下载的系统，可以跳过该方法，把电脑关机。</strong></p>
<p>首先，我们先去下载一个软件—&gt;软碟通:<a href="https://cn.ultraiso.net/xiazai.html" target="_blank" rel="noopener">https://cn.ultraiso.net/xiazai.html</a>  可以免费试用，安装软件。</p>
<p>然后，我们找到下载的系统，双击，自动打开软碟通，点击继续试用。</p>
<p>接着，点击：启动—&gt;写入硬盘映像—&gt;写入。它会找到你插入的U盘，如果要求格式化点击确认。</p>
<p>最后，写入完成，可以把电脑关机。</p>
<h1 id="修改启动项"><a href="#修改启动项" class="headerlink" title="修改启动项"></a>修改启动项</h1><p>BIOS是写在主板上的代码，我们启动电脑，BIOS都会自检，找到启动项或引导，检测你系统放到哪个盘。所以现在我们就是要改变这个选项，让我们的U盘启动。</p>
<p>我们在关机状态启动电脑，因为每个人的主板不同，进入的按键也不同，通常是F12、Delete这个按键。如果你是笔记本，可能按F2或组合键，这就要百度你电脑的品牌如何进入BIOS。</p>
<p>BIOS现在有的电脑有两种模式：</p>
<p>一种是傻瓜模式，直接进入Boot  Devices ，在这你会清楚的看到自己的系统盘和U盘，上下键选中自己的U盘，按回车键，电脑会重启。</p>
<p>第二种则是正常的BIOS，可能有单页也可能有多页(一般情况是多页)。单页找到和自己U盘名字相同的就行，按F5、F6改变U盘的位置，把它放到第一个。</p>
<p>多页的话，找到Boot，不出意外头几行就看到你的U盘，也按F5、F6把它放到第一个启动项。</p>
<p>然后按F10保存并退出，电脑会重启。</p>
<h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><p>重启后，电脑会停留在一个窗口，显示：重装系统还是选择修复系统。我们选择重新系统。</p>
<p>来到第二个界面，我们选择下面的那个—&gt;自定义：仅安装Windows</p>
<p>第三个界面就是我们的硬盘，上面的驱动器0或驱动器1说明你的硬盘有几个，后面是它分了多少个盘。</p>
<p>你可以把不必要的分区删除再进行重新分区，一般win10安装在80G左右的盘就行，如果你的硬盘只有120G左右，那干脆全用来装系统算了。</p>
<p>接着下一步，开始自动安装，安装完毕后系统会重启，你可以把U盘拔下来了，防止在进入安装界面。</p>
<p>最后则是Windows的要求的各种设置。折腾一下就装好了。</p>
<p>注意：系统安装快慢取决于你的U盘的写入速度和硬盘的读取速度，如果加载的慢请多等等，我以前的破电脑，可是装了一个多小时才搞定，所以请不要急躁。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（十二）</title>
    <url>/2019/10/12/java12/</url>
    <content><![CDATA[<p>这次记录的是多线程，我们能一遍听歌一遍聊QQ等等，都是多线程的操作。</p>
<a id="more"></a>

<p>我们常常都听到进程与线程，而它们却是有差异的。<br>当我们打开一个应用程序，CPU会给它分配一定的资源，这就是进程。最明显的就是我们打开任务管理器，那些CPU给的内存资源。</p>
<p>而线程呢，我们打开这些应用程序，程序会给我们不停的画窗口，这就是一个进程，我们每打开一个功能，就是打开一个进程。这些进程同时执行，就是多线程的概念。</p>
<p>一个进程至少有一个线程。</p>
<p>并发与并行：<br>并发是多个处理器，在同一时间，一起执行不同的线程。<br>并行是一个处理器，在不同时间处理不同的线程。</p>
<p>而我们的处理器大部分都是并行处理，因为有很多线程一起执行。我们往往感受不到卡顿，是因为它执行的速度太快了。<del>这段好啰嗦</del></p>
<h1 id="多线程的状态"><a href="#多线程的状态" class="headerlink" title="多线程的状态"></a>多线程的状态</h1><p>线程的生命周期：新建状态(New)、可运行状态(Runnable)、运行状态(Running)、阻塞状态(Blocked)和死亡状态(Dead)。</p>
<h2 id="多线程的声明和状态情况"><a href="#多线程的声明和状态情况" class="headerlink" title="多线程的声明和状态情况"></a>多线程的声明和状态情况</h2><p>下面代码虽长，但我们实际使用的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyThread mt = new MyThread();	</span><br><span class="line">mt.start();	</span><br><span class="line">还有重写run()方法，其他都是可有可无的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();					//新建状态，先New一个线程</span><br><span class="line">		System.out.println(&quot;线程的状态-新建:&quot;+mt.getState());</span><br><span class="line">		//mt.setName(&quot;mt&quot;);						//线程的取名，一定要在start()执行前调用，我忘了用了</span><br><span class="line">		mt.start();							//可运行状态，什么时候运行，看CPU的调度</span><br><span class="line">		System.out.println(&quot;线程的状态-可运行:&quot;+mt.getState());		//getState()获取线程运行状态</span><br><span class="line"></span><br><span class="line">		for(int i=0; i&lt;100; i++) &#123;</span><br><span class="line">			//Thread.currentThread().getName()获取线程的名称，main也是一个线程</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;使用&quot;);</span><br><span class="line">			System.out.println(&quot;线程的状态-可运行/阻塞:&quot;+mt.getState());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(100);					//使用线程休眠100毫秒，这里休眠的是main方法执行的线程</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;线程的状态-死亡:&quot;+mt.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;							//继承Thread类，也就是多线程类</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;							//把要多线程运行的代码贴进去</span><br><span class="line">		for(int i=0; i&lt;100; i++) &#123;</span><br><span class="line">			System.out.println(this.getName()+&quot;线程&quot;+i+&quot;使用&quot;);	//getName()获取当前线程的名字</span><br><span class="line">			System.out.println(&quot;线程的状态-可运行:&quot;+this.getState());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程的状态-新建:NEW</span><br><span class="line">线程的状态-可运行:RUNNABLE</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行/阻塞:RUNNABLE</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行/阻塞:RUNNABLE</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行/阻塞:RUNNABLE</span><br><span class="line">...</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行/阻塞:RUNNABLE</span><br><span class="line">Thread-0线程0使用</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行:RUNNABLE</span><br><span class="line">线程的状态-可运行/阻塞:BLOCKED</span><br><span class="line">Thread-0线程1使用</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行/阻塞:BLOCKED</span><br><span class="line">main使用</span><br><span class="line">线程的状态-可运行/阻塞:BLOCKED</span><br><span class="line">...</span><br><span class="line">Thread-0线程98使用</span><br><span class="line">线程的状态-可运行:RUNNABLE</span><br><span class="line">Thread-0线程99使用</span><br><span class="line">线程的状态-可运行:RUNNABLE</span><br><span class="line">线程的状态-死亡:TERMINATED</span><br></pre></td></tr></table></figure>

<p>上面则是截取的一段结果，我们可以看到它们执行顺序的不同，这是CPU决定的，我们不敢说也不敢动。</p>
<p>也能看到线程的四个状态。Running是获取不到的，就像我们看得到水，却看不见水流</p>
<p>这是从继承的角度去调用，我们都知道，Java是单继承，所以不能继承其它类。所以我们可以继承多线程的接口——Runnable。它里面只要一个抽象方法run()。所以在实际使用中，还是要传给Thread类里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();		</span><br><span class="line">		</span><br><span class="line">		Thread t = new Thread(mt,&quot;t&quot;);		//第一个传入的是线程的参数，第二个是它的别名</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;			//继承接口，实现它里面唯一的方法</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0; i&lt;100; i++) &#123;</span><br><span class="line">							//获取线程名字和状态都是Thread里的，所以这里不能用this</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;线程&quot;+i+&quot;使用&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我删除了多余代码，当然运行结果是不一样的，这里相当于是单线程操作，只运行了run()里的方法。</p>
<p>所以多线程的实现方法一般有两种。直接继承Thread类。或者实现Runnable接口，在传值给它的子类Thread类里，这种为了能实现其它类。</p>
<h2 id="多线程的阻塞"><a href="#多线程的阻塞" class="headerlink" title="多线程的阻塞"></a>多线程的阻塞</h2><p>多线程的阻塞有四个方法。第一个是刚才写的sleep()：它能使指定的线程休眠一段时间。第二个是yield()：是指定的线程回到可运行状态等待CPU的下次调用。第三个是join()：它是停止之前的线程，让CPU执行现在的线程。第四个是wait()和notify()：wait使线程阻塞，notify使可运行。</p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();		</span><br><span class="line">		Thread t1 = new Thread(mt,&quot;t1&quot;);				//在这里弄了两个线程一起执行</span><br><span class="line">		Thread t2 = new Thread(mt,&quot;t2&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0; i&lt;10; i++) &#123;</span><br><span class="line">			//如果线程的名叫t1，并且循环执行到了第五次，那么t1进入休息10毫秒</span><br><span class="line">			if(Thread.currentThread().getName().equals(&quot;t1&quot;) &amp;&amp; i==5) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.currentThread().sleep(100);	//sleep()会返回一个异常，我们在run()方法里，只能try/catch</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1:0</span><br><span class="line">t2:0</span><br><span class="line">t1:1</span><br><span class="line">t2:1</span><br><span class="line">t1:2</span><br><span class="line">t1:3</span><br><span class="line">t2:2</span><br><span class="line">t1:4</span><br><span class="line">t2:3</span><br><span class="line">t2:4</span><br><span class="line">t2:5</span><br><span class="line">t2:6</span><br><span class="line">t2:7</span><br><span class="line">t2:8</span><br><span class="line">t2:9</span><br><span class="line">t1:5</span><br><span class="line">t1:6</span><br><span class="line">t1:7</span><br><span class="line">t1:8</span><br><span class="line">t1:9</span><br></pre></td></tr></table></figure>

<p>在执行的前8行运行结果都是无顺序的，而在t1=5时，它休眠了100毫秒，之后就是t2开始执行100毫秒，当然这100毫秒t2已经执行完毕了。100毫秒后就是t1从5开始执行。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		Thread t1 = new Thread(mt,&quot;t1&quot;);</span><br><span class="line">		Thread t2 = new Thread(mt,&quot;t2&quot;);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0; i&lt;10; i++) &#123;</span><br><span class="line">			if(Thread.currentThread().getName().equals(&quot;t1&quot;) &amp;&amp; i==5) &#123;</span><br><span class="line">				Thread.currentThread().yield();			//把这里改了下</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果和sleep()类似。当然，因为这里的数据太小，不过它们的思想是不同的，sleep是一直在线程等待，而yield是中断现在的线程，回到可运行状态，等待CPU的再次调用继续执行。</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		mt.setName(&quot;mt&quot;);</span><br><span class="line">		mt.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0; i&lt;15; i++) &#123;</span><br><span class="line">			if(i==5) &#123;</span><br><span class="line">				MyThread2 mt2 = new MyThread2();</span><br><span class="line">				mt2.setName(&quot;mt2&quot;);</span><br><span class="line">				mt2.start();</span><br><span class="line">				try &#123;</span><br><span class="line">					mt2.join();			//当mt执行了4次后，mt2启动并执行。</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 extends Thread&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0; i&lt;10; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mt:0</span><br><span class="line">mt:1</span><br><span class="line">mt:2</span><br><span class="line">mt:3</span><br><span class="line">mt:4</span><br><span class="line">mt2:0</span><br><span class="line">mt2:1</span><br><span class="line">mt2:2</span><br><span class="line">mt2:3</span><br><span class="line">mt2:4</span><br><span class="line">mt2:5</span><br><span class="line">mt2:6</span><br><span class="line">mt2:7</span><br><span class="line">mt2:8</span><br><span class="line">mt2:9</span><br><span class="line">mt:5</span><br><span class="line">mt:6</span><br><span class="line">mt:7</span><br><span class="line">mt:8</span><br><span class="line">mt:9</span><br><span class="line">mt:10</span><br><span class="line">mt:11</span><br><span class="line">mt:12</span><br><span class="line">mt:13</span><br><span class="line">mt:14</span><br></pre></td></tr></table></figure>

<p>可以看到，join()的使用，使得mt阻塞，开始执行mt2，等到mt2执行完毕后，才执行mt。join就跟我们平时排队时类似，总有那么几个人插队。</p>
<h3 id="wait-和notify"><a href="#wait-和notify" class="headerlink" title="wait()和notify()"></a>wait()和notify()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		MyThread2 mt2 = new MyThread2();</span><br><span class="line">		mt.start();</span><br><span class="line">		mt2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends MyT&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (o) &#123;						//这里是线程同步的方法，也称为线程锁</span><br><span class="line">			try &#123;</span><br><span class="line">				System.out.println(&quot;线程一&gt;&gt;现在等待&quot;);</span><br><span class="line">				o.wait();					//这里是让o这个对象等待</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;线程一&gt;&gt;执行完毕&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;线程一&gt;&gt;结束运行&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 extends MyT&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(100);</span><br><span class="line">		&#125; catch (InterruptedException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		synchronized (o) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000*3);				//让当前线程等待3秒</span><br><span class="line">				System.out.println(&quot;线程二&gt;&gt;休眠状态&quot;);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;线程二&gt;&gt;已被唤醒&quot;);</span><br><span class="line">			o.notify();						//把o对象唤醒</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;线程二&gt;&gt;结束运行&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyT extends Thread&#123;</span><br><span class="line">	static Object o = new Object();						//线程同步要点:保证同步资源一致</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程一&gt;&gt;现在等待</span><br><span class="line">线程二&gt;&gt;休眠状态</span><br><span class="line">线程二&gt;&gt;已被唤醒</span><br><span class="line">线程二&gt;&gt;结束运行</span><br><span class="line">线程一&gt;&gt;执行完毕</span><br><span class="line">线程一&gt;&gt;结束运行</span><br></pre></td></tr></table></figure>

<p>如何MyThread2不加Thread.sleep(100)，可能会出现下面这样的错误。在MyThread一直等待。所以一定要先让MyThread进入线程锁里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">线程二&gt;&gt;休眠状态</span><br><span class="line">线程二&gt;&gt;已被唤醒</span><br><span class="line">线程二&gt;&gt;结束运行</span><br><span class="line">线程一&gt;&gt;现在等待</span><br></pre></td></tr></table></figure>

<p>运行结果以第一个为例。先打印第一行，接着过了大约3秒，打印最后的几行。</p>
<p>为啥要加入synchronized使线程同步呢好像JVM要求使用wait()时，要使用线程同步。而且我们要等待和唤醒的是同一个对象——Object。而wait()不会造成死锁状态，它会把synchronized解锁。</p>
<h2 id="线程的结束"><a href="#线程的结束" class="headerlink" title="线程的结束"></a>线程的结束</h2><p>Thread里有两个方法可以结束线程，但都不安全、不可靠。所以，一般都是让它自己运行结束，或使用boolean标记。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		mt.start();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(10);			//当主线程停止10毫秒，停止mt线程的执行</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		mt.flagToFalse();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">	private boolean flag = true;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(flag) &#123;					//用boolean进行标记，如果不改变，那么它将一直执行下去</span><br><span class="line">			System.out.println(&quot;线程执行&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void flagToFalse() &#123;</span><br><span class="line">		this.flag = false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="线程为啥不安全"><a href="#线程为啥不安全" class="headerlink" title="线程为啥不安全"></a>线程为啥不安全</h2><p>为什么要线程安全呢?我们从下面的例子展开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		Thread t1 = new Thread(mt);</span><br><span class="line">		Thread t2 = new Thread(mt);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		Thread.sleep(1000*15);						//15秒后打印结果</span><br><span class="line">		mt.printSum();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public int sum = 0;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=0; i&lt;100; i++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(100);		//模拟网络延迟</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			sum++;							//简单模拟求和</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void printSum() &#123;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是两个线程启动，有”延迟”的情况下，求sum的和，sum最后的和应该为200。那我们看看实际情况可能为多少。这里只运行了两次，因为要等10多秒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">193</span><br><span class="line">188</span><br></pre></td></tr></table></figure>

<p>每次得到的答案都不相同，这是为啥？这是两个线程同时运行，在同一时间都拿到了某个数，假设为100，它们都给100赋值，最后sum只加了一次。而取得相同数有很大概率。</p>
<p>下面模拟简单取火车票。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		Thread t1 = new Thread(mt);	</span><br><span class="line">		Thread t2 = new Thread(mt);</span><br><span class="line">		Thread t3 = new Thread(mt);		//三个线程去抢车票</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public int sum = 20;				//假设有20张车票</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(sum&gt;0) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(200);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			//模拟取票，看看谁取走哪张票</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+sum--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0&gt;&gt;20</span><br><span class="line">Thread-1&gt;&gt;18</span><br><span class="line">Thread-2&gt;&gt;19</span><br><span class="line">Thread-1&gt;&gt;17</span><br><span class="line">Thread-0&gt;&gt;16</span><br><span class="line">Thread-2&gt;&gt;17</span><br><span class="line">Thread-1&gt;&gt;15</span><br><span class="line">Thread-2&gt;&gt;13</span><br><span class="line">Thread-0&gt;&gt;14</span><br><span class="line">Thread-2&gt;&gt;12</span><br><span class="line">Thread-1&gt;&gt;11</span><br><span class="line">Thread-0&gt;&gt;10</span><br><span class="line">Thread-2&gt;&gt;9</span><br><span class="line">Thread-1&gt;&gt;8</span><br><span class="line">Thread-0&gt;&gt;7</span><br><span class="line">Thread-2&gt;&gt;6</span><br><span class="line">Thread-1&gt;&gt;5</span><br><span class="line">Thread-0&gt;&gt;4</span><br><span class="line">Thread-1&gt;&gt;3</span><br><span class="line">Thread-2&gt;&gt;2</span><br><span class="line">Thread-0&gt;&gt;1</span><br><span class="line">Thread-1&gt;&gt;0</span><br><span class="line">Thread-2&gt;&gt;-1</span><br></pre></td></tr></table></figure>

<p>我们可以看到，取了重复的，最后还取了一个负一。重复的如上面所讲，同时取了一个数。而负数呢？还剩最后一个数为1，它们三个都取到了，都进入while循环里，一个取了把sum变成了0，又一个取了把0变为-1 。</p>
<h2 id="synchronized的使用与注意"><a href="#synchronized的使用与注意" class="headerlink" title="synchronized的使用与注意"></a>synchronized的使用与注意</h2><p>线程不安全往往就会出现多取或重复取的情况，所以才有线程安全或线程锁的概念。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		MyThread mt = new MyThread();</span><br><span class="line">		Thread t1 = new Thread(mt);</span><br><span class="line">		Thread t2 = new Thread(mt);</span><br><span class="line">		Thread t3 = new Thread(mt);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public int sum = 20;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (this) &#123;				//添加线程锁，但这锁的是Mythread对象</span><br><span class="line">			while(sum&gt;0) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.currentThread().sleep(200);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+sum--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后也没有出现取重或取多的情况，可synchronized不是那么简单的使用？我们把新建线程都改改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Thread t1 = new Thread(new MyThread());			//三个Thread新建三个Mythreadd对象</span><br><span class="line">		Thread t2 = new Thread(new MyThread());</span><br><span class="line">		Thread t3 = new Thread(new MyThread());</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public static int sum = 5;					//三个不同对象，所以保证它们取的sum都是同一个</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			while(sum&gt;0) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.currentThread().sleep(200);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+sum--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-2&gt;&gt;5</span><br><span class="line">Thread-1&gt;&gt;4</span><br><span class="line">Thread-0&gt;&gt;4</span><br><span class="line">Thread-0&gt;&gt;3</span><br><span class="line">Thread-2&gt;&gt;2</span><br><span class="line">Thread-1&gt;&gt;3</span><br><span class="line">Thread-2&gt;&gt;1</span><br><span class="line">Thread-0&gt;&gt;0</span><br><span class="line">Thread-1&gt;&gt;1</span><br></pre></td></tr></table></figure>

<p>明明锁了，可还是错了，那是因为我们锁的是对象，三个线程三个对象，对象不同，锁的也不同。那怎么锁？这是我们考虑的。</p>
<p>下面看看，这次锁的是MyThread这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Thread t1 = new Thread(new MyThread());</span><br><span class="line">		Thread t2 = new Thread(new MyThread());</span><br><span class="line">		Thread t3 = new Thread(new MyThread());</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	public static int sum = 5;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (MyThread.class) &#123;				//锁的是MyThread类</span><br><span class="line">			if(sum&lt;=0) return;				//这是简单的优化，很有必要</span><br><span class="line">			while(sum&gt;0) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.currentThread().sleep(200);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+sum--);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看了三个新的线程，但是结果符合我们的要求，没有重复，没有0和负一。</p>
<p>锁的时候一定要注意锁的是对象还是类，如果是对象是否为同一个对象。</p>
<p>当然，还可以锁run()这个方法，但我不太喜欢用，run()锁的也不是方法，而是这个对象，和我们用锁this没啥区别。</p>
<p>而且，锁方法范围太大，我们可以锁自己感觉需要锁的块。这样可以提高运行效率。</p>
<p>注意：锁块，一定要锁对位置，要不然可能锁不住，不能锁的太大，效率降低很多。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>我现在做的是你下一步想做的事，你现在做的是我下一步想做的事，但我们都不想让出现在资源。这就出现了死锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Threading &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Thread t1 = new Thread(new MyThread());</span><br><span class="line">		Thread t2 = new Thread(new MyThread2());</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	MyWatch mw = new MyWatch();</span><br><span class="line">	MySleep ms = new MySleep();</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (MyWatch.class) &#123;					//先锁的是看电视类</span><br><span class="line">			mw.myWatch();</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(200);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			synchronized (MySleep.class) &#123;				//锁里在加一个锁，睡觉类</span><br><span class="line">				ms.mySleep();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 implements Runnable&#123;</span><br><span class="line">	MyWatch mw = new MyWatch();</span><br><span class="line">	MySleep ms = new MySleep();</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (MySleep.class) &#123;					//先锁的睡觉类</span><br><span class="line">			ms.mySleep();</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(200);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			synchronized (MyWatch.class) &#123;				//锁里在锁看电视类</span><br><span class="line">				mw.myWatch();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyWatch&#123;</span><br><span class="line">	public void myWatch()&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+&quot;我要看电视&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MySleep&#123;</span><br><span class="line">	public void mySleep()&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;&gt;&gt;&quot;+&quot;我要睡觉&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0&gt;&gt;我要看电视</span><br><span class="line">Thread-1&gt;&gt;我要睡觉</span><br></pre></td></tr></table></figure>

<p>最后结果变为看电视的想去睡觉，但床被占了；睡觉的想去看电视，但电视被占了。谁也不想让谁，造成了死锁。</p>
<p>而死锁一般都是锁上加锁造成的，所以要想避免死锁，就不要多重加锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">	MyWatch mw = new MyWatch();</span><br><span class="line">	MySleep ms = new MySleep();</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (MyWatch.class) &#123;</span><br><span class="line">			mw.myWatch();</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(200);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		synchronized (MySleep.class) &#123;</span><br><span class="line">			ms.mySleep();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyThread2 implements Runnable&#123;</span><br><span class="line">	MyWatch mw = new MyWatch();</span><br><span class="line">	MySleep ms = new MySleep();</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		synchronized (MySleep.class) &#123;</span><br><span class="line">			ms.mySleep();</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(200);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		synchronized (MyWatch.class) &#123;</span><br><span class="line">			mw.myWatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全还有Lock()和unlock()方法，一个是上锁，一个是解锁。这里就不弄了，写的太长了….</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（十一）</title>
    <url>/2019/10/04/java11/</url>
    <content><![CDATA[<p>本次记录IO流，方便我们从各个方面存取数据。</p>
<a id="more"></a>

<p>IO流往简单学习就是输入流和输出流。再细分就是字节流还是字符流。常常都说，IO学五大类。而这些很多方法都是类似的，字符输入流有什么，那么字符输入流也有什么。相应的输出流也都有相对应的方法。所以也没那么难。</p>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>FIle文件操作的类，它不属于IO的四大类，但它是IO流的基础。怎么找文件，怎么判断是否为文件，才能方便我们后面的学习，怎么在文件上存和取。</p>
<p>在写代码前，我们先了解路径分隔符。<br>在win上分隔符是’\‘。如”D:\Test”。而’\‘在java中有特殊含义，如果要使用’\‘，需要再加’\‘转译’\‘，如”D:\\Test”。<br>而在linux上，分隔符是’/‘。”D:/Test”。不同系统有不同的分隔符。不过win也支持’/‘。所以我们在写路径可以采用linux的方法。<br>但java可能不止在win和linux上运行，所以我们可以用File里的方法separator来获取系统的分隔符。<br>如String path = “D:”+File.separator+”Test”;这段代码，如果路径比较长，还是挺麻烦的。但不会出错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.File;											//记得引入File包</span><br><span class="line">import java.io.IOException;										//某些方法可能会抛出异常</span><br><span class="line"></span><br><span class="line">public class FileTest &#123;</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		</span><br><span class="line">		String path = &quot;../../Test&quot;;								//相对路径</span><br><span class="line">		File src = new File(path);</span><br><span class="line">		System.out.println(&quot;是否在存在：&quot;+src.exists());			</span><br><span class="line">		System.out.println(&quot;是否为文件夹：&quot;+src.isDirectory());</span><br><span class="line">		System.out.println(&quot;是否为文件：&quot;+src.isFile());</span><br><span class="line">		System.out.println(&quot;是否可读：&quot;+src.canRead());</span><br><span class="line">		System.out.println(&quot;是否可写：&quot;+src.canWrite());</span><br><span class="line">		</span><br><span class="line">		//一般情况，是文件夹，无论有没有内容，都得0，是文件获取大小</span><br><span class="line">		System.out.println(&quot;获得文件的大小:&quot;+src.length());			</span><br><span class="line">		System.out.println(&quot;相对于当前路径的绝对路径：&quot;+src.getAbsolutePath());</span><br><span class="line">		System.out.println(&quot;纯绝对路径：&quot;+src.getCanonicalPath());</span><br><span class="line">		System.out.println(&quot;传入的路径：&quot;+src.getPath());					//根据你传入的路径，是什么就输出什么</span><br><span class="line">		System.out.println(&quot;当前文件|文件夹名称：&quot;+src.getName());</span><br><span class="line">		System.out.println(&quot;上一级的路径：&quot;+src.getParent());</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;是否创建01.txt文件：&quot;+new File(path,&quot;01.txt&quot;).createNewFile());	//File里可以写一个父路径和子路径,能拼接在一起</span><br><span class="line">		</span><br><span class="line">		File[] url = src.listFiles();								//获取子文件的名称</span><br><span class="line">		for(File u:url ) &#123;</span><br><span class="line">			System.out.println(u.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">		System.out.println(&quot;是否删除01.txt：&quot;+new File(new File(path),&quot;01.txt&quot;).delete());	//File里也也可以File加子路径的组合</span><br><span class="line">		</span><br><span class="line">		url = src.listFiles();</span><br><span class="line">		System.out.println(&quot;是否创建C++/学习心得(mdir)&quot;+new File(path,&quot;C++/学习心得&quot;).mkdir());	//如果有多层路径，中间有不存在的路径则不会创建</span><br><span class="line">		System.out.println(&quot;是否创建C++/学习心得(mdirs)&quot;+new File(path,&quot;C++/学习心得&quot;).mkdirs());	//无论中间有没有路径，都一起创建出来</span><br><span class="line">		System.out.println(&quot;是否改变text,txt的名字:&quot;+new File(&quot;../../Test/text.txt&quot;).renameTo(new File(&quot;../../Test/01.txt&quot;)));</span><br><span class="line">		</span><br><span class="line">		url = src.listFiles();</span><br><span class="line">		for(File u:url) &#123;</span><br><span class="line">			System.out.println(u.getName());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		new File(path,&quot;C++&quot;).delete();</span><br><span class="line">		new File(&quot;../../Test/01.txt&quot;).renameTo(new File(&quot;../../Test/text.txt&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java11_01.png" alt><br>上面也有很多注意点，在获取文件夹的大小上，得到一个4096？百度查了一下，这可能是缓存的锅，按道理文件夹应该为0。只有文件才能获取大小。<br>要区别创建文件(createNewFile)还是文件夹(mkdirs)。创建文件夹推荐使用mkdirs。<br>这是最后运行后在我硬盘的内容。<br><img src="/imgs-java/java11_02.png" alt><br>而我们的循环只能获取一层，如果要获取全部文件，可以试试以下方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">public class FileTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String path = &quot;../../Test&quot;;</span><br><span class="line">		File src = new File(path);</span><br><span class="line">		findFile(src,&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void findFile(File src,String separ)</span><br><span class="line">	&#123;</span><br><span class="line">		if(src.exists())</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			System.out.print(separ);</span><br><span class="line">			System.out.println(src.getName());</span><br><span class="line">			if(src.isDirectory())</span><br><span class="line">			&#123;</span><br><span class="line">				File[] url = src.listFiles();</span><br><span class="line">				for(File s:url)</span><br><span class="line">				&#123;</span><br><span class="line">					findFile(s,separ+&quot;|·&quot;);	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java11_03.png" alt></p>
<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><p>在记录四大IO类前，先解决一个问题——编码。我们常用的编码有GBK、utf-8、utf-16、ISO-8859-1、GB2312。每种编码格式不一样，如果编码和解码不统一，那么在操作上会出现乱码。<br>GBK：字母占一个字节，汉字占两个字节。<br>ISO-8859-1：字节编码。<br>GB2312：汉字编码，分成94个区，每个区有94位，每位对应一个字。<br>utf-8：变长unicode编码，字母占一字节，汉字占两字节。<br>utf-16：定长unicod编码，都占两个字节。还分大端(高字节在低地址)小端(低字节在低地址)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.UnsupportedEncodingException;				//会抛出异常</span><br><span class="line"></span><br><span class="line">public class toBye &#123;</span><br><span class="line">	public static void main(String[] args) throws UnsupportedEncodingException &#123;</span><br><span class="line">		String str = &quot;Hello世界&quot;;</span><br><span class="line">		//编码：</span><br><span class="line">			byte[] b = str.getBytes();			//获取文件编码格式，我这是GBK</span><br><span class="line">			System.out.println(b.length);			//打印 9 字母占一个，汉字占两个</span><br><span class="line">			</span><br><span class="line">			b = str.getBytes(&quot;GBK&quot;);			//把编码改为GBK</span><br><span class="line">			System.out.println(b.length);	</span><br><span class="line">			</span><br><span class="line">			b = str.getBytes(&quot;utf-8&quot;);			//把编码改为utf-8</span><br><span class="line">			System.out.println(b.length);			//打印 11 字母占1个，汉字占三个</span><br><span class="line">			</span><br><span class="line">			b = str.getBytes(&quot;utf-16BE&quot;);			//改为大端</span><br><span class="line">			System.out.println(b.length);			//打印 14 每个字占两个字节</span><br><span class="line">						</span><br><span class="line">			b = str.getBytes(&quot;utf-16&quot;);			//没有指定大端还是小端，</span><br><span class="line">			System.out.println(b.length);			//打印 16,因为没指定，前两个字节表示该数组是大端还是小端</span><br><span class="line">			</span><br><span class="line">		//解码：</span><br><span class="line">			str = new String(b,0,b.length,&quot;utf-16&quot;);	//因为我们最后一次编码为utf-16</span><br><span class="line">			System.out.println(str);			//打印 Hello世界</span><br><span class="line">		//乱码：</span><br><span class="line">			str = new String(b,0,b.length,&quot;GBK&quot;);		//如果我们想用原本的编码格式GBK，会怎样</span><br><span class="line">			System.out.println(str);			//打印一堆莫名奇妙的</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h1><p>从特点的节点来获取与读写数据，而这个节点可能是内存或硬盘等其他地方。<br>它以字节流和字符流两类。<br>字节流是一个字节或多个字节传输。一个字节占8bit。<br>字符流是一个字符或多个字符传输，一个字符占1~3字节，看编码格式。<br>字符流主要做文本的操作，而字节流还能做图片、音频、视频等等。字符流能做的字节流也能做。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>我们可以从文件中获取内容，但是字节流是一个字节一个字节获取的。下面是读取文件里的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class InputStreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		InputStream is = null;					//创建输入字节流对象</span><br><span class="line">		int temp;					</span><br><span class="line">		try &#123;</span><br><span class="line">			is = new FileInputStream(&quot;test.txt&quot;);		//指定流位置，相对路径</span><br><span class="line">//			while((temp=is.read())!=-1)			//文件没有了返回-1，不是null</span><br><span class="line">//			&#123;</span><br><span class="line">//				System.out.println((char)temp);		//每次读入一个字节，也只能一个一个打印</span><br><span class="line">//			&#125;</span><br><span class="line">			byte[] b = new byte[100];</span><br><span class="line">			while((temp=is.read(b))!=-1)			//读入多个字节</span><br><span class="line">			&#123;</span><br><span class="line">				String src = new String(b,0,temp);	//转为String可以打印多个字节，也可以循环打印</span><br><span class="line">				System.out.println(src);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;			//可能抛出的异常</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;						//跟外界有交流，一定要记得关闭流</span><br><span class="line">			if(is!=null) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					is.close();			//告诉虚拟机可以关闭流</span><br><span class="line">				&#125; catch (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把内容写入到文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OutputStreamTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		File src = new File(&quot;01.txt&quot;);					//在OutpuStream里，File不存在可以自动创建</span><br><span class="line">		try (OutputStream os = new FileOutputStream(src,true))&#123;		//jdk1.7用try...with...resources来释放资源</span><br><span class="line">								//true 表示在之前的内容后添加，false表示重新写入</span><br><span class="line">			String str = &quot;Hello,World\r\n&quot;;</span><br><span class="line">			byte[] b = str.getBytes();				//字节流输出，要用数组去接收</span><br><span class="line">			os.write(b,0,b.length);</span><br><span class="line">			os.flush(); 						//记得每次输出，要刷新一下，不要等close关闭后强制刷新</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而网络中，数据都是以字节获取。而不是文件。所以我们通常是把文件转换成字节，在把字节转换成我们看得懂的字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayInputStream;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class Byte_IO &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		byte[] b = &quot;Hello,World&quot;.getBytes();				//要获取的字节数组流</span><br><span class="line">		InputStream is = new ByteArrayInputStream(b);			//声明字节数组输入流的对象</span><br><span class="line">		ByteArrayOutputStream os = new ByteArrayOutputStream();		//声明字节数组输出流的对象，因为要用它写的方法，没用多态</span><br><span class="line">		int temp;</span><br><span class="line">		try &#123;</span><br><span class="line">			while((temp=is.read())!=-1) &#123;</span><br><span class="line">				os.write(temp);					//获取is的数据</span><br><span class="line">			&#125;</span><br><span class="line">			os.flush();</span><br><span class="line">			byte[] src = os.toByteArray();				//转为数组打印</span><br><span class="line">			System.out.println(new String(src,0,src.length));</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为直接在网络或其他内存上使用，可以不用close()关闭流。</p>
<p>我们还有数据类型流，和对象流，这里就以数据类做例子，对象流类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DateType &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try(OutputStream os = new FileOutputStream(&quot;003.txt&quot;);</span><br><span class="line">				DataOutputStream dos = new DataOutputStream(os);</span><br><span class="line">			InputStream is = new FileInputStream(&quot;003.txt&quot;);</span><br><span class="line">			DataInputStream dis = new DataInputStream(is);	) &#123;</span><br><span class="line">			</span><br><span class="line">			dos.writeUTF(&quot;你好&quot;);		//存数据到dos，dos写在了os里声明的003.txt文件里</span><br><span class="line">			dos.writeInt(18);</span><br><span class="line">			dos.writeBoolean(true);</span><br><span class="line">			dos.flush();</span><br><span class="line">			dos.writeChar(&apos;a&apos;);</span><br><span class="line">			System.out.println(dis.readUTF());	//取数据到dis,dis从is里声明的003.txt文件里</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java11_04.png" alt><br>在这里，可不是乱码，是程序把我们写的内容序列化，给程序看的，但不影响我们的使用。而且，取数据，一定要按照存的顺序取。</p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>用法和FileInputStream与FileOutputStream类似，但字符流传输的是一个或多个字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.Writer;</span><br><span class="line"></span><br><span class="line">public class ReaderAndWriter &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try (Writer writer = new FileWriter(&quot;a.txt&quot;);</span><br><span class="line">			Reader reader = new FileReader(&quot;a.txt&quot;);)&#123;</span><br><span class="line">			//writer的使用</span><br><span class="line">			writer.write(&quot;Hello,World\r\n&quot;);			//我们可以传入字符串</span><br><span class="line">			writer.flush();</span><br><span class="line">			</span><br><span class="line">			char[] b = &quot;大家好&quot;.toCharArray();			//也可以传入字符数组</span><br><span class="line">			writer.write(b,0,b.length);	</span><br><span class="line">			writer.flush();</span><br><span class="line">			</span><br><span class="line">			writer.append(&quot;\r\n&quot;).append(&quot;欢迎来我的博客&quot;);		//或者writer独有的append方法去添加</span><br><span class="line">			writer.flush();</span><br><span class="line">			</span><br><span class="line">			//reader的使用</span><br><span class="line">			int length;</span><br><span class="line">			char[] src = new char[100];</span><br><span class="line">			while((length=reader.read(src))!=-1)			//和InputStream类似</span><br><span class="line">			&#123;</span><br><span class="line">				String str = new String(src,0,length);</span><br><span class="line">				System.out.println(str);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h1><p>缓冲流是提高效率的，上面的方法，每一次取，都要去原文件里拿。就好比一个加工厂，我每次只拿我本次用的材料，下次还用又从仓库里取下次够用的材料。所以每次取都要跑到仓库里。而缓冲流的效果就是每次从仓库拿一堆材料，每次用都在旁边取，如果不够了，再从仓库拿一堆。这提高了运行效率。</p>
<h2 id="字节流-1"><a href="#字节流-1" class="headerlink" title="字节流"></a>字节流</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Buffered_IO &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try(OutputStream os = new BufferedOutputStream(			//声明缓冲流对象</span><br><span class="line">					new FileOutputStream(			//声明文件操作</span><br><span class="line">						new File(&quot;001.txt&quot;),false));	//声明文件位置,</span><br><span class="line">										//FileOutputStream(File,boolean)默认为false</span><br><span class="line">		InputStream is = new BufferedInputStream(</span><br><span class="line">					new FileInputStream(</span><br><span class="line">						new File(&quot;001.txt&quot;)));) &#123;</span><br><span class="line">			</span><br><span class="line">			byte[] b = &quot;Hello,World&quot;.getBytes();</span><br><span class="line">			os.write(b,0,b.length);					//写入到001.txt</span><br><span class="line">			os.flush();						//强制刷新，缓冲流不到一定内容，不会写入</span><br><span class="line">			</span><br><span class="line">			byte[] a = new byte[5];					//每次写入多少字节</span><br><span class="line">			int len=0;</span><br><span class="line">			while((len=is.read(a))!=-1) &#123;</span><br><span class="line">				System.out.println(new String(a,0,len));	//打印获取的内容</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IOException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符流-1"><a href="#字符流-1" class="headerlink" title="字符流"></a>字符流</h2><p>字符流中的缓冲流，本身有很多新的方法，所以建议不要多态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Buffered_IO02 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try (BufferedWriter writer = new BufferedWriter(</span><br><span class="line">						new FileWriter(&quot;002.txt&quot;,false));	//默认为false，重新写入</span><br><span class="line">		    BufferedReader reader = new BufferedReader(</span><br><span class="line">					 	new FileReader(&quot;002.txt&quot;));)&#123;</span><br><span class="line">			//writer的使用</span><br><span class="line">			writer.write(&quot;Hello,World\r\n&quot;);				//我们可以传入字符串</span><br><span class="line">			writer.flush();</span><br><span class="line">			</span><br><span class="line">			char[] b = &quot;大家好&quot;.toCharArray();				//也可以传入字符数组</span><br><span class="line">			writer.write(b,0,b.length);	</span><br><span class="line">			writer.flush();</span><br><span class="line">			writer.newLine();						//写入一个换行</span><br><span class="line">			writer.append(&quot;欢迎来我的博客&quot;);					//或者writer独有的append方法去添加</span><br><span class="line">			writer.flush();</span><br><span class="line">			</span><br><span class="line">			//reader的使用</span><br><span class="line">//			int length;</span><br><span class="line">//			char[] src = new char[100];</span><br><span class="line">//			while((length=reader.read(src))!=-1)				//和InputStream类似</span><br><span class="line">//			&#123;</span><br><span class="line">//				System.out.println(new String(src,0,length));</span><br><span class="line">//			&#125;</span><br><span class="line">			String src=null;</span><br><span class="line">			while((src=reader.readLine())!=null) &#123;				//可以每次读取一行数据</span><br><span class="line">				System.out.println(src);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><p>因为网络中都是字节传输，而我们实际可能是想要字符操作，所以我们可以把字节流转换成字符流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line">public class Change &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try (BufferedReader reader = new BufferedReader(				//先建立缓冲流提高效率</span><br><span class="line">				new InputStreamReader(System.in,&quot;GBK&quot;));			//获得字节输入并转换为字符，也可以指定编码</span><br><span class="line">			BufferedWriter writer = new BufferedWriter(</span><br><span class="line">					new OutputStreamWriter(System.out,&quot;GBK&quot;));)&#123;		//字符输出，也可以指定编码</span><br><span class="line">			writer.write(reader.readLine());					//读一行字符并写入</span><br><span class="line">			writer.flush();</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在指定编码，一定要与自己写的代码编码一致，我这是GBK，所以才写GBK，如果是utf8就写utf8。</p>
<p>还有很多类和方法，都是大同小异。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（十）</title>
    <url>/2019/09/28/java10/</url>
    <content><![CDATA[<p>程序员就是不停的deBug，而这些Bug也就被我们称为异常。</p>
<a id="more"></a>

<h1 id="了解异常"><a href="#了解异常" class="headerlink" title="了解异常"></a>了解异常</h1><p>异常是为了预见在运行程序时可能会出现的问题，有问题安全退出程序的机制。所以的异常都有一个父类Throwable类，当然它也继承其他接口，但那个接口没有任何属性和方法。而Throwable又被两个类继承。分别是Error和Exception。<br><img src="/imgs-java/java10_01.png" alt></p>
<p>Error一般是编译器或虚拟机的问题，这个无解。我们能做的就是把编译器关闭后重新打开，严重的要重装JDK。</p>
<p>Exception也分为两类，一类是非运行时异常，另一类是运行时异常。</p>
<p>非运行时异常在编译时，编译器就可以提示我们，比如把整型赋值给字符串，少打符号或者中英的符号没区别开等等，编译器提示的错。</p>
<p>运行时异常，是我们编译运行后，进行该行代码运行时，出现了错误。比如：”ArithmeticException”、”ArrayIndexOutOfBoundsException”、”NullPointerException”等等等。这些都是我们常见的异常，算数异常、数组下标越界、空指针等等。而我们今天记录的就是提前发现运行时异常。</p>
<h1 id="为啥学异常"><a href="#为啥学异常" class="headerlink" title="为啥学异常"></a>为啥学异常</h1><p>当我们在处理数据时，尤其后面要学的流，很可能会出现很多错误，比如文件找不到，硬盘装不下，格式不匹配呀等等异常。很可能处理一行代码，就要做不断的判断。异常机制帮助我们，你做好开发就行，有问题交给Exception和它的子类去做。下面是简单的异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	</span><br><span class="line">	int a = 1;</span><br><span class="line">	int b = 0;</span><br><span class="line">	if(b!=0) System.out.println(a/b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为整数除以0，是无限大或无限小的数，无法表示的数，所以会报ArithmeticException异常，算数异常。我们可以提前预判，手动处理被除数是否为0。</p>
<p>而有些类或方法，必须要捕获异常和抛出异常，才能正常使用，否则编译器也会报错。这就是我们接下来学的异常，它属于运行时异常。</p>
<h1 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	//运行可能出异常的代码</span><br><span class="line">&#125;catch(SubClassException e)&#123;</span><br><span class="line">	//如果子类异常类能解决问题，抛出异常。</span><br><span class="line">&#125;catch(ParentClassException e)&#123;</span><br><span class="line">	//如果子类异常不能处理，交给父类异常处理。</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">	//无论有没有抛出异常，最后都运行finally，finally可写可不写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">		</span><br><span class="line">	try &#123;</span><br><span class="line">		</span><br><span class="line">		int a = 1;</span><br><span class="line">		int b = 0;</span><br><span class="line">		System.out.println(a/b);</span><br><span class="line">		System.out.println(&quot;我被执行了吗&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;执行子类算数异常：&quot;+e.getMessage());</span><br><span class="line">		</span><br><span class="line">	&#125;catch (NullPointerException e) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;空指针吗？&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;执行父类异常：&quot;+e.getMessage());</span><br><span class="line">		</span><br><span class="line">	&#125;finally &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;执行了finally&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java10_02.png" alt></p>
<p>从上面的运行结果可以看到，如果try里面的某行代码有异常，那么接下来的代码不会运行，直接进入到catch里。<br>而且，catch是可以多个使用，因为我们try不可能只写一个代码，可能有多个代码会出现不同的异常。<br>这catch里的异常怎么写也有讲究，如果是同一级的子类，顺序可以随意，但如果有父类异常，一定要写在子类后面。原因有两，一，子类更能详细异常的问题，二，catch是从上到下执行的，全让父类执行了，那之后的子类也没必要了。</p>
<p>只要写了finally，那它可能就是最后执行的。因为它也会有例外。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	</span><br><span class="line">	int a = 1;</span><br><span class="line">	int b = 0;</span><br><span class="line">	System.out.println(plus(a,b));	//打印 1</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public static int  plus(int a, int b) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(a/b);</span><br><span class="line">		System.out.println(&quot;我被执行了吗&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		return -1;</span><br><span class="line">		</span><br><span class="line">	&#125;finally &#123;</span><br><span class="line">		</span><br><span class="line">		return 1;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码，在plus方法里，catch执行了return -1语句，但并没有结束运行，打印-1。而是继续运行到finally执行return 1.所以最后打印1。所以return也不能阻止finally的运行。但是，看下面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	</span><br><span class="line">	int a = 1;</span><br><span class="line">	int b = 0;</span><br><span class="line">	try &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(a/b);</span><br><span class="line">		System.out.println(&quot;我被执行了吗&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125; catch (Exception e) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;执行catch了吗&quot;);</span><br><span class="line">		System.exit(0);</span><br><span class="line">		</span><br><span class="line">	&#125;finally &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;执行finally了吗&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在上面这段代码中，打印“执行catch了吗”，System.exit(0)是直接退出程序。所以没运行到finally。我们写代码要避免使用System.exit(0)的使用。</p>
<h1 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h1><p>当然，还有就是甩锅式的抛出异常，我不处理异常，交给上一级处理吧，而上一级可能也不处理异常，也抛了出去，直到抛给了Object类处理异常，它的使用很简单。在方法名后加Throws 和异常名就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception,NullPointerException&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>可能有的时候，异常类里面并没有解决我们的错误，需要我们自己写异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ThrowableTest &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		</span><br><span class="line">		User  u = new User();</span><br><span class="line">		try &#123;</span><br><span class="line">			u.setName(&quot;张三&quot;);</span><br><span class="line">			u.setAge(18);</span><br><span class="line">			u.setSex(&quot;男&quot;);</span><br><span class="line">		&#125; catch (MyThrowable e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThrowable extends Exception&#123;</span><br><span class="line">	public  MyThrowable() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	public  MyThrowable(String msg)&#123;</span><br><span class="line">		super(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	private String sex;</span><br><span class="line">	</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setAge(int age) throws MyThrowable&#123;</span><br><span class="line">		if(age&lt;0) &#123;</span><br><span class="line">			throw new MyThrowable(&quot;年龄不能为负&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else if(age&gt;150) &#123;</span><br><span class="line">			throw new MyThrowable(&quot;年龄不能超过150岁&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		this.age  = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setSex(String sex) &#123;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常以后会常伴在我们左右，所以写代码一定要注意。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（九）</title>
    <url>/2019/09/28/java09/</url>
    <content><![CDATA[<p>这次记录的是泛型和容器，有点相爱相杀的感觉。</p>
<a id="more"></a>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在写泛型，我们先回忆八大基本数据类型和引用数据类型。它们都可以做参数的数据类型和方法的返回类型。有没有一种数据类型可以解决重载时代码的冗余呢？那就是我们最喜欢的Object类，它是所有类的超类(父类)，根据多态的特性，很好解决了重载代码的冗余，我们先实验以下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		T t = new T(12);			//存入整数12</span><br><span class="line">		System.out.println(t.getO());</span><br><span class="line">		int a = (Integer)t.getO();		//多态的实例，向下转型，所以要用Integer类</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		</span><br><span class="line">		t = new T(&quot;Hello&quot;);			//存入字符串Hello</span><br><span class="line">		System.out.println(t.getO());</span><br><span class="line">		String str = (String)t.getO();		//也要转型为String类</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class T&#123;</span><br><span class="line">	private Object o;				//把Object当做数据类型使用</span><br><span class="line">	</span><br><span class="line">	public T() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public T(Object o) &#123;</span><br><span class="line">		this.o = o;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Object getO() &#123;</span><br><span class="line">		return o;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在放数据的时候挺轻松的，整数，字符，布尔，小数，往里放就行，但是，取数据却要每次从Object类转为相应数据类型的包装类。如果我定义的是这个数组呢，一千一万，每次取都要很麻烦，浪费时间。</p>
<p>所以就有了泛型，不仅解决了重载代码的冗余，也解决了类型转换的问题，也定义了一种规范吧。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class genericTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		generic g = new generic(12);</span><br><span class="line">		int a = (int)g.getNum();		//因为这里的泛型没有定义具体类型</span><br><span class="line">							//一样也要转型，但可以用基本数据类型</span><br><span class="line"></span><br><span class="line">		g = new generic(&quot;Hello&quot;);</span><br><span class="line">		String str = (String)g.getNum();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class generic&lt;T&gt;					//定义一个泛型类，&lt; &gt;里可以填任意值,可以自己定义</span><br><span class="line">&#123;							//常用的有T(Type),E(Element),K(Key),V(Value)</span><br><span class="line">	private T num;					//把Object改为 T</span><br><span class="line">	</span><br><span class="line">	public generic() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public generic(T num)&#123;				//修改参数类型</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public T getNum() &#123;				//修改返回类型</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们只是在类加了<t>,把Object修改为T，就变成了泛型类。当然，由于没有具体指明泛型具体参数，所以也可以乱放数据，也要转型为具体数据类型。下面就是泛型规范化的使用。</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class genericTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//generic&lt;Integer&gt; g = new generic&lt;Integer&gt;(12);</span><br><span class="line">		//generic&lt;Integer&gt; g = new generic&lt;&gt;(12);</span><br><span class="line">		generic&lt;Integer&gt; g = new generic(12);		//上面是泛型声明的变化，都可以使用，但里面填的也是包装类</span><br><span class="line">		int a = g.getNum();				//不用在转型</span><br><span class="line">		//g = new generic(&quot;hello&quot;)；			//报错</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class generic&lt;T&gt;			</span><br><span class="line">&#123;						</span><br><span class="line">	private T num;			</span><br><span class="line">	</span><br><span class="line">	public generic() &#123;</span><br><span class="line">		super();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public generic(T num)&#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public T getNum() &#123;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型抽象类和接口"><a href="#泛型抽象类和接口" class="headerlink" title="泛型抽象类和接口"></a>泛型抽象类和接口</h2><p>现在想想，既然有泛型类，那么抽象类、接口呢？它们也是类，所以它们自然而然也可以泛型化。简单带过了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface InterGeneric&lt;T&gt;&#123;						//泛型接口</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">abstract class absGeneric&lt;T&gt; implements InterGeneric&lt;T&gt;&#123;		//泛型抽象类实现泛型接口</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">class generic&lt;T&gt; extends absGeneric&lt;T&gt;					//泛型类继承泛型抽象类</span><br><span class="line">&#123;							</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>泛型方法一定要注意你使用的是哪个，类定义的类型，还是方法新定义的类型，而方法新定义的类型可以为任意类型，不受约束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class genericTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		generic&lt;Integer&gt; g = new generic();		//定义泛型为integer型</span><br><span class="line">		g.printNa(12);					//因为printNa()为新的类型，所有可以输入其他数据类型</span><br><span class="line">		g.printNa(&quot;12&quot;);</span><br><span class="line">		System.out.println(g.printName(25));</span><br><span class="line">		//System.out.println(g.printName(&quot;hw&quot;));	 //报错，因为类定义的类型是integer。</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class generic&lt;T&gt;			</span><br><span class="line">&#123;							</span><br><span class="line">	</span><br><span class="line">	public &lt;T&gt;void printNa(T name)				//&lt;T&gt;声明这里的泛型T为全新的类型</span><br><span class="line">	&#123;							//因为类没有声明，而且不受类定义泛型类影响</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public T printName(T name) &#123;				//这里的T受类影响，如果修改为&lt;T&gt;T,则不受类影响</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型还有一个通配符？和其他注意点，但没弄明白……</p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>我们之前也接触过容器，那就是数组，数组是有序列表，有相同的数据类型。今天我们学的是其他容器，Collection和Map。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</span><br></pre></td></tr></table></figure>

<p>Collection实现了Iterable(迭代器)接口，可以看到，它们都是泛型类，而被继承的也都是泛型。Iterable本身最主要定义了forEach循环，迭代和循环也没多少差异。</p>
<p>而Collection又被哪些继承呢？<br><img src="/imgs-java/java09_01.png" alt><br><img src="/imgs-java/java09_02.png" alt></p>
<p>可以看到，主要的有抽象类和接口，而这些可以细分为三类List(链表)、Set(集合)、Queue(队列)。这也就是Collection所学的。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List被实现的主要类有ArrayList和Vector，它们都是单链表，而且方法都差不多。只是，它们和StringBuffer和StringBulder一样，Vector是线程安全的类。而它们都是单链表，学过数据结构应该都知道，还要双向链表、循环链表等等其他复杂的链表。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>顾名思义：数组链表。它是由数组实现的。看看以下原代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line"></span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一块是整型常量，大小为10。第二块定义一个Object[]数组，那个transient不知道谁啥，但也不影响我们看代码。再看最后两个构造方法。如果使用的是默认构造方法或给的值为0，则Object数组大小为10，或者指定它的大小，但小于0，抛出异常。</p>
<p>以下则是声明ArrayList，容量为10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;		//别忘了引入相应的包</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List list1 = new ArrayList();		//多态的特性</span><br><span class="line">		List list2 = new ArrayList(0);</span><br><span class="line">		List list3 = new ArrayList(10);</span><br><span class="line">		ArrayList list4 = new ArrayList(10);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把容器大小变为-10，则编译报错<br><img src="/imgs-java/java09_03.png" alt></p>
<p>学容器或学数据结构或java学的是啥，都是为了数据的增删改查。</p>
<p>增加元素，链表在C语言的数据结构中，可以在链表范围内随意增加一个元素，那么链表如何呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List list = new ArrayList(5);					//定义链表长度为5</span><br><span class="line">		list.add(&quot;Hello&quot;);						//添加元素</span><br><span class="line">		list.add(13);							//因为没指定链表的具体数据类型，可以任意添加</span><br><span class="line">		list.add(true);</span><br><span class="line">		list.add(new CollectionTest());</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;链表中元素长度(个数)：&quot;+list.size());	//打印链表的元素长度</span><br><span class="line">		</span><br><span class="line">		for(Object l:list)						//前面写过的foreach循环，因为没指定具体类型，用Object</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(l);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;-------------------&quot;);</span><br><span class="line">		list.add(1,&quot;java&quot;);						//也可以在指定位置加元素</span><br><span class="line">		list.add(2,&quot;!&quot;);						//链表就是高级数组，下标也是从0开始</span><br><span class="line">		</span><br><span class="line">		for(Object l:list)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(l);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;链表中元素长度(个数)：&quot;+list.size());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java09_04.png" alt></p>
<p>我们可以发现，定义带链表长度是5，但是我们输入了六个元素，没有报数组越界，那是因为在ArrayList中，每次添加一个元素，都进行了判断，如果超过指定的范围，则给它的范围扩容，从新copy一个新数组给原有的数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure>

<p>这是它扩容的其中两行代码，每次扩容原数组的一半，把值复制给扩容后的数组，但变量名还是原数组名。</p>
<p>在链表中，没有删除这个方法，只有remove()方法，移除元素，所以它们虽然不在容器里，但还在内存上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		List list = new ArrayList(5);			</span><br><span class="line">		list.add(&quot;Hello&quot;);		</span><br><span class="line">		list.add(13);							</span><br><span class="line">		list.add(true);</span><br><span class="line">		list.add(new CollectionTest());</span><br><span class="line">		list.add(15);</span><br><span class="line">		list.add(3);</span><br><span class="line">		for(Object l:list) System.out.println(l);</span><br><span class="line">/*</span><br><span class="line"> * 		Hello</span><br><span class="line"> *		13</span><br><span class="line"> *		true</span><br><span class="line"> *		io.github.java09.CollectionTest@7852e922</span><br><span class="line"> *		15</span><br><span class="line"> *		3</span><br><span class="line"> */</span><br><span class="line">		</span><br><span class="line">		list.remove(3);					//把下标为3移除,对象没了</span><br><span class="line">		list.remove(Integer.valueOf(3));		//把值为3移除</span><br><span class="line">		list.remove(&quot;Hello&quot;);				//把&quot;Hello&quot;移除</span><br><span class="line">		for(Object l:list) System.out.println(l);</span><br><span class="line">/*		</span><br><span class="line"> * 		13</span><br><span class="line"> * 		true</span><br><span class="line"> * 		15</span><br><span class="line"> */</span><br><span class="line">		list.clear();					//清空链表</span><br><span class="line">		System.out.println(list.isEmpty());		//链表是否为空， true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表添加到某个位置的元素和删除某个位置的元素，都是在数组里“整体来回移动”得到的，也就是顺序表。所以它修改和查找某个元素是最方便的</p>
<p>修改和查找提下方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set(index, element) 设置元素值，下标名，新的元素值。</span><br><span class="line">get(int index)      获取元素值，下标名</span><br></pre></td></tr></table></figure>

<p>我们还应该遍历元素，有for循环遍历，也有容器特有的迭代器遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=0; i&lt;list.size(); i++) &#123;</span><br><span class="line">	System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int k=0;</span><br><span class="line">while(k&lt;list.size())</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(list.get(k++));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(Object l:list) System.out.println(l);</span><br><span class="line"></span><br><span class="line">Iterator it = list.iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(Iterator it2 = list.iterator();it2.hasNext();) &#123;</span><br><span class="line">	System.out.println(it2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList就讲那么多，而Vector的方法很多都一样，无非加了线程安全。当然还有其他方法，很多方法Arrays就接触过，虽然可能结果不同，但意思是差不多的。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack是Vector的一个子类，我们称为栈，栈的特性就是先进后出，后进先出，就像羽毛球桶一样，先放进去的最后拿出来。理解它，递归也就差不多想通了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.List;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; s = new Stack();				//多态的特性，和泛型具体化</span><br><span class="line">		StackInteger&gt; stack = (Stack)s;				//但我们想使用栈的方法，向下转型</span><br><span class="line">		stack.push(1);						//stack的入栈方法</span><br><span class="line">		stack.add(2);						//入栈可以用List中的add()</span><br><span class="line">		stack.push(3);</span><br><span class="line">		stack.push(4);</span><br><span class="line">		System.out.println(stack.pop());			//出栈，并返回值, 打印 4</span><br><span class="line">		stack.push(5);</span><br><span class="line">		stack.push(6);</span><br><span class="line">		stack.add(7);</span><br><span class="line">		stack.peek();	</span><br><span class="line">		//stack.add(1, 8);					//这就不是很栈，能用，但不是栈该有的特性</span><br><span class="line">		//stack.remove(Integer.valueOf(0));			//如果用这两种方法，栈就没存在的必要,不建议使用</span><br><span class="line">			</span><br><span class="line">		while(stack.isEmpty()==false)				//如果栈不为空，继续循环 isEmpty()是为空为true</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(stack.pop()+&quot; &quot;);		//7 6 5 3 2 1 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue是一个接口，也继承了List接口，而实现它全部方法的类主要有LinkedList(一开始找队列的类没找到，没想到在java名字不一样)，我们常用的队列就是LinkedList。它的特点是先进先出，后进后出，就像买票一样，先到先得。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Queue;</span><br><span class="line"></span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; q = new LinkedList();		//具体化泛型</span><br><span class="line">		Queue&lt;Integer&gt; queue = (LinkedList)q;</span><br><span class="line">		queue.add(1);</span><br><span class="line">		queue.offer(2);					//入队方法</span><br><span class="line">		queue.offer(3);</span><br><span class="line">		System.out.println(queue.poll());		//出队方法，并返回一个值, 1</span><br><span class="line">		System.out.println(queue.peek());		//出队，返回 2</span><br><span class="line">		queue.offer(4);</span><br><span class="line">		queue.offer(5);</span><br><span class="line">		while(!queue.isEmpty()) &#123;</span><br><span class="line">			System.out.print(queue.poll()+&quot; &quot;);	//2 3 4 5 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>集合，在集合里元素是无序的，不能有重复的值。而链表则是有序，可以有重复的值。因为继承的是在是太多了，这里找了个HashSet类学习。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.math.BigDecimal;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class CollectionTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Set s = new HashSet();</span><br><span class="line">		s.add(14);</span><br><span class="line">		s.add(&quot;14&quot;);</span><br><span class="line">		s.add(12);</span><br><span class="line">		s.add(&quot;Hello&quot;);</span><br><span class="line">		s.add(&quot;12&quot;);</span><br><span class="line">		s.add(&quot;Hello&quot;);</span><br><span class="line">		s.add(12);</span><br><span class="line">		s.add(&quot;He&quot;+&quot;llo&quot;);</span><br><span class="line">		s.add(new String(&quot;Hello&quot;));		//即使new一个新的对象Hello，但比较的还是值</span><br><span class="line">		s.add(12.3456);</span><br><span class="line">		s.add(12.3456);</span><br><span class="line">		s.add(12.31+0.0356);			//出现误差打印 12.345600000000001</span><br><span class="line">		</span><br><span class="line">		//因为没有误差，存入的还是第一次出现的12.3456</span><br><span class="line">		s.add((new BigDecimal(&quot;12.31&quot;).add(new BigDecimal(&quot;0.0356&quot;))).doubleValue());</span><br><span class="line">		</span><br><span class="line">		Iterator it = s.iterator();</span><br><span class="line">		while(it.hasNext()) &#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">/*</span><br><span class="line"> * 		12					//第一个整型12</span><br><span class="line"> * 		14</span><br><span class="line"> * 		Hello					//第一个Hello</span><br><span class="line"> * 		12					//字符串12</span><br><span class="line"> * 		12.3456					//浮点</span><br><span class="line"> * 		14</span><br><span class="line"> * 		12.345600000000001			//有误差</span><br><span class="line"> */</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，我们存入的和打印出来的位置不一样，因为在Set是无序的，也不知道它具体怎么排列的，好像是字符串优先。<br>而且，如果存入的数据类型和值一样，则集合只存一个，即使它们地址不同值相同，也只存一个值。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map原本的意思是地图，当然，在这不是这个翻译，它翻译为映射。它里面有两个泛型，一个是键(Key),另一个是值(Value)，就好像我们的书或字典，键就是目录的序列，值就是该序列下具体的内容。所以有的语言也称它为字典。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>应该是最常用的Map，也是最基础的，它里面有两个值&lt;Key,Value&gt;。我们通过找Key(键)，来获取(Value)值，键在值在，键亡值亡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class MapTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Map map = new HashMap();			//声明Map</span><br><span class="line">		map.put(&quot;Java基础1&quot;, &quot;初学数据类型&quot;);		//插入元素</span><br><span class="line">		map.put(&quot;Java基础2&quot;, &quot;基本语句与数组&quot;);</span><br><span class="line">		map.put(3, &quot;方法的调用&quot;);</span><br><span class="line">		map.put(12,13);</span><br><span class="line">		System.out.println(map.get(&quot;Java基础1&quot;));	//打印 初学数据类型</span><br><span class="line">		map.remove(12);					//移除键为12和它的值13</span><br><span class="line">		System.out.println(map.get(12)); 		//打印 null，因为这里泛型没定义，为Object类的数据类型，空为null</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到在容器这里，应该就能体现面向对象的优越性，因为子继承父类，而父类可能继承其他类或其他接口，这样下来，子类很多方法的用法都是差不多的。会一个，其他看看就会用了。</p>
<p>而泛型呢？一开始说相爱相杀呢？无论是Collection<e>还是Map&lt;K,V&gt;，它们的作用就是增删改查。而我们的数据类型有八种基本数据类型和3种引用类型共11种。如果重写方法，那代码量太冗余了。而泛型则减轻了代码，还能避免取值转型问题，也提供了规范性，你要整数就定义整型，字符串就定义字符串，乱放就默认，让其他开发人员知道，这个到底直接用，还是判断数据类型，提高了开发效率。</e></p>
<p>泛型和容器的记录就到这，有错请在下方提出问题。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（八）</title>
    <url>/2019/09/20/java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<p>本次记录内部类，内部类我感觉挺特别的，既有类的感觉，又有方法和变量的感觉。内部类是定义在类里的，所以我们通常把内部类之外的类，称为外部类。</p>
<a id="more"></a>

<h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><p>我们都知道，在类定义的变量称为成员变量，内部类也一样，定义在类里的类，就是成员内部类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	class b</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是成员内部类的表示，那怎么使用呢。先想想，类，我们一开始使用时，如果它使用的都是普通方法，要先new对不对。如果是静态方法，则可以引入这个类，直接调用。是不是有感觉了。是类，要先new，是静态，可以直接使用，是不是内部类也有这样的属性呢，对，没错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A.B b = new A().new B();</span><br><span class="line">		b.print();</span><br><span class="line">				</span><br><span class="line">//		也可以这样new一个内部类B的对象</span><br><span class="line">//		A a = new A();</span><br><span class="line">//		A.B b1 = a.new B();</span><br><span class="line">//		b1.print();</span><br><span class="line">		A.C c = new A.C();</span><br><span class="line">		c.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	class B						//是一个普通的内部类</span><br><span class="line">	&#123;</span><br><span class="line">		public void print()</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;我是B&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 static class C				//static修饰，是个静态内部类</span><br><span class="line">	&#123;</span><br><span class="line">		public void print()</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;我是C&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都如期打印相应的print()方法，我们也看得出来，我们在使用内部类的时候，都要先new父类的对象，如果内部类是静态，直接 . 使用，否则还要new内部类的对象。</p>
<p><img src="/imgs-java/java08_01.png" alt><br>当然，这里如图补充一句，平时我们写java代码，编译器都会给我们的代码编译成.class的字节码，方便虚拟机在任何平台运行，而上图也看得出来，我们的代码虽然在同一个java文件，但是编译器会把它以类的形式分开，而且，如果是内部类，则会有一个$符号，表示它是谁的内部类。</p>
<p>还有，你也可以不停的写内部类里写内部类，内部类里的内部类写内部类里的内部类的内部类……有点像递归啦。下面则是一个例子。而它的.class也就生成了 A$C$D.class 这样，会一直延伸下去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A.C.D d = new A.C().new D();</span><br><span class="line">		d.print();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	 static class C</span><br><span class="line">	&#123;</span><br><span class="line">		 class D</span><br><span class="line">		 &#123;</span><br><span class="line">			 public void print()</span><br><span class="line">				&#123;</span><br><span class="line">					System.out.println(&quot;我是D&quot;);</span><br><span class="line">					C.this.print();</span><br><span class="line">				&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		public void print()</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;我是C&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码里有个this，this指向当前对象。谁的当前对象，是C的。当前C的print()方法。所以这里先后打印了我是D和我是C。等下就讲外部类使用内部类的属性方法，内部类如何使用外部类的属性方法。</p>
<h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>局部内部类就像局部变量一样，出了相应的范围就不能使用。所以我们只能在方法里使用局部内部类，它的外部类是不能调用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A a = new A();</span><br><span class="line">		a.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	public static void print()</span><br><span class="line">	&#123;</span><br><span class="line">		class B</span><br><span class="line">		&#123;</span><br><span class="line">			void printB()</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(&quot;我是B&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		B b = new B();</span><br><span class="line">		b.printB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="外部类和内部类的互相使用"><a href="#外部类和内部类的互相使用" class="headerlink" title="外部类和内部类的互相使用"></a>外部类和内部类的互相使用</h1><p>先看一看外部类如何使用内部类的属性和方法吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A a = new A();</span><br><span class="line">		a.printA();</span><br><span class="line">		//A.B b = new A().new B();	报错</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	private int x;</span><br><span class="line">	private class B</span><br><span class="line">	&#123;</span><br><span class="line">		int y;</span><br><span class="line">		private int z;</span><br><span class="line">		public void print()</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;我是B&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printA()</span><br><span class="line">	&#123;</span><br><span class="line">		B b = new B();</span><br><span class="line">		b.print();</span><br><span class="line">		b.y = 1;</span><br><span class="line">		b.z = 2;</span><br><span class="line">		System.out.println(&quot;y:&quot;+b.y);</span><br><span class="line">		System.out.println(&quot;z:&quot;+b.z);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到很多有意思的东西，我们把内部类B私有化，这样内部类B就是外部类A独享的moment，所以它不能被其他类所访问，我们可以在外部类中，使用方法去新建内部类，使用它的方法，属性。而我们也看到，内部类中的z是私有的，但是我们可以在外部类中使用，看到z被赋值啦。</p>
<p>注意啦，外部类使用内部类可以在方法里调用。外部类也可以使用内部类私有的属性和方法。</p>
<p>下面则是内部类使用外部类的方法和属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A.B b = new A().new B();</span><br><span class="line">		b.print();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	private int x=1;</span><br><span class="line">	int z;</span><br><span class="line">	private int c = 2;</span><br><span class="line">	public void print()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;这是A&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	class B</span><br><span class="line">	&#123;</span><br><span class="line">		int x = 3;</span><br><span class="line">		</span><br><span class="line">		public void print()</span><br><span class="line">		&#123;</span><br><span class="line">			z = 1;</span><br><span class="line">			x = 2;</span><br><span class="line">			c = 3;</span><br><span class="line">			System.out.println(&quot;内部类的x:&quot;+x);</span><br><span class="line">			System.out.println(&quot;外部类的x:&quot;+A.this.x);</span><br><span class="line">			System.out.println(&quot;外部类的z:&quot;+z);</span><br><span class="line">			System.out.println(&quot;外部类的c:&quot;+c);</span><br><span class="line">			A.this.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java08_02.png" alt></p>
<p>可以看得出来，内部类在使用外部类属性方法时，也同样在方法里使用，但可以直接使用。如果内部类和外部类有相同的变量名，可以用this来指向外部类的变量。而且，也同样，内部类也可以使用外部类的私有属性方法。</p>
<p>当然，这就有一点要注意的，上面两个代码，内部类都是非静态内部类。我们在前面的学习可以知道，在我们运行代码时，虚拟机会提前把静态的，常量，方法名加载到内存中，如果内部类为静态的呢，会怎么样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A a = new A();</span><br><span class="line">		a.print();</span><br><span class="line">		A.B b = new A.B();</span><br><span class="line">		b.print();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	private int x=1;</span><br><span class="line">	int z;</span><br><span class="line">	private int c = 2;</span><br><span class="line">	public void print()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;这是A&quot;);</span><br><span class="line">		B.x = 1;</span><br><span class="line">		B b = new B();</span><br><span class="line">		b.y = 2;</span><br><span class="line">		System.out.println(B.x);</span><br><span class="line">		System.out.println(b.y);</span><br><span class="line">		b.print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static class B</span><br><span class="line">	&#123;</span><br><span class="line">		static int x = 3;</span><br><span class="line">		int y = 3;</span><br><span class="line">		</span><br><span class="line">		public void print()</span><br><span class="line">		&#123;</span><br><span class="line">//			z = 1;</span><br><span class="line">			x = 2;</span><br><span class="line">//			c = 3;</span><br><span class="line">			System.out.println(&quot;内部类的x:&quot;+x);</span><br><span class="line">//			System.out.println(&quot;外部类的x:&quot;+A.this.x);</span><br><span class="line">//			System.out.println(&quot;外部类的z:&quot;+z);</span><br><span class="line">//			System.out.println(&quot;外部类的c:&quot;+c);</span><br><span class="line">//			A.this.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，注释的都是报错的代码，而这些代码则是静态内部类使用外部类的属性方法。而外部类，则可以使用静态内部类的方法属性。为什么呢，还是和虚拟机运行机制有关。静态先加载出来，所以一开始静态内部类就比外部类先出现在内存上，而静态内部类要使用外部类的方法属性时。编译器找不到外部类，因为它没加载到内存上，所以报错。在外部类为什么能使用呢，也很简单，当我们使用外部类的时候，一定是把这个类先new出来了，虽然内部类提前加载到内存上，但new出了外部类，自然也就能使用静态内部类的方法属性。</p>
<p>以上是内部类像普通变量一样，有静态的，私有的，公共的，成员或局部。当然，内部类也可以定义为final修饰的，但，那就和私有差不多，只能外部类使用，而且比私有更恐怖的就是不能更改，毕竟final修饰。</p>
<h1 id="抽象内部类"><a href="#抽象内部类" class="headerlink" title="抽象内部类"></a>抽象内部类</h1><p>上面说完了内部类像变量一样的使用，而我们的类，除了普通的类，还是抽象类和接口对不对。所以内部类也有这样的特征，但也有不一样的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A.B b = new A().new B() &#123;</span><br><span class="line">			</span><br><span class="line">			@Override</span><br><span class="line">			void print() &#123;</span><br><span class="line">				System.out.println(&quot;主main&quot;);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		b.print();</span><br><span class="line">		</span><br><span class="line">		A.C c = new A().new C();</span><br><span class="line">		c.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	abstract class B</span><br><span class="line">	&#123;</span><br><span class="line">		abstract void print();</span><br><span class="line">	&#125;</span><br><span class="line">	class C extends B</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		void print() &#123;</span><br><span class="line">			System.out.println(&quot;C实现抽象类B的方法&quot;);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是抽象内部类的两种使用，当然，第一种肯定是不推荐使用的那种，方法全写在main方法里了，占空间，不好看。推荐下面的那种写法，和普通抽象类一样的继承使用。</p>
<h1 id="内部接口"><a href="#内部接口" class="headerlink" title="内部接口"></a>内部接口</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		A.C c = new A().new C();</span><br><span class="line">		c.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	interface   B</span><br><span class="line">	&#123;</span><br><span class="line">		abstract void print();</span><br><span class="line">	&#125;</span><br><span class="line">	class C implements B</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public</span><br><span class="line">		void print() &#123;</span><br><span class="line">			System.out.println(&quot;C实现内部接口B的方法&quot;);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和抽象内部类使用方法差不多，也没啥好说的，毕竟接口就是比抽象类更抽象的类。</p>
<h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名类就是没有变量名的类，之间new一个类使用它的方法。比如下面的类，直接使用，当然，这种类就是一次性的，因为没有名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		new A().print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	void print()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;Hello&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那内部类的匿名怎么使用呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class innerClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		A.B b = new A().new B();</span><br><span class="line">		b.print();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">	class B</span><br><span class="line">	&#123;</span><br><span class="line">		void print()</span><br><span class="line">		&#123;</span><br><span class="line">			new C() &#123;</span><br><span class="line">				</span><br><span class="line">				@Override</span><br><span class="line">				public void print() &#123;</span><br><span class="line">					System.out.println(&quot;C&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;.print();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//abstract class C</span><br><span class="line">//&#123;</span><br><span class="line">//	abstract public void print();</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">interface C</span><br><span class="line">&#123;</span><br><span class="line">	abstract void print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上使用，在内部类把抽象类或接口的方法实现，然后调用相应的方法，可以看到最后有个.print()。我调用了这个方法。匿名内部类的要点就是要实现抽象类或接口的方法，而这些方法可能只用一次。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>小米平板1+LineageOS 14.1+Smoke刷机教程</title>
    <url>/2019/09/18/Los/</url>
    <content><![CDATA[<p>贫穷限制了我的欲望，为了好好看PFD(米8看着眼痛)，所以捡了个米板1，但是系统是万年安卓4.4.4，所以刷入Los 安卓7.1.2提升系统流畅性和软件兼容性。</p>
<a id="more"></a>

<p>看书也确实挺好的，还挺大的。相等于一本小的笔记本。<br><img src="/imgs-Android/Los_01.jpg" alt><br>我图片明明是竖的，怎么这里显示横的……下面很多图片都横了过来，所以，不要暴打我呀。</p>
<p><a href="https://pan.baidu.com/s/1Aygb5FwYQ2HJuU0KClbuhg" target="_blank" rel="noopener">https://pan.baidu.com/s/1Aygb5FwYQ2HJuU0KClbuhg</a> 提取码:q3j8<br>这是群里大佬整合的，刷了两遍，没遇到问题。我们可以把里面的文件都放到手机里，当然，有的不需要，是电脑上用的。</p>
<p>注意:如果你系统没刷过机，先进入rec模式，看看是不是系统1，不是请从系统1打开系统重启，在进行以下操作。因为我买的二手，卖家刷了内核。所以没有这一步。</p>
<p>首先先解压，然后找到lrogongjuxiang，解压，打开LR工具，专门刷手机recovery的。<br><img src="/imgs-Android/Los_02.png" alt></p>
<p>我们把rec2.8.4放进LR工具箱里，当然，你的平板要先打开usb调试。一会儿就进刷好并进入rec(recovery简称)模式.</p>
<img src="/imgs-Android/Los_03.jpg" height="700px," width="300px/">

<p>我们可以看到 TWRP为 V2.8.4版本。这里，用红字简单标示它们是干什么的。Install是我们闪存(内存/外存)的文件，我们刷ROM、安装都在这里进行。Wipe是清除数据的，双清、三清、四清呀。Reboot是重启，里面有重启系统，重启rec，重启fastboot，关机好像也有。</p>
<img src="/imgs-Android/Los_05.jpg" height="700px," width="300px/">

<p>我们先四清，点Wipe-&gt;Advanced Wipe，进入到上面的图，只选前四个，滑动按钮。</p>
<img src="/imgs-Android/Los_06.jpg" height="700px," width="300px/">
接着返回第一次进来的界面，点Install，找到你存放下载的那些文件，我的直接放在根目录，点Repartition_MI_Pad_1_2GB_zardMi3.zip,这是合并分区包。

<p>接下来就是刷Los的rec-03.11.2018，还是在LR工具箱进行，和一开始的一样，刷完重启进入到rec模式</p>
<img src="/imgs-Android/Los_07.jpg" height="700px," width="300px/">

<p>上图就是新刷入的rec，3.2.1-0版本。</p>
<p>接下来卡刷Los 14.1的ROM包，一样进入到install，找到lineage-14.1的zip，刷完后点击Wipe-&gt;Advanced Wipe,进行双清，我觉得可以不用，但，还是跟着做吧。<br><img src="/imgs-Android/Los_09.jpg" height="700px," width="300px/"></p>
<p>现在开始重启系统，你可以按电源键，也可以点Reboot-&gt;System。</p>
<p><img src="/imgs-Android/Los_12.jpg" alt></p>
<p>当你看到一条弯线，屏幕变亮了，有三个球来回移动，最后看到这个logo，说明刷入成功了。</p>
<p>当然，Los要配合smoke内核，才使得米板1更流畅。关机，按音量上+电源进入rec模式，进入Install，找到smoke1.3.5.zip，刷入，重启，你也可以顺便刷入superSU超级管理来装黑域呀等其他软件。</p>
<p><img src="/imgs-Android/Los_13.jpg" alt></p>
<p>最后是刷入成功的图。</p>
<p>注意要，变砖有风险，刷机需谨慎！！！！！</p>
<p>如果刷机变砖了，按音量下+电源键进入fastboot，可以在这个界面刷入rec，在继续刷机。<br>米板1在rec不要黑屏，会关机变砖的…..<br>如果fastboot都进不去，只能骚操作用MIfalsh刷机。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（七）</title>
    <url>/2019/09/15/java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<p>这次记录几个常用的类，有Arrays、Math和Data这几个。而更新内容也会越来越少，主要是后面的我也不太会….<br>说一下计划，之后记录内部类，泛型和容器，异常，io，多线程，java基础篇也就完结啦。当然，学编程最重要的是逻辑思维，所以少不了数据结构。为了能成为全栈工程师，前端、数据库、servlet也很重要，共勉吧。也许有人会说少了框架，那东西，只是帮助开发，会用就行。基础才最重要。</p>
<a id="more"></a>

<h1 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h1><p>Arrays类为数组提供一些方法，还有一个单词Array，网上对它的解释为java中最基本的一个存储结构，两者还是不同的。</p>
<p>而Arrays里面的方法基本都是静态方法，所以可以不用new对象，直接使用。下面就介绍Arrays静态类提供常用的方法吧。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sort(Object)</td>
<td align="center">顺序排序，实现方法看着是归并排序</td>
</tr>
<tr>
<td align="center">toString（Object）</td>
<td align="center">返回数组元素的值</td>
</tr>
<tr>
<td align="center">length</td>
<td align="center">返回数组的长度</td>
</tr>
<tr>
<td align="center">equals(Object)</td>
<td align="center">比较两个对象的内容是否相等</td>
</tr>
<tr>
<td align="center">binarySearch（Object, int）</td>
<td align="center">二分查找该数在数组的位置</td>
</tr>
<tr>
<td align="center">copyOf(Object, int)</td>
<td align="center">复制数组的内容从0到int之间</td>
</tr>
<tr>
<td align="center">copyOfRange(Object, int, int)</td>
<td align="center">复制数组的内容</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;						//Arrays是外部类，要先引入</span><br><span class="line"></span><br><span class="line">public class frequentClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		int[] a = new int []&#123;3,4,1,7,5,9&#125;;</span><br><span class="line">		int[] b = &#123;1,4,7,0,4,2,6,5&#125;;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		Arrays.sort(a);						//把数组a排序</span><br><span class="line">		System.out.println(Arrays.toString(a));			//打印 [1, 3, 4, 5, 7, 9]。如果直接写a，打印的是a的哈希地址</span><br><span class="line">		</span><br><span class="line">		int c = Arrays.binarySearch(a, 4);			//查找数组a，3所在的位置，该数组一定是有序数组</span><br><span class="line">		System.out.println(c);					//打印 2</span><br><span class="line">		System.out.println(Arrays.binarySearch(b, 4));		//4也在数组b里，但不是有序，所以打印莫名其妙的数-7</span><br><span class="line"></span><br><span class="line">		a = Arrays.copyOf(b, 5);				//把数组b从[0，5)复制给数组a</span><br><span class="line">		System.out.println(Arrays.toString(a));			//打印 [1, 4, 7, 0, 4]</span><br><span class="line">		</span><br><span class="line">		a = Arrays.copyOfRange(b, 0, b.length);			//把数组从选定的开始位置到结束位置复制给a，这里从[0,b.length)</span><br><span class="line">									//数组length不用打括号，String的length()才有括号</span><br><span class="line">		</span><br><span class="line">		System.out.println(Arrays.toString(b));			//[1, 4, 7, 0, 4, 2, 6, 5]</span><br><span class="line">		System.out.println(Arrays.toString(a));			//[1, 4, 7, 0, 4, 2, 6, 5]</span><br><span class="line">		System.out.println(a.equals(b));			//打印 false。这里比较的是数组a和数组b的对象是否相等，要注意区别</span><br><span class="line">		System.out.println(Arrays.equals(a, b));		//打印 true。比较数组a和数组b的内容是否相等</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>数学类，提供很多数学上的计算，所以有很多，这里简要几个说明。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abs(Long |int |double |float)</td>
<td align="center">任意负数取正</td>
</tr>
<tr>
<td align="center">sin(double)</td>
<td align="center">三角函数的求解，还有其它，这里写一个做示范</td>
</tr>
<tr>
<td align="center">ceil(double)</td>
<td align="center">向上取整，类似于把浮点数加1再强制取整</td>
</tr>
<tr>
<td align="center">floor(double)</td>
<td align="center">向下取整，类似于把double强制转换为int型</td>
</tr>
<tr>
<td align="center">sqrt(double)</td>
<td align="center">开方 √double</td>
</tr>
<tr>
<td align="center">pow(double,double)</td>
<td align="center">求几次方，两者都是double，所以求整数的次方，可能会有精度问题，建议手写整数的次方</td>
</tr>
<tr>
<td align="center">random(double)</td>
<td align="center">求[0,1)之间的伪随机数</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Math默认在java.lang包,不需要导入包名</span><br><span class="line"></span><br><span class="line">public class frequentClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//Math类的两个常量</span><br><span class="line">		System.out.println(Math.E);				//打印 2.718281828459045</span><br><span class="line">		System.out.println(Math.PI);				//打印 3.141592653589793</span><br><span class="line"></span><br><span class="line">		System.out.println(Math.abs(-12));			//打印 12</span><br><span class="line">		System.out.println(Math.sin(30*Math.PI/180));		//打印 0.49999999999999994。sin30°= 1/2，精度问题</span><br><span class="line">		System.out.println(Math.ceil(1.2));			//打印 2.0</span><br><span class="line">		System.out.println(Math.floor(1.5));			//打印 1.0</span><br><span class="line">		System.out.println(Math.sqrt(25));			//打印 5.0</span><br><span class="line">		System.out.println(Math.pow(2, 4));			//打印 16.0</span><br><span class="line">		System.out.println(Math.random());			//打印[0,1)之间的伪随机数</span><br><span class="line">		System.out.println((int)(Math.random()*10+1)); 		//打印[1,10]之间的随机整数</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在Math类里还有一个类,那就是BigDecimal类，进行大数运算，你可以输入超过long和double数据范围，所以它的精度也挺高，也经常用于浮点数的加减问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.math.BigDecimal;						//Math.BigDecimal类里</span><br><span class="line"></span><br><span class="line">public class frequentClass &#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">		BigDecimal b1 = new BigDecimal(&quot;123.415&quot;);		//进行字符串的浮点输入和普通的浮点输入</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">		</span><br><span class="line">		BigDecimal b2 = new BigDecimal(123.415);</span><br><span class="line">		System.out.println(b2);</span><br><span class="line">		</span><br><span class="line">		BigDecimal b3 = new BigDecimal(&quot;123.415&quot;);</span><br><span class="line">		System.out.println(b3);</span><br><span class="line"></span><br><span class="line">		System.out.println(b1.equals(b2));			//比较，在java大部分类都重写了equals方法，不再是比较对象是否相等</span><br><span class="line">		System.out.println(b1.equals(b3));</span><br><span class="line">		</span><br><span class="line">		double d = b1.add(b3).doubleValue();			//add()进行相加，doubleValue()转化为浮点相加，因为字符串没有基本运算</span><br><span class="line">		System.out.println(d);</span><br><span class="line">		</span><br><span class="line">		double d2 = b1.subtract(b3).doubleValue();</span><br><span class="line">		System.out.println(d2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java07_01.png" alt></p>
<p>可以看得出来，BigDecimal使用的时候，如果是浮点型，一定要写成字符串的形式，否则，还是可能会出现精度问题。</p>
<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p>Date类在以前是一个很强的类，所以就被削弱了，很多方法都给了Calendar类。下面这是它的使用方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class frequentClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Date d = new Date();				//新建一个Date()对象</span><br><span class="line">		System.out.println(d);				//打印 Sun Sep 15 17:25:25 CST 2019，打印的是当前时间</span><br><span class="line">		</span><br><span class="line">		System.out.println(new Date(1000)); 		//打印 Thu Jan 01 08:00:01 CST 1970</span><br><span class="line">								//设置从1970年1月1号0时0分0秒到1000毫秒的时间</span><br><span class="line">								//可能由于时差的问题，所以显示的是8点</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		System.out.println(d.getTime());		//打印 1568539525671,获取当前时间的毫秒</span><br><span class="line">		d.setTime(1000);				//和new Date(long)一样，设置纪元时间后的1000毫秒</span><br><span class="line">		System.out.println(d); 				//打印 Thu Jan 01 08:00:01 CST 1970</span><br><span class="line">		System.out.println(d.before(new Date(1200)));	//打印 true。1000是否在1200之前</span><br><span class="line">		System.out.println(d.after(new Date(1200)));	//打印 false。1000是否在1200之后</span><br><span class="line"></span><br><span class="line">		Date d1 = new Date(2000);</span><br><span class="line">		Date d2 = new Date(1500);</span><br><span class="line">		System.out.println(d1.compareTo(d2));		//打印1， 如果d1比d2大，相等返回0，小于返回-1</span><br><span class="line"></span><br><span class="line">		//下面则是被废弃的方法，能用，但不建议使用</span><br><span class="line">		d = new Date();</span><br><span class="line">		System.out.println(&quot;获取年:&quot;+(d.getYear()+1900));//获取年:2019</span><br><span class="line">		System.out.println(&quot;获取月:&quot;+d.getMonth());	//获取月:8。当然现在9月，因为英语日期不是按数字的，所以也是从0开始</span><br><span class="line">		System.out.println(&quot;获取日:&quot;+d.getDate());	//获取日:15</span><br><span class="line">		System.out.println(&quot;获取时:&quot;+d.getHours());	//获取时:17</span><br><span class="line">		System.out.println(&quot;获取分:&quot;+d.getMinutes());	//获取分:34</span><br><span class="line">		System.out.println(&quot;获取秒:&quot;+d.getSeconds());	//获取秒:29</span><br><span class="line">		System.out.println(&quot;获取星期:&quot;+d.getDay());	//获取星期:0。星期也是从0开始，0是星期天</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><p>Calendar则替代了Date类废弃的方法，但，首先，我们先认识时间在java的字段表示。</p>
<table>

<tr>
<th>YEAR</th>
<th>MONTH</th>
<th>WEEK_OF_YEAR</th>
<th>WEEK_OF_MONTH</th>
<th>DATE</th>
<th>DAY_OF_MONTH</th>
<th>DAY_OF_YEAR</th>
</tr>
<tr>
<td>年</td>
<td>月</td>
<td>本年的周数</td>
<td>本月的周数</td>
<td>本月的日期</td>
<td>本月的日期</td>
<td>本年的日数</td>
</tr>
<tr>
<th>DAY_OF_WEEK</th>
<th>AM_PM</th>
<th>HOUR</th>
<th>HOUR_OF_DAY</th>
<th>MINUTE</th>
<th>SECOND</th>
<th>MILLISECOND</th>
</tr>
<tr>
<td>星期几</td>
<td>早上_下午</td>
<td>小时(12小时制)</td>
<td>小时(24小时制)</td>
<td>分钟</td>
<td>秒钟</td>
<td>毫秒</td>
</tr>
<tr>
<th>SUNDAY</th>
<th>MONDAY</th>
<th>TUESDAY</th>
<th>WEDNESDAY</th>
<th>THURSDAY</th>
<th>FRIDAY</th>
<th>SATURDAY</th>
</tr>
<tr>
<td>星期天</td>
<td>星期一</td>
<td>星期二</td>
<td>星期三</td>
<td>星期四</td>
<td>星期五</td>
<td>星期六</td>
</tr>
<tr>
<th>JANUARY</th>
<th>FEBRUARY</th>
<th>MARCH</th>
<th>APRIL</th>
<th>MAY</th>
<th>JUNE</th>
<th>JULY</th>
</tr>
<tr>
<td>一月</td>
<td>二月</td>
<td>三月</td>
<td>四月</td>
<td>五月</td>
<td>六月</td>
<td>七月</td>
</tr>
<tr>
<th>AUGUST</th>
<th>SEPTEMBER</th>
<th>OCTOBER</th>
<th>NOVEMBER</th>
<th>DECEMBER</th>
<th>AM</th>
<th>PM</th>
</tr>
<tr>
<td>八月</td>
<td>九月</td>
<td>十月</td>
<td>十一月</td>
<td>十二月</td>
<td>上午</td>
<td>下午</td>
</tr>
</table>

<p>下面是日期的获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Calendar;							//Calendar也是外部类</span><br><span class="line"></span><br><span class="line">public class frequentClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Calendar c = Calendar.getInstance();				//获取当前时间</span><br><span class="line">		System.out.println(&quot;年:&quot;+c.get(Calendar.YEAR));</span><br><span class="line">		System.out.println(&quot;月:&quot;+c.get(Calendar.MONTH));		//月份从0开始</span><br><span class="line">		System.out.println(&quot;日:&quot;+c.get(Calendar.DATE));</span><br><span class="line">		System.out.println(&quot;日:&quot;+c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">		System.out.println(&quot;时:&quot;+c.get(Calendar.HOUR));			//12小时制</span><br><span class="line">		System.out.println(&quot;时:&quot;+c.get(Calendar.HOUR_OF_DAY));		//24小时制</span><br><span class="line">		System.out.println(&quot;分:&quot;+c.get(Calendar.MINUTE));</span><br><span class="line">		System.out.println(&quot;秒:&quot;+c.get(Calendar.SECOND));		//星期日为第一天</span><br><span class="line">		System.out.println(&quot;星期:&quot;+c.get(Calendar.DAY_OF_WEEK));</span><br><span class="line">		System.out.println(&quot;本月第几周:&quot;+c.get(Calendar.WEEK_OF_MONTH));</span><br><span class="line">		System.out.println(&quot;本年第几周:&quot;+c.get(Calendar.WEEK_OF_YEAR));</span><br><span class="line">		System.out.println(&quot;上午？下午？&quot;+c.get(Calendar.AM_PM));	//上午返回0，下午返回1</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是设置时间。</p>
<p>我们也要先认识日期在SimpleDateFormat类的表示格式。</p>
<table>
<tr>
<th>y</th>
<th>M</th>
<th>w</th>
<th>W</th>
<th>D</th>
<th>d</th>
<th>H</th>
<th>k</th>
<th>K</th>
<th>h</th>
</tr>
<tr>
<td>年</td>
<td>本年的月份</td>
<td>本年的周数</td>
<td>本月的周数</td>
<td>本年的天数</td>
<td>本月的天数</td>
<td>小时[0,23]</td>
<td>小时[1,24]</td>
<td>小时[0,11]</td>
<td>小时[1,12]</td>
</tr>
<tr>
<th>m</th>
<th>s</th>
<th>S</th>
<th>a</th>
<th>F</th>
<th>E</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
<tr>
<td>分钟</td>
<td>秒</td>
<td>毫秒</td>
<td>AM/PM</td>
<td>本月的周数</td>
<td>星期几</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>

<p>个数只是表示占的位置，比如1999年，用yyyy表示1999，yy表示99。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class frequentClass &#123;</span><br><span class="line">	public static void main(String[] args) throws ParseException &#123;		//throws抛出异常</span><br><span class="line">		Date d = new Date();</span><br><span class="line">		SimpleDateFormat sdf = new SimpleDateFormat();			//设置输出日期格式</span><br><span class="line">		String str = sdf.format(d);					//把日期转换成字符串</span><br><span class="line">		System.out.println(str);					//打印 19-9-15 下午6:51</span><br><span class="line">		</span><br><span class="line">		str = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date());</span><br><span class="line">		System.out.println(str); 					//打印 2019-09-15 18:51:45</span><br><span class="line">		</span><br><span class="line">		sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);</span><br><span class="line">		str = &quot;2000/1/2 3:4:5&quot;;						//输入的格式一定要与上面的一致</span><br><span class="line">		Date date = sdf.parse(str);					//把字符串转换为日期</span><br><span class="line">		System.out.println(date);					//打印 Sun Jan 02 03:04:05 CST 2000</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（六）</title>
    <url>/2019/09/13/java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<p>这次主要记录抽象类、接口和String的其它学习。</p>
<a id="more"></a>

<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>什么是抽象类呢？定义一个类，我们可以不必完全实现它里面的功能，这就是抽象类。没有具体的方法，就是抽象。</p>
<p>下面是具体的使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal						//定义一个抽象类animal</span><br><span class="line">&#123;</span><br><span class="line">	String color;						//抽象类里可以有属性</span><br><span class="line">	</span><br><span class="line">	public Animal(String color) &#123;				//也有构造方法</span><br><span class="line">		this.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">								//抽象类有抽象方法，修饰符都是abstract</span><br><span class="line">	abstract void sound();					//抽象方法可以protected、public、default修饰</span><br><span class="line">	protected abstract void nose();</span><br><span class="line">	public abstract void eyes();</span><br><span class="line">	</span><br><span class="line">	public void leg()					//抽象类也可以实现普通方法</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;短腿&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	abstract String skinColor()				//抽象方法不能在抽象类实现</span><br><span class="line">	&#123;</span><br><span class="line">		return color;</span><br><span class="line">	&#125;</span><br><span class="line">	final abstract void high();				//抽象方法要能够被子类继承和实现</span><br><span class="line">	private  abstract void hair();</span><br><span class="line">	static abstract void weight();</span><br><span class="line">	*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为抽象类很多方法并未实现，我们也不能new一个抽象类的对象。不能凭空产生一个方法。<br>要想使用抽象类的方法，我们只能继承，如果子类也不能全实现抽象类的方法，那子类也必须是抽象类，直到能全实现方法的子类，我们新建对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class abstractTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Animal cat = new Cat(&quot;白色&quot;);</span><br><span class="line">		System.out.println(cat.color);			//打印 白色</span><br><span class="line">		cat.eyes();					//打印 蓝眼睛</span><br><span class="line">		cat.leg();					//打印 短腿</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Animal						//定义一个抽象类animal</span><br><span class="line">&#123;</span><br><span class="line">	String color;						//抽象类里可以有属性</span><br><span class="line">	</span><br><span class="line">	public Animal(String color) &#123;				//也有构造方法</span><br><span class="line">		this.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">								//抽象类有抽象方法，修饰符都是abstract</span><br><span class="line">	abstract void sound();					//抽象方法可以protected、public、default修饰</span><br><span class="line">	protected abstract void nose();</span><br><span class="line">	public abstract void eyes();</span><br><span class="line">	</span><br><span class="line">	public void leg()					//抽象类也可以实现普通方法</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;短腿&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Felidae extends Animal				//Felidae并没有实现Animal全部方法，只能定义为抽象类</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	public Felidae(String color) &#123;</span><br><span class="line">		super(color);</span><br><span class="line">	&#125;</span><br><span class="line">	void sound()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;喵喵喵~~~&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat extends Felidae					//Cat实现全部方法</span><br><span class="line">&#123;</span><br><span class="line">	public Cat(String color) &#123;</span><br><span class="line">		super(color);</span><br><span class="line">	&#125;</span><br><span class="line">	protected void nose()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;鼻子&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void eyes()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;蓝眼睛&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口和抽象类差不多，但是，比抽象类更规范。<br>它不实现任何方法，它的一般只有常量和抽象方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Car</span><br><span class="line">&#123;</span><br><span class="line">	public static final int LENGTH = 280;					//定义一个常量</span><br><span class="line">	/*public final static*/ int WIDTH = 120;			</span><br><span class="line">	public abstract void sound();						//抽象方法</span><br><span class="line">	/*public abstract*/ void weigth();</span><br><span class="line">	static void xx()							//静态方法，好像不推荐使用</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;--------&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Sedan c = new Sedan();</span><br><span class="line">		c.sound();							//打印 滴滴滴！！！</span><br><span class="line">		c.weigth();							//打印 it</span><br><span class="line">		System.out.println(c.LENGTH);					//打印 280</span><br><span class="line">		Car.xx();							//打印 --------</span><br><span class="line">		c.color();							//打印 白色</span><br><span class="line">		c.feel();							//打印 舒服</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Car</span><br><span class="line">&#123;</span><br><span class="line">	public static final int LENGTH = 280;					//定义一个常量</span><br><span class="line">	/*public final static*/ int WIDTH = 120;			</span><br><span class="line">	public abstract void sound();						//抽象方法</span><br><span class="line">	/*public abstract*/ void weigth();</span><br><span class="line">	static void xx()							//静态方法，好像不推荐使用</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;--------&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface InterF</span><br><span class="line">&#123;</span><br><span class="line">	void feel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class CarStyle</span><br><span class="line">&#123;</span><br><span class="line">	abstract void color();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sedan extends CarStyle implements Car,InterF				//继承只能单继承，但接口可以多继承，接口实现用implements</span><br><span class="line">&#123;</span><br><span class="line">	@Override								//表明实现的方法，一般编译器在快捷键输入会自动帮忙生成	</span><br><span class="line">	public void sound() &#123;</span><br><span class="line">		System.out.println(&quot;滴滴滴！！！&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void weigth() &#123;</span><br><span class="line">		System.out.println(&quot;1t&quot;);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void feel()&#123;</span><br><span class="line">		System.out.println(&quot;舒服&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	void color()&#123;</span><br><span class="line">		System.out.println(&quot;白色&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类和接口的共同点:<br>1、都有抽象方法。<br>2、都需要被子类继承。</p>
<p>抽象类和接口的不同点:<br>1、抽象类的变量只是普通变量，接口是常量。<br>2、抽象类可以有具体的方法。<br>3、接口相比抽象类讲，定义的是一种规范。<br>4、接口可以多继承。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String是不可变的引用类型。使用的时候总会产生很多新的对象，所以就有了StringBuffer和StringBuilder两个类，它们都是继承于AbstractStringBuilder这个抽象类，而都现实了父类的方法，所以它们相当于双胞胎兄弟。</p>
<p>而双胞胎也有差别，它们的差别就是线程是否安全。</p>
<p>StringBuider下实现append()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public StringBuilder append(Object obj) &#123;</span><br><span class="line">    return append(String.valueOf(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer下实现append()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized StringBuffer append(Object obj) &#123;</span><br><span class="line">    toStringCache = null;</span><br><span class="line">    super.append(String.valueOf(obj));</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看得出来，区别不是很大，只是在StringBuffer下，方法都多了一个synchronized修饰符，该修饰符保证线程安全。</p>
<p>线程安全解决啥呢。大致就是我们使用电脑时，不是一个只运行一个软件，而是很多个在同时运行，这时有多个软件修改了一个文件内容和多个软件同时获取该文件内容，在同一时间下，就可能出现错误。所以要保证线程安全，一个一个来，慢慢校验。所以线程安全提供了安全性，但效率会降低。</p>
<p>而StringBuider和StringBuffer方法都差不多一样，所以了解其中一个就行，以Stringbuider为例。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">使用说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">append(Object)</td>
<td align="center">实现多个字符串拼接，可以为任意类型</td>
</tr>
<tr>
<td align="center">delete(int, int)</td>
<td align="center">删除起始位置到终止位置(不包括终止位置)之间的元素</td>
</tr>
<tr>
<td align="center">deletCharAt(int)</td>
<td align="center">删除该下标的元素</td>
</tr>
<tr>
<td align="center">replce(int, int, String</td>
<td align="center">把起始位置到终止位置(不包括终止位置)之间的元素修改为新的字符串</td>
</tr>
<tr>
<td align="center">insert(int, Object)</td>
<td align="center">在该下标插入某个元素</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	StringBuilder str = new StringBuilder();</span><br><span class="line">	str.append(&quot;a&quot;);			//拼接任意元素，&quot;a&quot;,12,1.2到str</span><br><span class="line">	str.append(12);</span><br><span class="line">	str.append(1.2);</span><br><span class="line">	System.out.println(str);		//打印 a121.2</span><br><span class="line">	</span><br><span class="line">	str.delete(3,5);			//删除从3到5之间的元素[3,5)</span><br><span class="line">	System.out.println(str);		//打印 a122</span><br><span class="line">	</span><br><span class="line">	str.deleteCharAt(0);			// 删除下标为0的元素</span><br><span class="line">	System.out.println(str);		//打印 122</span><br><span class="line">	</span><br><span class="line">	str.replace(1, 2, &quot;java&quot;);		//下标[1,2)变换为&quot;java&quot; 	</span><br><span class="line">	System.out.println(str);		//打印 1java2</span><br><span class="line">	</span><br><span class="line">	str.insert(1, &quot;hello&quot;);			//在下标为1处插入字符串&quot;hello&quot;</span><br><span class="line">	System.out.println(str);		//打印 1hellojava2</span><br><span class="line">	str.insert(0, true);			//在下标为0处插入布尔值true</span><br><span class="line">	System.out.println(str);		//打印 true1hellojava2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是都是StringBuider常用的方法，当然还有indexOf()、lastIndexOf()这样的字符匹配，length()长度，equals()比较内容等等，这些以前也用过的方法。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>进制转换</title>
    <url>/2019/09/11/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>十进制是我们常常使用的。但是，在计算机中，通用进制是2进制，所以本次写进制转换。在java基础（一）最后一段也用java的类快速转换，今天就简单的实现。</p>
<a id="more"></a>

<p>代码略长，简单讲一下，如果是整数，对2取余，最把每次得到的余数倒着写一遍。如果有小数，整数同上，但小数部分乘2，积满1写1并-1，不满写0继续乘。</p>
<p>注意：<br>如果是负整数，我们要先算原码再求反码最后补码才是答案。<br>而小数，要进过偏移，组合才是答案。</p>
<p>以下代码注意:浮点数可能和java类写的答案有误差…..不知道怎么解决…. :P</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Scanner;						//如果要使用其他包的类或类库，一定要导入相应的包，否则运行时虚拟局不知道在哪</span><br><span class="line"></span><br><span class="line">/**									//文档注释，说明类的使用，其方法、字段的说明等等</span><br><span class="line"> * 测试十进制的任意数字，转换成二进制、十六进制的方式</span><br><span class="line"> * @author KEKEXI</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BinaryConversion &#123;						//类名：进制转换</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.print(&quot;请输入十进制的数:&quot;);</span><br><span class="line">		</span><br><span class="line">		Scanner sc = new Scanner(System.in);			//定义一个输入的引用 sc</span><br><span class="line">		String num = sc.next();					//输入一个浮点型sc.next()，并赋值给num</span><br><span class="line">		ChangeNum cn = new ChangeNum(num);		</span><br><span class="line">		cn.getNumbers();					//把字符串转换成数字，分为整数部分和浮点数部分</span><br><span class="line">		</span><br><span class="line">		System.out.print(&quot;输出转换成的二进制：&quot;);</span><br><span class="line">		if(cn.judgeNum())					//判断num是整数呢，还是浮点数</span><br><span class="line">		&#123;</span><br><span class="line">			Binary br = new Binary(cn.getIntPart());	//输出二进制和十六进制</span><br><span class="line">			br.pinrtNum();</span><br><span class="line">			System.out.println(&quot;JAVA类的整数二进制:&quot;+Integer.toBinaryString(Integer.parseInt(num)));	//比较输出是否和java写的一样</span><br><span class="line">			</span><br><span class="line">			System.out.print(&quot;\n输出转换成的十六进制：&quot;);</span><br><span class="line">			Hexadecimal hc = new Hexadecimal(br.getA());</span><br><span class="line">			hc.printHX();</span><br><span class="line">			System.out.println(&quot;JAVA类的整数十六进制:&quot;+Integer.toHexString(Integer.parseInt(num)));</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			BinaryDouble bd = new BinaryDouble(cn.getIntPart(), cn.getDouPart());</span><br><span class="line">			bd.pinrtNum();</span><br><span class="line">			System.out.println(&quot;JAVA类的浮点型二进制:&quot;+Integer.toBinaryString(Float.floatToIntBits(Float.parseFloat(num))));</span><br><span class="line">			</span><br><span class="line">			System.out.print(&quot;\n输出转换成的十六进制：&quot;);</span><br><span class="line">			Hexadecimal hc = new Hexadecimal(bd.getA());</span><br><span class="line">			hc.printHX();</span><br><span class="line">			System.out.println(&quot;JAVA类的浮点型十六进制:&quot;+Integer.toHexString(Float.floatToIntBits(Float.parseFloat(num))));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取整型和浮点型</span><br><span class="line">class ChangeNum</span><br><span class="line">&#123;</span><br><span class="line">	private String num;						//private私有属性，提升代码安全性</span><br><span class="line">	private int intPart;</span><br><span class="line">	private int douPart;</span><br><span class="line">	</span><br><span class="line">	public ChangeNum(String num)					//构造方法，获取num</span><br><span class="line">	&#123;</span><br><span class="line">		this.num = num;</span><br><span class="line">	&#125;</span><br><span class="line">	public ChangeNum() &#123;&#125;						//默认构造方法，在这不需要</span><br><span class="line">	</span><br><span class="line">	public boolean judgeNum()					//判断是否整数的方法</span><br><span class="line">	&#123;</span><br><span class="line">		int k = 0;						//定义k，找到&apos;.&apos;的位置，看看有没有&quot;假浮点数&quot;，如12.0000，有就化为整数型</span><br><span class="line">		boolean flag = false;					//判断是否为&quot;假浮点数&quot;</span><br><span class="line">		for(int i=0; i&lt;this.num.length(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(this.num.charAt(i) == &apos;.&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">				k = i;</span><br><span class="line">				flag = true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int sum = 0;						//定义sum，计算小数点后相加的和是否为0，为0说明是假浮点数</span><br><span class="line">		if(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			for(int i=k+1; i&lt;num.length(); i++)</span><br><span class="line">			&#123;</span><br><span class="line">				sum += num.charAt(i)-&apos;0&apos;;		//字符的&apos;0&apos;是48，所以要减去&apos;0&apos;或48才是0</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum == 0) return true;</span><br><span class="line">		return false;						//为浮点型，返回false</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void getNumbers()					//浮点数分割，获取整数和浮点数部分</span><br><span class="line">	&#123;</span><br><span class="line">		if(judgeNum())</span><br><span class="line">		&#123;</span><br><span class="line">			this.intPart = (int)Double.parseDouble(num);	//可能为&quot;假浮点数&quot;，先转为double，在转为int</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			String[] str = this.num.split(&quot;\\.&quot;);		//字符串切割，.为特殊字符，要用\\表示才是普通.</span><br><span class="line">									//只要整数部分和浮点数部分，字符就2个</span><br><span class="line">			this.intPart = Integer.parseInt(str[0]);	//this,指当前类，给当前类的intPart变量赋值</span><br><span class="line">			this.douPart = Integer.parseInt(str[1]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getIntPart()						//变量为私有，要设置和获取该变量，有set和get方法，</span><br><span class="line">	&#123;								//设置只能我设置，你只能获取，封装性</span><br><span class="line">		return intPart;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getDouPart()</span><br><span class="line">	&#123;</span><br><span class="line">		return douPart;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//整型</span><br><span class="line">class Binary</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	private int[] a = new int[32];					//定义a数组，装二进制数，可以为32，也可以为64，都行</span><br><span class="line">	private int i = a.length-1;					//i为0还是数组长度在输出上有关系</span><br><span class="line">									//为0要把数组逆输出，因为我们最先计算的数放到了前面</span><br><span class="line">									//比如2，先得a[0]=0, a[1]=1, 答案应该为10，逆输出</span><br><span class="line">									//而i=数组长度，a[1]=1,a[0]=0,顺输出</span><br><span class="line">	private int intPart;						//整数部分就算一个整数，定义该变量就行</span><br><span class="line">	</span><br><span class="line">	Binary(int intPart)										</span><br><span class="line">	&#123;</span><br><span class="line">		this.intPart = intPart;</span><br><span class="line">		intNum(this.intPart, a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Binary() &#123;&#125;						//因为有继承关系，要创建默认构造方法</span><br><span class="line"></span><br><span class="line">	public void intNum(int intPart, int[] a/*, int i*/)		//计算二进制的值</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		if(intPart &lt; 0) 					//如果整数是负的，变为正，一切都以正数处理</span><br><span class="line">		&#123;</span><br><span class="line">			intPart = -intPart;</span><br><span class="line">			a[0] = 1;					//符号位变为1，1为负数，0为正数</span><br><span class="line">		&#125;</span><br><span class="line">		while(intPart != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i--] = intPart%2;				//变为啥，就取啥余，其他进制类同，所以很简单</span><br><span class="line">									//位移符，&gt;&gt;右移为除，&lt;&lt;左移为乘</span><br><span class="line">									// &gt;&gt;1右移一位为除以2的一次方(2^1)</span><br><span class="line">			intPart &gt;&gt;= 1;					// &gt;&gt;2右移两位为除以2的2次方(2^2)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void complementCode(int[] a)				//求补码，正数原码 = 反码 = 补码，所以不用求</span><br><span class="line">	&#123;</span><br><span class="line">		if(a[0] == 1)						//先判断符号位</span><br><span class="line">		&#123;</span><br><span class="line">			for(int i=1; i&lt;a.length; i++)			//先求反码，除符号位，1变0，0变1</span><br><span class="line">			&#123;</span><br><span class="line">				//if(a[i] == 1) a[i] = 0;</span><br><span class="line">				//else a[i] = 1;</span><br><span class="line">				</span><br><span class="line">				//a[i] = a[i]==0 ? 1:0;</span><br><span class="line">				</span><br><span class="line">				a[i] = (a[i]+1)%2;							</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			a[a.length-1] += 1;				//补码 = 反码+1</span><br><span class="line">			</span><br><span class="line">			for(int i=a.length-1; i&gt;0; i--)			//如果有进位，进位变0，前一位加1</span><br><span class="line">			&#123;</span><br><span class="line">				if(a[i] == 2)</span><br><span class="line">				&#123;</span><br><span class="line">					a[i] = 0;</span><br><span class="line">					a[i-1] += 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void pinrtNum()</span><br><span class="line">	&#123;</span><br><span class="line">		complementCode(a);					//调用补码方法</span><br><span class="line">		</span><br><span class="line">		for(int j=0; j&lt;a.length; j++)				//打印输出，没4位空一格，好看</span><br><span class="line">		&#123;</span><br><span class="line">			if(j%4 == 0 &amp;&amp; j != 0) System.out.print(&apos; &apos;);</span><br><span class="line">			System.out.print(a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int[] getA()							</span><br><span class="line">	&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//浮点型</span><br><span class="line">class BinaryDouble extends Binary					//继承父类</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	private int[] a = new int[32];					//由于父类私有，在重新定义，也可以把父类的修饰符改改</span><br><span class="line">	private int i = 0;</span><br><span class="line">	</span><br><span class="line">	private int intPart;</span><br><span class="line">	private int douPart;								</span><br><span class="line">	</span><br><span class="line">	public BinaryDouble()&#123;&#125;</span><br><span class="line">	public BinaryDouble(int intPart,int douPart)</span><br><span class="line">	&#123;</span><br><span class="line">		this.intPart = intPart;</span><br><span class="line">		this.douPart = douPart;</span><br><span class="line">		DouNum(intPart, douPart);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	public void DouNum(int intPart, int douPart)</span><br><span class="line">	&#123;</span><br><span class="line">		if(intPart &lt; 0)						//判断是否为负数</span><br><span class="line">		&#123;</span><br><span class="line">			a[0] = 1;					//获取符号位</span><br><span class="line">			intPart = -intPart; 			</span><br><span class="line">		&#125;	</span><br><span class="line"></span><br><span class="line">		//求整数部分</span><br><span class="line">		int[] numInt = new int[a.length-1];			//a[0]为符号位，所以结果只能比数组a少1</span><br><span class="line">		int intI = numInt.length-1;				//还是倒着求二进制</span><br><span class="line"></span><br><span class="line">		int intPartT = intPart;					//intPart要用两次，所以这里临时变量求解</span><br><span class="line">		</span><br><span class="line">		while(intPartT != 0)					//本来要用父类的intNum()方法，但无奈，不可以址传递，intI的值还是31</span><br><span class="line">		&#123;</span><br><span class="line">			numInt[intI] = intPartT%2;</span><br><span class="line">			intI--;</span><br><span class="line">			intPartT &gt;&gt;= 1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">												</span><br><span class="line">		int e = 127+numInt.length-intI-2;			//length-1-intI-1求移动小数位，在加127的偏移位</span><br><span class="line">		</span><br><span class="line">		int[] E = new int[a.length-1];</span><br><span class="line">		int intE = E.length-1;					//也是倒着求二进制</span><br><span class="line">		</span><br><span class="line">		while(e != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			E[intE] = e%2;</span><br><span class="line">			intE--;</span><br><span class="line">			e &gt;&gt;= 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int j=intE+1; j&lt;E.length; j++)			//一开始赋了符号位，现在先赋E</span><br><span class="line">		&#123;</span><br><span class="line">			a[++i] = E[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for(int j = intI+2; j&lt;numInt.length; j++)		//在赋整数部分</span><br><span class="line">		&#123;</span><br><span class="line">			a[++i] = numInt[j];</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">		int[] numDou = new int[a.length-1];			//求浮点型部分</span><br><span class="line">		int intD = 0;						//浮点部分不用倒过来，直接从0开始计算二进制每一位</span><br><span class="line">		</span><br><span class="line">		int t = douPart;				</span><br><span class="line">		int z = 1;						//因为是变为整数，相当于算1.0</span><br><span class="line">		while(t != 0)</span><br><span class="line">		&#123;</span><br><span class="line">			t /= 10;</span><br><span class="line">			z *= 10;</span><br><span class="line">		&#125;</span><br><span class="line">		while(douPart!=0 &amp;&amp; intD&lt;numDou.length)			//浮点计算，每次*2，大于&quot;1.0&quot;，numDou[intD] = 1</span><br><span class="line">		&#123;</span><br><span class="line">			douPart &lt;&lt;= 1;</span><br><span class="line">			numDou[intD++] = douPart&gt;=z ? douPart/z : 0;</span><br><span class="line">			</span><br><span class="line">			if(douPart&gt;=z)douPart -= z;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		for(int j = 0; j&lt;intD &amp;&amp; i&lt;31; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[++i] = numDou[j];</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	public void pinrtNum()						//重新父类，因为我们不需要算补码</span><br><span class="line">	&#123;</span><br><span class="line">		for(int j=0; j&lt;a.length; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if(j%4 == 0 &amp;&amp; j != 0) System.out.print(&apos; &apos;);</span><br><span class="line">			System.out.print(a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	public int[] getA()		</span><br><span class="line">	&#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Hexadecimal</span><br><span class="line">&#123;</span><br><span class="line">	private int[] a = new int [32];</span><br><span class="line">	private int[] ans = new int[8];</span><br><span class="line">	</span><br><span class="line">	public Hexadecimal(int[] a)</span><br><span class="line">	&#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">	&#125;</span><br><span class="line">	public void aglormHX()						//求16进制</span><br><span class="line">	&#123;</span><br><span class="line">		int k = 0;</span><br><span class="line">		int j = 3;						//每4位为一组，[0,3]四位,把j=3改为2，就是求八进制</span><br><span class="line">		for(int i=0; i&lt;a.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[k] += a[i]&lt;&lt;j;				//因为数组a得到的答案为顺序，第一位为2^3,第二位为2^2...2……0</span><br><span class="line">			</span><br><span class="line">			if(j==0)					//求完每组，进行下一组</span><br><span class="line">			&#123;</span><br><span class="line">				k++;						</span><br><span class="line">				j = 3;</span><br><span class="line">			&#125;</span><br><span class="line">			else j--;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printHX()</span><br><span class="line">	&#123;</span><br><span class="line">		aglormHX();</span><br><span class="line">		for(int i=0; i&lt;ans.length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			switch(ans[i])					//特殊处理[10,15]的数</span><br><span class="line">			&#123;</span><br><span class="line">			case 10:</span><br><span class="line">				System.out.print(&apos;A&apos;);</span><br><span class="line">				break;</span><br><span class="line">			case 11:</span><br><span class="line">				System.out.print(&apos;B&apos;);</span><br><span class="line">				break;</span><br><span class="line">			case 12:</span><br><span class="line">				System.out.print(&apos;C&apos;);</span><br><span class="line">				break;</span><br><span class="line">			case 13:</span><br><span class="line">				System.out.print(&apos;D&apos;);</span><br><span class="line">				break;</span><br><span class="line">			case 14:</span><br><span class="line">				System.out.print(&apos;E&apos;);</span><br><span class="line">				break;</span><br><span class="line">			case 15:</span><br><span class="line">				System.out.print(&apos;F&apos;);</span><br><span class="line">				break;</span><br><span class="line">			default :</span><br><span class="line">				System.out.print(ans[i]);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;H&quot;);				//&quot;H&quot;表明它是十六进制</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>番外</tag>
        <tag>程序</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（五）</title>
    <url>/2019/09/06/java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>这次主要记录的是基本数据类型的封装和String的基本使用。</p>
<a id="more"></a>

<h1 id="基本数据类型的封装"><a href="#基本数据类型的封装" class="headerlink" title="基本数据类型的封装"></a>基本数据类型的封装</h1><p>在java中，八种数据类型也可以封装成对象。所以java相较于C++，面向对象更彻底，而相对于只有面向对象的语言，又有容易操作的面向过程的处理。</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">封装数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<p>而封装的数据类型，保证了数据的安全性，也为我们提供一些方法，比如把字符串转换成整数，小数之类的，重写的equals()方法来比较是否相等。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Integer in = new Integer(10);</span><br><span class="line">	System.out.println(in);	//打印 10</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是封装，那也就是对象，需要实例化，看样子和平时int a = 10；没啥区别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Integer in = new Integer(10);</span><br><span class="line">	Integer in2 = new Integer(10);</span><br><span class="line">	</span><br><span class="line">	System.out.println(in == in2);	//打印 false</span><br><span class="line">	System.out.println(in.equals(in2)); 	//打印 true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是 == 的注意，只比较基本变量的值是否相等和对象是否相等，对象相等的条件是引用的地址是否同一个。所以这里不出意外， false。<br>而equals()方法在Object也是比较值或地址是否相等，当在这重写了equals()方法，看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    if (obj instanceof Integer) &#123;</span><br><span class="line">        return value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面则是把字符串变为整型各种方法，虽然最后值都是一样。但，运算不一样，parseInt()把它默认当做十进制的1000表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	String str = &quot;1000&quot;;</span><br><span class="line">	</span><br><span class="line">	int in = Integer.parseInt(str);	</span><br><span class="line">	</span><br><span class="line">	int in2 = new Integer(str).intValue();</span><br><span class="line">	</span><br><span class="line">	int in3 = new Integer(str);</span><br><span class="line">	</span><br><span class="line">	int in4 = Integer.valueOf(str).intValue();</span><br><span class="line">	</span><br><span class="line">	int in5 = Integer.valueOf(str);</span><br><span class="line">	</span><br><span class="line">	Integer in6 = Integer.parseInt(str,2);	//这里打印的是8，1000在2进制就是8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果出现其他字符字母，则运行会报错，下面的代码，我们都知道是11.1，整数为11，但编译器不会把小数点后面的去掉。当然，里面只填11.1，编译器也会直接报错。你可以改为Double类使用浮点数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">	Integer in = new Integer(&quot;11.1&quot;);</span><br><span class="line">	System.out.println(in);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java05_01.png" alt></p>
<h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Integer in = 1;	//装箱，在虚拟机实际运行的是Integer in = new Integer(1);</span><br><span class="line">	</span><br><span class="line">	int in2 = new Integer(1);	//拆箱，实际运行的是int in2 = 1；</span><br><span class="line">	</span><br><span class="line">	//箱，听起来的感觉就是包装成对象，封装成一个对象，拆解为普通的变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>装箱与拆箱也改变了一点变化。我们来看看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Integer in = 10;</span><br><span class="line">	Integer in2 = 10;</span><br><span class="line">	</span><br><span class="line">	Integer in3 = 130;</span><br><span class="line">	Integer in4 = 130;</span><br><span class="line">	</span><br><span class="line">	System.out.println(in == in2);</span><br><span class="line">	System.out.println(in3 == in4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个答案是什么呢？因为是对象，你可以回答都是false。但是，我们先看看它的源代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Cache to support the object identity semantics of autoboxing for values between</span><br><span class="line"> * -128 and 127 (inclusive) as required by JLS.</span><br><span class="line"> *</span><br><span class="line"> * The cache is initialized on first usage.  The size of the cache</span><br><span class="line"> * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span><br><span class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span><br><span class="line"> * may be set and saved in the private system properties in the</span><br><span class="line"> * sun.misc.VM class.</span><br><span class="line"> */</span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns an &#123;@code Integer&#125; instance representing the specified</span><br><span class="line"> * &#123;@code int&#125; value.  If a new &#123;@code Integer&#125; instance is not</span><br><span class="line"> * required, this method should generally be used in preference to</span><br><span class="line"> * the constructor &#123;@link #Integer(int)&#125;, as this method is likely</span><br><span class="line"> * to yield significantly better space and time performance by</span><br><span class="line"> * caching frequently requested values.</span><br><span class="line"> *</span><br><span class="line"> * This method will always cache values in the range -128 to 127,</span><br><span class="line"> * inclusive, and may cache other values outside of this range.</span><br><span class="line"> *</span><br><span class="line"> * @param  i an &#123;@code int&#125; value.</span><br><span class="line"> * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;.</span><br><span class="line"> * @since  1.5</span><br><span class="line"> */</span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Constructs a newly allocated &#123;@code Integer&#125; object that</span><br><span class="line"> * represents the specified &#123;@code int&#125; value.</span><br><span class="line"> *</span><br><span class="line"> * @param   value   the value to be represented by the</span><br><span class="line"> *                  &#123;@code Integer&#125; object.</span><br><span class="line"> */</span><br><span class="line">public Integer(int value) &#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然看着还挺长的，但很多都是注释，注释都是帮助理解的。先看中间的这段代码，看得出来，如果这个数在默认的[low(-128),high(127)]范围外，是直接返回一个数组的值，而这个数组是怎么来的呢？看第一段里从第32行做分水岭，上面操作都在确定数组的范围，下面给cache赋值范围并新建Interger对象赋值。否则在[low,high]范围内呢，返回一个value，而这个value就是它本身。</p>
<p>所以，在装箱中，如果范围在[-128,127]之间，得到的是一个值，不在范围内才是对象。</p>
<p>既然你可以自动装箱和拆箱，那么下面的写法也就是ok的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Integer in = Integer.valueOf(&quot;1000&quot;);</span><br><span class="line">	</span><br><span class="line">	int in2 = Integer.valueOf(&quot;1000&quot;);</span><br><span class="line">	</span><br><span class="line">	Integer in3 = Integer.valueOf(1000);</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;in==in2：&quot;+(in==in2));</span><br><span class="line">	System.out.println(&quot;in==in3：&quot;+(in==in3));</span><br><span class="line">	System.out.println(&quot;in.equals(in3):&quot;+in.equals(in3));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java05_02.png" alt></p>
<p>写东西总是会发现有意思的事，对象和值用 == 是什么比较？没想到是值，以前都没发现，都是对象.equals(对象)，值==值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class test01 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println( 5 == (new a().t=5) );</span><br><span class="line">		</span><br><span class="line">		a a = new a();</span><br><span class="line">		a.t = 10;</span><br><span class="line">		</span><br><span class="line">		System.out.println(10 == a.t);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class a</span><br><span class="line">&#123;</span><br><span class="line">	int t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的两个都是true。</p>
<p>以上是关于Int型的封装Integer的使用，八种基本数据类型，封装都差不多，但也还是有不同，可以试试其他，比如integer的加法比较，Double的大小比较，Boolean的返回的true和false是不是对象等等。</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>八种基本数据类型之外的都是引用数据类型，比如数组，String，类，接口。而引用数据类型也就意味着它是对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	String str = &quot;Hello,World&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看，String是类，却没有new，很多人初学可能都以为它是特殊的基本数据类型。但它是类，所以它也可以new。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	String str = &quot;Hello,World&quot;;</span><br><span class="line">	String str2 = new String(&quot;Hello,World&quot;);</span><br><span class="line">	System.out.println(str == str2);</span><br><span class="line">	System.out.println(str2.equals(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那第一个打印啥，是false，为啥？在内存中，常量是一开始加载到方法区的常量池，比如我们定义的Final，或字符串都在常量池，而str2是先在常量池找有没有该常量，有的话直接在堆新建一个对象，没有的话，会在常量池存入该常量，接着在堆里新建对象。一个指向常量池，一个指向堆，所以打印false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	String str = &quot;Hello,World&quot;;</span><br><span class="line">	String str2 = &quot;Hello,World&quot;;</span><br><span class="line">	System.out.println(str == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码也能说明问题，当我给str赋值时，会去常量池找”Hello,World”这个常量，str2赋值，也会先去常量池找，同时指向同一个地址，那么它们的对象、值也就相等。</p>
<p>String也被称为不可变的字符串，在java中定义如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class String</span><br></pre></td></tr></table></figure>

<p>可是，我们在使用中，往往可以加字符串，但是会产生多个对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	//System.identityHashCode(Object) 打印在内存中的地址</span><br><span class="line">	</span><br><span class="line">	String str;							//一开始str为null，没有对象，也就没有哈希地址</span><br><span class="line">	</span><br><span class="line">	str = &quot;Hello,World&quot;;						//把常量池的&quot;Hello,World&quot;的地址给了str</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;Hello,World&quot;));	//2018699554</span><br><span class="line">	System.out.println(System.identityHashCode(str));		//两个地址在我的电脑上都是上面这一串</span><br><span class="line">	</span><br><span class="line">	str += &quot;! java&quot;;						//接着给str又赋值</span><br><span class="line">	System.out.println(System.identityHashCode(str));		//1311053135	这是新的str的地址</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;! java&quot;));		//118352462		这是该字符串的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里新建了一次str对象。而对象呢，也就创建了一个，因为”Hello,World”和”! java”一开始就加载到了常量池，使用的时候直接指向在常量池的对象就行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	//System.identityHashCode(Object) 打印在内存中的地址</span><br><span class="line">	</span><br><span class="line">	String str = new String(&quot;Hello&quot;);</span><br><span class="line">	System.out.println(System.identityHashCode(str));			//2018699554</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;Hello&quot;));			//1311053135</span><br><span class="line">	</span><br><span class="line">	String str2 = new String(&quot;Hello&quot;);</span><br><span class="line">	System.out.println(System.identityHashCode(str2));			//118352462</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;Hello&quot;));			//1311053135</span><br><span class="line">	</span><br><span class="line">	String str3 = &quot;He&quot; + &quot;llo&quot;;</span><br><span class="line">	System.out.println(System.identityHashCode(str3));			//1311053135</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;He&quot;));			//1550089733</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;llo&quot;));			//865113938</span><br><span class="line">	</span><br><span class="line">	String str = str+str;</span><br><span class="line">	System.out.println(System.identityHashCode(str));			//1442407170</span><br><span class="line">	System.out.println(System.identityHashCode(&quot;HelloHello&quot;));		//1028566121</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次地址都不一样，也就说明对象也不一样，一开始str新建String对象，而常量池没有”Hello”，于是先在常量池新建”Hello”对象，接着给str新建对象，所以第5行代码新建了两个对象，我们也看到str和”Hello”地址不一样。<br>而str2也新建”Hello”对象，但是常量池有”Hello”的对象，所以直接在堆里新建一个对象，所以这里只新建str2对象。看得出”Hello”地址没变。</p>
<p>而str3是把”He”和”llo”合在一起，构成一个字符串，去常量池找，所以直接指向常量池的对象地址。没有创建对象。</p>
<p>最后str把str+str，因为字符串不可变，而常量池没有”HelloHello”，所以先在常量池创建新对象”HelloHello”，str也更改对象，获取“helloHello”。创建了两个对象。</p>
<p>所以上面的代码最少创建5个对象，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	String str = String.valueOf(1.21);</span><br><span class="line">	System.out.println(str);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String自然也可以用装箱和拆箱使用一些方法。</p>
<h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isEmpty()</td>
<td align="center">是否为空，如果空返回true，否则返回flag</td>
</tr>
<tr>
<td align="center">charAt(int)</td>
<td align="center">返回字符串下标为int的值</td>
</tr>
<tr>
<td align="center">length()</td>
<td align="center">返回字符串的长度，从0开始计算，但字符串末尾默认以\0结束</td>
</tr>
<tr>
<td align="center">indexOf(String||char)</td>
<td align="center">返回字符或子字符串的最开的出现的下标</td>
</tr>
<tr>
<td align="center">lastIndexOf(String||char)</td>
<td align="center">返回最后字符或子字符串的出现的下标</td>
</tr>
<tr>
<td align="center">startsWith(String)</td>
<td align="center">是否以当前字符串开头</td>
</tr>
<tr>
<td align="center">endsWith(String)</td>
<td align="center">是否以当前字符串结尾</td>
</tr>
<tr>
<td align="center">replace(String||char，String||char)</td>
<td align="center">替换字符</td>
</tr>
<tr>
<td align="center">toUpperCase()</td>
<td align="center">字符串全变为大写字母</td>
</tr>
<tr>
<td align="center">toLowerCase()</td>
<td align="center">字符串全变为小写字母</td>
</tr>
<tr>
<td align="center">split(String)</td>
<td align="center">切割字符串</td>
</tr>
<tr>
<td align="center">toCharArray()</td>
<td align="center">变为字符数组</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		String str = &quot;&quot;;</span><br><span class="line">		System.out.println(&quot;str是否为空：&quot; + str.isEmpty());		//str是否为空：true</span><br><span class="line">		</span><br><span class="line">		str = &quot;Hello,World&quot;;</span><br><span class="line">		System.out.println(&quot;str赋值后是否为空：&quot; + str.isEmpty());		//str赋值后是否为空：false</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;str的下标第四个的值：&quot;+ str.charAt(4));		//str的下标第四个的值：o</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;str的长度为多少：&quot; + str.length());		//str的长度为多少：11</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;返回l最开始出现的的下标：&quot; + str.indexOf(&apos;l&apos;));		//返回l最开始出现的的下标：2</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;返回从下标4开始，l最开始出现的下标：&quot; + str.indexOf(&apos;l&apos;,4));	//返回从下标4开始，l最开始出现的下标：9</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;返回l最后出现的下标&quot; + str.lastIndexOf(&apos;l&apos;));	//返回l最后出现的下标9</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;str是否以hello开头：&quot; + str.startsWith(&quot;Hello&quot;));	//str是否以hello开头：true</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;str是否以hello结尾：&quot; + str.endsWith(&quot;Hello&quot;));		//str是否以hello结尾：false</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;把str里的,变为空格&quot; + str.replace(&quot;,&quot;, &quot; &quot;));	//把str里的,变为空格Hello World</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;str全部转换成大写字母&quot; + str.toUpperCase());	//str全部转换成大写字母HELLO,WORLD</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;str全部转换成小写字母&quot; + str.toLowerCase());	//str全部转换成小写字母hello,world</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//以&quot;,&quot;把字符串分割</span><br><span class="line">		String[] str2 = str.split(&quot;,&quot;);</span><br><span class="line">		for(String s:str2)System.out.println(s);</span><br><span class="line">		</span><br><span class="line">/*</span><br><span class="line"> * 		Hello</span><br><span class="line"> * 		World</span><br><span class="line"> */</span><br><span class="line">		</span><br><span class="line">		//转换成字符数组</span><br><span class="line">		char[] str3 = str.toCharArray();</span><br><span class="line">		for(char s:str3) System.out.println(s);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *		H</span><br><span class="line"> *		e</span><br><span class="line"> *		l</span><br><span class="line"> *		l</span><br><span class="line"> *		o</span><br><span class="line"> *		,</span><br><span class="line"> *		W</span><br><span class="line"> *		o</span><br><span class="line"> *		r</span><br><span class="line"> *		l</span><br><span class="line"> *		d</span><br><span class="line"> */</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当然，String方法还有重写的equals()、hashCode()等等方法….</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（四）</title>
    <url>/2019/09/04/java%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>前面记录的都是java面向过程的记录，而现在起，则是面向对象的开始。也正是java的魅力所在。</p>
<a id="more"></a>

<p>类是对象的抽象化，对象是类的实例化。怎么说呢，类，定义某个事物的特征，比如球，有半径，有材质，有厚度，有弹性。而对象呢，根据具体事物来说明，半径2cm，材质塑料，厚度1mm，弹性一般，这可能就是乒乓球，而其他球也可以根据类的定义来实例化（对象化）。所以才有万物皆对象，我们可以抽象任何事物的特征，根据不同的特征组合来表述现有的事物。</p>
<h2 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h2><p>从我们学习java开始，就已经接触类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;				//一个类只要唯一一个公共类</span><br><span class="line">	public static void main(String[] args) &#123;	//main方法</span><br><span class="line">		System.out.println(&quot;Hello, World&quot;);	//输出Hello，World</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么用对象呢，都说new一个<del>女朋友</del>，我们把程序改改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		HelloWorld hi = new HelloWorld();	//new一个HelloWorld类</span><br><span class="line">		hi.printHello();			//使用HelloWorld()类中的非静态方法printHello()</span><br><span class="line">	&#125;</span><br><span class="line">	void printHello()				//声明一个输出Hello，World的方法</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;Hello,World&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分析为这两个的区别。当然首先我们应该也知道，我们写.java的代码，编译器编译为.class的字节码，最后在虚拟机(JVM)运行。这是java之所以流行的原因，跨平台。一次编译，处处运行。</p>
<p>我们的代码都在内存上运行，所以要涉及栈，堆，方法区。栈的特点，连续空间，先进后出，就想乒乓球桶一样，最后放进来的一定最先出来。堆在内存中是随机，无序存放的，不要与数据结构的堆混淆。方法区存放代码块的地方，类，静态的，常量，方法名等等，而方法区是在堆里的。</p>
<p>第一个代码，我们的代码名为HelloWorld，编译器会先找到HelloWorld的类，把该类的相关代码放进方法区，并在栈中开辟一个空间。接着编译器找到main方法，程序运行的入口。一步步运行，只有一个输出，打印，程序运行结束，关闭栈，关闭该程序其它占用的内存（堆）。</p>
<p>第二个代码，前面都一样，从main开始，遇到hi的变量名，放入栈中，hi = null; 然后new一个HelloWordl类的引用，既然new，则又在栈中开辟第二个空间，存放helloWordl类的引用地址，并new的类的引用放到了堆里，里面有printHello方法，使用hi.printHello方法后，关闭第二个栈和该类占用的内存，接着程序结束，关闭第一个栈，关闭该程序其他占用的内存。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>我们在new HelloWorld()方法时，其实调用了HelloWorld的默认构造方法。构造方法也可以重写，下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">	</span><br><span class="line">	private String hi;</span><br><span class="line">	public HelloWorld()&#123;&#125;	//默认构造方法</span><br><span class="line">	public HelloWorld(String _hi)</span><br><span class="line">	&#123;</span><br><span class="line">		hi = _hi;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//HelloWorld hello = new HelloWorld();</span><br><span class="line">		HelloWorld hello = new HelloWorld(&quot;你好，世界&quot;);</span><br><span class="line">		HelloWorld hello2 = new HelloWorld();</span><br><span class="line">		hello.printHello();</span><br><span class="line">		hello2.printHello();</span><br><span class="line">	&#125;</span><br><span class="line">	void printHello()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;Hello,World！&quot;+hi);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java04_01.png" alt></p>
<p>构造方法的注意：<br>1、构造方法没有返回类型、返回值。<br>2、如果没有重写（重载：除了方法名和内容其它都可以改变；重写：除了方法名和返回类型其它都可以改变），只会调用默认构造方法。<br>3、重写构造方法，默认构造方法也就没有了，编译器觉得你都自己写了，那我给你的，你也没必要用了。所以还想要默认构造方法，自己写一个。</p>
<p>其它注意：<br>在以前写代码，没有赋值的变量如果被使用，编译器会报错，但在这hello2中，我new的默认构造方法，hi变量没赋值，所以输出String的默认值”null”。简单说明下，在方法内的变量称为局部变量，只归该方法使用，默认没有初始化。而在方法外，类内的的变量称为成员变量(全局变量),能在该类任意一个位置使用，自带初始化，String引用类型，默认值null。</p>
<h2 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h2><p>this指向当前类，可以用当前类的变量或构造方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package io.github.java04;</span><br><span class="line"></span><br><span class="line">public class graphArea &#123;</span><br><span class="line">	</span><br><span class="line">	private int a;		//长</span><br><span class="line">	private int b;		//宽</span><br><span class="line">	private int c; 		//高</span><br><span class="line">	private int area;	//面积</span><br><span class="line">	</span><br><span class="line">	//默认构造方法</span><br><span class="line">	graphArea()&#123;&#125;	</span><br><span class="line">	</span><br><span class="line">	//正方形的面积</span><br><span class="line">	public graphArea(int a) </span><br><span class="line">	&#123;</span><br><span class="line">		this.a = a;		//this.a，当前类的变量， a该方法的变量</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//矩形的面积</span><br><span class="line">	public graphArea(int a, int b)	</span><br><span class="line">	&#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">		this.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//长方体的面积</span><br><span class="line">	public graphArea(int a, int b, int c)</span><br><span class="line">	&#123;</span><br><span class="line">		this(a,b);		//this()调用相应的构造方法</span><br><span class="line">		this.c = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//获取面积</span><br><span class="line">	public int getArea()</span><br><span class="line">	&#123;</span><br><span class="line">		if(b==0&amp;&amp;c==0) area = a*a;		//方法没有局部变量，调用的成员变量</span><br><span class="line">		else if(c==0) area = a*b;</span><br><span class="line">		else area = (a*b+a*c+b*c)*2;</span><br><span class="line">		return area;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//正方形</span><br><span class="line">		graphArea cube = new graphArea(3);</span><br><span class="line">		System.out.println(&quot;正方形的面积：&quot; + cube.getArea());</span><br><span class="line">		</span><br><span class="line">		//矩形</span><br><span class="line">		graphArea rect = new graphArea(2, 3);</span><br><span class="line">		System.out.println(&quot;矩形的面积：&quot; + rect.getArea());</span><br><span class="line">		</span><br><span class="line">		//长方体</span><br><span class="line">		graphArea cuboid = new graphArea(2, 3, 4);</span><br><span class="line">		System.out.println(&quot;长方体的面积：&quot; + cuboid.getArea());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java04_02.png" alt></p>
<p>注意：this. ，注意’.’，指代调用当前类的变量。this()调用本类的其他构造方法时，只能放在构造方法的第一行。与this()对应的还有super()指代父类，下面会有记录。</p>
<h2 id="关键字static和final"><a href="#关键字static和final" class="headerlink" title="关键字static和final"></a>关键字static和final</h2><p>静态的，第三章也简单带过，这里在带过一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">	</span><br><span class="line">	public static int a = 5;</span><br><span class="line">	public final static int b = 10;</span><br><span class="line">	int c = 15;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		HelloWorld h1 = new HelloWorld();</span><br><span class="line">		HelloWorld h2 = new HelloWorld();</span><br><span class="line">		System.out.println(h1.a);	//输出h1.a的值</span><br><span class="line">		</span><br><span class="line">		a = 16;</span><br><span class="line">		System.out.println(h1.a);	//a的值改变了，输出h1.a的值</span><br><span class="line">		</span><br><span class="line">		h1.a = 10;			//h1.a的值改变了，输出h2.a的值</span><br><span class="line">		System.out.println(h2.a);</span><br><span class="line">		</span><br><span class="line">		//b = 15;  常量不可修改</span><br><span class="line">		//System.out.println(c);	//编译器报错</span><br><span class="line">		</span><br><span class="line">		printHello();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	public static void printHello()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;Hello,World！&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java04_03.png" alt></p>
<p>static：静态的，一开始加载到方法区，可以在方法中直接使用，如第21行直接调用printHello()方法，没有用类去调用。<br>第12行把a变为16，对应的第19行输出非静态变量c编译器直接报错。<br>既然static是在方法区，如果静态的值改变，那么其它引用的类的a值也改变，参考代码。</p>
<p>final:会用就行，常量，一开始也加载到方法区，当final修饰，所以不可修改，修饰方法也就没有继承，比如Math类，String类等等。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;你好，static方法块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;你好，普通方法块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void sayHi()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;sayHi方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;main方法执行&quot;);</span><br><span class="line">		HelloWorld p = new HelloWorld();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;------------&quot;);</span><br><span class="line">		</span><br><span class="line">		p.sayHi();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;------------&quot;);</span><br><span class="line">		new HelloWorld().sayHi();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你好，static方法块</span><br><span class="line">main方法执行</span><br><span class="line">你好，普通方法块</span><br><span class="line">------------</span><br><span class="line">sayHi方法</span><br><span class="line">------------</span><br><span class="line">你好，普通方法块</span><br><span class="line">sayHi方法</span><br></pre></td></tr></table></figure>

<p>我们慢慢分析，静态、常量、方法名、类一开始加载到方法区，所以最新输出static方法块，之后开始执行main方法，p引用HelloWorld对象，开辟新的栈，堆加载一个HelloWorld对象，由于static已经加载，所以不在执行static方法块，输出普通的方法块，接着画出横线，使用sayHi()方法.又画出横线，又新建一个对象，开辟新的栈，加载新对象，使用普通方法块，程序结束，关闭所有占用的内存。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>以上是类的简单示例，和对象的基本认识。现在开始就是面向对象的三大特性：封装，继承，多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在求面积那，就简单封装了一下，用构造方法设置边长，面积只能getArea()获取，我们可以在这些设置或获取的方法中做相应的限制。比如输出一个年龄，如果没有封装，可以随意输入，-1，-10，1000000，可现实中，生物中生命不可能为负数，也不可能活的非常非常的长，可以设置if年龄在0到150之间为正确输入，如果超过，提示用户错误信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class years &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(&quot;输入年龄，范围在0&lt;year&lt;=150之间：&quot;);</span><br><span class="line">		_year y = new _year();</span><br><span class="line">		y.setYear(151);</span><br><span class="line">		y.ye = 151;</span><br><span class="line">		System.out.println(&quot;year:&quot; + y.getYear());</span><br><span class="line">		System.out.println(&quot;ye:&quot; + y.ye);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _year</span><br><span class="line">&#123;</span><br><span class="line">	private int year;</span><br><span class="line">	int ye;	</span><br><span class="line">	public int getYear() &#123;</span><br><span class="line">		</span><br><span class="line">		if(year == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(&quot;年龄错误&quot;);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		return year;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setYear(int year) &#123;</span><br><span class="line">		if(year&gt;0 &amp;&amp; year &lt;=150)	this.year = year;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java04_04.png" alt></p>
<p>封装基本就这样，就像我们现在看电视手机，用户不需要知道内部是怎么样的，怎么运行的，我们也不可以把内部代码放出来给用户修改。只需要给用户一个遥控器，一个触摸屏，保持一个合理的使用方法即可。也像我们的身体，内部怎样工作不清楚，我们只要观四方听八面走万里就行。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>子类继承父类，为啥，简单一句，提高开发效率，避免代码冗余。但在java中，继承只能单继承，并且所有类都默认继承Object，只有接口才能多继承。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AnimalTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Animal a = new Animal();</span><br><span class="line">		a.age = 10;</span><br><span class="line">		//a.weight	不可用，private只能在自己的类使用</span><br><span class="line">		//a.height	父类不可以用子类的任何属性</span><br><span class="line">		a.jiao();	//打印 动物叫了</span><br><span class="line">		</span><br><span class="line">		dog d = new dog();</span><br><span class="line">		d.age = 15;</span><br><span class="line">		d.height = 100;</span><br><span class="line">		//d.weight		子类不可以用父类的私有属性</span><br><span class="line">		d.jiao();	//打印 汪汪汪</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal extends Object	//默认继承Object类，可以不写</span><br><span class="line">&#123;</span><br><span class="line">	int age;</span><br><span class="line">	private int weight = 100;</span><br><span class="line">	</span><br><span class="line">	public void jiao()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;动物叫了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">	int height;</span><br><span class="line">	public void jiao()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;汪汪汪&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 父类Animal，子类dog，父类的自己的任何属性可以自己调用，但父类不可以调用子类的属性，就像人一样，我们的身体是从父母得来的，而父母的身体自然也不可能是从子女来。子类可以用父类除了私有的任何属性，也可以用自己的属性，也可以定义和父类一样的变量，也可以重写父类的方法。这就是继承。</p>
<h4 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h4><p>super()调用的是父类的构造方法，在子类中使用，也是放到构造方法的第一行。所以，this()和super()只能调用任意一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class superTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		cat c = new cat();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;---------------&quot;);</span><br><span class="line"></span><br><span class="line">		c.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">	animal()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;我是动物&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void eat() </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;动物在吃东西&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class cat extends animal</span><br><span class="line">&#123;</span><br><span class="line">	cat()</span><br><span class="line">	&#123;</span><br><span class="line">		//super(); //默认自动调用，并在方法的第一行</span><br><span class="line">		System.out.println(&quot;我是猫&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void eat()</span><br><span class="line">	&#123;</span><br><span class="line">		super.eat();</span><br><span class="line">		System.out.println(&quot;猫在吃猫粮&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java04_05.png" alt></p>
<p>上面只是new cat类，程序运行时，默认调用cat的默认构造方法，在cat的构造方法里默认调用了super()，也就是父类的默认构造方法，无论有没有super()，都调用父类的默认构造方法，而父类又向上调用super()，直到Object类的默认构造方法，最后一层层返回，返回到animal的默认构造方法的内容，运行结束又返回到cat的默认方法的内容，最后结束运行。整体就是递归调用的思想。</p>
<p>而横线下面，调用了eat()，在子类中，super.eat()调用了父类的方法。</p>
<p>当然如果父类没有默认的构造方法，但又想用父类的构造方法，就可以用super(参数名)的形式。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>同种物，不同的形态，就像陆地哺乳动物，眼鼻耳口肢体，外形都可以类似，但各自习惯，能力，体型等不同而产生的各种形态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AnimalTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Animal a = new dog();	//向上转型，把dog类变为Animal类</span><br><span class="line">		a.jiao();	//打印 汪汪汪</span><br><span class="line">		//重写了父类的jiao()方法，所以打印了子类的jiao()方法</span><br><span class="line">		//a.height	错误，虽然new的是dog()，但父类没有，</span><br><span class="line">		System.out.println(a.age);	//打印的也只是父类的15，并不是子类的10</span><br><span class="line"></span><br><span class="line">		dog d = (dog)a;	//向下转型，a是Animal类，转化为dog类</span><br><span class="line">		System.out.println(d.age);	//转型后，age的值才是子类的10</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">	int age = 15;</span><br><span class="line">	private int weight = 100;</span><br><span class="line">	</span><br><span class="line">	public void jiao()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;动物叫了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class dog extends Animal</span><br><span class="line">&#123;</span><br><span class="line">	int height;</span><br><span class="line">	public void jiao()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;汪汪汪&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把代码改改，用父类的引用指向了子类，简单意义就是多态，有父类的共同特点，也只可以用父类的属性。但是，子类自己定义的属性不能使用，子类与父类一样的变量名，也只使用父类的。这就是动态绑定，如果子类重写父类的方法，则用子类的，没有向父类找，直到找到最后一次重写的方法，如果找到了Object类也没有找到，则编译器自动报错。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>toString()是Object类的方法，下面是它默认的方法，我的jdk是1.8，所以可能与其它版本有差异，但大致都差不多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看的出来，返回了类的名称+@+类的哈希地址下面是示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package io.github.java04;</span><br><span class="line"></span><br><span class="line">public class toStringTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		car c = new car();</span><br><span class="line">		System.out.println(c.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class car</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这是得到的答案</span><br><span class="line">io.github.java04.car@7852e922</span><br></pre></td></tr></table></figure>

<p>我们一般会重写toString()方法，返回我们想得到的信息，比如类名，结果，而不是一串看不懂的哈希值。</p>
<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>equals()在后面String学习，我们都是通过equals()来判断String的内容是否相等，而不用 == ，因为在java中， == 是判断两个对象是否一样，或基本数据类型才比较值。而不是对象的内容。但是在String中是重写了该方法。下面是Object类的equals()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看的出来，返回的是对象是否相等，并没有比较值，所以我们在用equals()，想比较值是否相等，一定要重写该方法。下面是错误示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class equalsTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		circular c1 = new circular(1);</span><br><span class="line">		circular c2 = new circular(1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c1.equals(c2));	//打印 false</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class circular</span><br><span class="line">&#123;</span><br><span class="line">	private int radius;</span><br><span class="line">	</span><br><span class="line">	public circular(int radius)</span><br><span class="line">	&#123;</span><br><span class="line">		this.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getRadius()</span><br><span class="line">	&#123;</span><br><span class="line">		return radius;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是重写后的equals()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class equalsTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		circular c1 = new circular(1);</span><br><span class="line">		circular c2 = new circular(1);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c1.equals(c2));	//打印 true</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class circular</span><br><span class="line">&#123;</span><br><span class="line">	private int radius;</span><br><span class="line">	</span><br><span class="line">	public circular(int radius)</span><br><span class="line">	&#123;</span><br><span class="line">		this.radius = radius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int getRadius()</span><br><span class="line">	&#123;</span><br><span class="line">		return radius;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public boolean equals(Object obj) &#123;</span><br><span class="line">		</span><br><span class="line">		if(obj instanceof circular)	//instanceof，如果左边的对象是输入右边的类，则返回true</span><br><span class="line">		&#123;</span><br><span class="line">			return radius == ((circular)obj).radius;</span><br><span class="line">		&#125;</span><br><span class="line">		return this == obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好久没更了，但一直在想办法进步，努力，提升自己，大家一起加油吧！！！</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>太极·magisk</title>
    <url>/2019/08/16/%E5%A4%AA%E6%9E%81%C2%B7magisk/</url>
    <content><![CDATA[<p>太极·magisk，也被成为太极·面具或太极·阳，是一种不修改系统文件的框架，比以前的xposed框架好一些的框架。当然，这是我的理解…..</p>
<blockquote>
<p>“无极而太极，太极动而生阳，动极而静，静而生阴，静极复动，一动一静，互为其根，分阴分阳，两仪立焉。” –《太极图说》</p>
</blockquote>
<a id="more"></a>

<p>为什么要装框架，很多不搞机的用户会问，我也只是菜鸟，我只能以我的眼光说，为了美化自己的手机，使自己的手机变的独特。比如装去广告的插件，管理后台插件，手势插件，状态栏沉浸式等。当然，很多插件现在的系统都有内置，这也使得刷机也变得越来越少。</p>
<p>而我之所以刷机，是为了装应用变量，骗联通的5G体验包，有100G呀，可惜晚了两天，一不做二不休，为了以防万一以后用到，干脆刷了算了。而我们搞机用户也常说，我可以不用，但你不可以没有。</p>
<h1 id="太极·阴"><a href="#太极·阴" class="headerlink" title="太极·阴"></a>太极·阴</h1><p>首先介绍太极·阴，是不用刷机直接安装的软件，但要先下载软件，可以去关注虚拟框架公众号回复“最新版”下载太极。</p>
<p>想使用的模块(插件)也可以在这公众号下载安装。然后在软件点击那个像放大的按钮，再点击模块管理，勾选你要使用的框架。</p>
<p><img src="/imgs-Android/magisk_01.jpg" height="300" width="200"><img src="/imgs-Android/magisk_02.jpg" height="300" width="200"><img src="/imgs-Android/magisk_03.jpg" height="300" width="200"></p>
<p>但使用某些模块，需要把相应的软件也放到太极里。这里就体现出太极·阴的不好处，你需要把原始应用卸载，然后在太极·阴里安装。每一次软件更新，就要重新安装一遍，由于数据是保存在太极里，所以可能会丢失数据，好像也不可以应用双开。但是别忘了，太极·阴是不用BL解锁和root的，直接安装的软件，适用于现在大部分的手机。</p>
<h1 id="太极·阳"><a href="#太极·阳" class="headerlink" title="太极·阳"></a>太极·阳</h1><p>因为现在厂商对系统的限制，大部分都有BL锁，才能root。而能够轻松的BL解锁好像只要小米和一加手机吧。我的手机是小米，所以只能以小米为例。</p>
<p><img src="/imgs-Android/magisk_04.png" alt="http://www.miui.com/unlock/index.html"><br>小米BL解锁网址：<a href="http://www.miui.com/unlock/index.html" target="_blank" rel="noopener">http://www.miui.com/unlock/index.html</a></p>
<p>接下来就是刷第三方rec，可以在百度搜索 “某某手机 rec”，例如：小米8 rec</p>
<p>当然小米手机可以在MIUI论坛的<a href="http://www.miui.com/space-uid-362247641.html" target="_blank" rel="noopener">http://www.miui.com/space-uid-362247641.html</a> 的帖子找，来刷rec</p>
<p>现在来安装magisk，你可以百度magisk，去它的官网下载，<a href="https://forum.xda-developers.com/apps/magisk" target="_blank" rel="noopener">https://forum.xda-developers.com/apps/magisk</a> 第一个帖子就是magisk安装包，现在的版本是2019.6.4，19.3</p>
<p><img src="/imgs-Android/magisk_06.png" alt></p>
<p>点进去找到Downloads(下载)，我们只需要下载Latest Stable(最新稳定版)和Magisk Manager。</p>
<p><img src="/imgs-Android/magisk_05.png" alt></p>
<p>由于官网打开比较慢，所以，可以去其他网址下载或去酷安下载Magisk Helper(面具助手)。一定要下载Magisk和Magisk Manager。</p>
<p>然后安装Magisk Manager，关机进入rec，然后找到Magisk位置，刷入Magisk。</p>
<p>先刷rec还是先装Magisk Manager看各人喜好，但刷Magisk一定在刷rec之后。</p>
<p>打开软件大致就是这样，点开左上角的按钮，里面一定要有下载的按钮。如果没有那就说明刷的有误….重新再来刷Magisk吧。</p>
<img src="/imgs-Android/magisk_07.jpg" height="300" width="200">

<p>接着去下载里面下载”Tai Chi”，以上做那么多步，就是为了这个插件。如果下载里不能下载，可以去虚拟框架回复”面具”下载，然后在magisk或rec下安装这个插件。</p>
<p>然后再点开太极，就会发现面具变为太极·阳，可以直接添加软件到这里面。不用怕更新安装麻烦和导致数据丢失。</p>
<p>在安装了magisk之后，现在你打开设备解锁状态和ROOT权限。咦！竟然又锁上了，其实它们只是表面上锁了，你也不用担心不能用magisk或给应用权限。</p>
<p>PS:因为刷入第三方rec，所以更新系统只能线刷或者在MIUI官方下载完整包在rec里更新，magisk(面具)也可能会掉。。。只能重新刷，所以，请小心使用，不要删除Magisk。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>太极</tag>
        <tag>magisk</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（三）</title>
    <url>/2019/08/06/java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>本次记录的是方法，在其他语言也被称为函数。</p>
<a id="more"></a>

<p>我们写java代码中，main也是方法。public static void main(String[] args){}。其中public是访问控制修饰符，static是非访问修饰符，也称为静态修饰符，void是返回值类型，String[]是参数类型，为字符串数组(要区别字符数组char[]),args是参数名。</p>
<p>为什么要使用方法，为了更好的调用，减少代码冗余度，避免不必要的浪费，也为了减少代码修改的次数。</p>
<h1 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2...)&#123;</span><br><span class="line">	代码;</span><br><span class="line">	return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>修饰符:告诉编译器这个方法如何使用。方法中有四个访问控制修饰符：，public、protected、default、private。和两个基本非访问修饰符：final和static。</p>
<h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>public：公有访问修饰符。可以被所有类访问。</p>
<p>protected：受保护富访问修饰符。对同一包内的类和所有子类使用。</p>
<p>default：默认修饰符。在同一个包内可见。</p>
<p>private：私有访问修饰符。只能是当前类使用。</p>
<p>以default为例，在java中，不是静态方法或类，都要先new一个对象，才能使用相应的方法或类。其它修饰符也可以做，使用不同的包建立class，感受这些修饰符感受差异。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FangfaTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		FangfaTest ff = new FangfaTest();</span><br><span class="line">		System.out.println(ff.add(1,2));</span><br><span class="line">	&#125;</span><br><span class="line">	int add(int a, int b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而public和private应该是最常用的修饰符吧，使用的次数挺多的。当然，这里强调下，在一个类中，只能有唯一一个public类，但可以有多个public方法。</p>
<h3 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h3><p>static：静态修饰符，静态变量和方法可是直接使用。</p>
<p>final：变量一旦赋值，就不能更改，和static使用创建类常量。</p>
<p>static修饰的方法直接使用，不需要创建对象。常用的类Math也是静态类，它里面有很多方法也是静态方法。</p>
<p><img src="/imgs-java/java03_01.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FangfaTest &#123;</span><br><span class="line">	static int a = 1;	//静态修饰的变量</span><br><span class="line">	final int B = 2;	//final修饰的变量，也称为常量，不能更改值</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(add(1,2));	//使用static修饰的方法</span><br><span class="line">		a = 2;	//修改static修饰的变量</span><br><span class="line">		// B= 3; final修饰的常量不能更改值，修饰的类也不能继承</span><br><span class="line">		System.out.println(a);</span><br><span class="line"></span><br><span class="line">		FangfaTest ff = new FangfaTest(); </span><br><span class="line">		System.out.println(ff.add(1.2,2));	//只要不是static修饰的方法，都要先new一个对象</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//下面是方法重载，返回值类型和参数类型不同</span><br><span class="line">	final double add(double a, double b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static int add(int a, int b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上六种修饰符，不仅可以用在方法上，也可以用在类或类里的数据类型上。当然，修饰符还有其它的，那就要讲到后面的内容慢慢补充。</p>
<h1 id="方法的返回类型"><a href="#方法的返回类型" class="headerlink" title="方法的返回类型"></a>方法的返回类型</h1><p>方法的返回也就是我们前面记录的八种基本数据类型和现在慢慢补充的引用类型，比如数组，以后的字符串String或者是类。还有无返回类型void。</p>
<p>用基本数据类型int实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FangfaTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		FangfaTest ff = new FangfaTest();</span><br><span class="line">		System.out.println(ff.add(1,2));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int add(int a, int b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回类型为void实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FangfaTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		FangfaTest ff = new FangfaTest();</span><br><span class="line">		ff.add(1,2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	void add(int a, int b) &#123;</span><br><span class="line">		System.out.println(a+b);</span><br><span class="line">		return; //虽然没返回值，但return有两个意思，一个结束运行，另一个返回结果。在这只是结束运行。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用类简单写了一个1+2，然后用方法调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FangfaTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		//先把对象建立，两个类，两个对象</span><br><span class="line">		FangfaTest ff = new FangfaTest();</span><br><span class="line">		adds a = new adds();</span><br><span class="line">		</span><br><span class="line">		//设置私有变量a和b的值</span><br><span class="line">		a.setA(1);</span><br><span class="line">		a.setB(2);</span><br><span class="line">		</span><br><span class="line">		//输出结果</span><br><span class="line">		System.out.println(ff.add(a));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//公有类的方法</span><br><span class="line">	int add(adds a) &#123;	//调用了adds类</span><br><span class="line">		return a.add();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//类的封装，我可以在set方法中设置我的要求，比如是正整数呀，范围多少，增加限制，减少代码出错率</span><br><span class="line">class adds&#123;</span><br><span class="line">	private int a;</span><br><span class="line">	private int b;</span><br><span class="line"></span><br><span class="line">	public int getA() &#123;</span><br><span class="line">		return a;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setA(int a) &#123;</span><br><span class="line">		this.a = a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getB() &#123;</span><br><span class="line">		return b;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setB(int b) &#123;</span><br><span class="line">		this.b = b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public int add() &#123;</span><br><span class="line">		return this.a+this.b;	//关键字this，指当前的类的变量</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h1><p>重载，意思就是实现的内容大致一样，只是参数类型不同，返回类型无所谓，但参数类型一定要不一样，否则，编译器不知道用谁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test02 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		Test02 t = new Test02();</span><br><span class="line">		</span><br><span class="line">		System.out.println(t.add(1, 2));</span><br><span class="line">		System.out.println(t.add(1, 2, 3));</span><br><span class="line">		System.out.println(t.add(1.2, 2.1));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	int add(int a,int b) &#123;</span><br><span class="line">		return a+b;</span><br><span class="line">	&#125;</span><br><span class="line">	int add(int a,int b, int c) &#123;</span><br><span class="line">		return a+b+c;</span><br><span class="line">	&#125;</span><br><span class="line">	double add(double a, double c) &#123;</span><br><span class="line">		return a+c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把double add()里的参数类型都变成int，那就会编译器报错。所以一定是参数类型不同才能重载。</p>
<h1 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h1><p>形参:方法中定义的参数。</p>
<p>实参:调用中，传入方法的实际参数。</p>
<p>值传递:只是把值传给方法的参数，但不改变原参数的值。一般只有八种基本数据类型是值传递。</p>
<p>引用传递(址传递):传入方法中，如果方法里的参数改变了数据，那么原参数也改变。一般只是引用类型会改变。</p>
<p>为什么会有值传递和址传递的差异？</p>
<p>说白了就是指向的对象不同，值传递是在方法调用中，指向一个新的数据变量，址传递因为一开始都指向同一个对象，那么原参数也改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class test03 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//基本数据类型，一般是值传递</span><br><span class="line">		int a = 10;					//一开始a是10</span><br><span class="line">		changeInt(a);					//方法里把a变为20</span><br><span class="line">		System.out.println(a);				//值传递并没有改变原a的值</span><br><span class="line">		</span><br><span class="line">		//引用类型，一般是引用传递/址传递</span><br><span class="line">		int []arr = new int[] &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">		changeArr(arr);					//数组是一个对象，改变同对象的值</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		//方法中重新new一个对象</span><br><span class="line">		changeArr2(arr);				//新的方法，重新new一个数组[0,1,2,3,4]</span><br><span class="line">		System.out.println(Arrays.toString(arr));	//但并没有改变原数组的值，因为它们的指向的地址不同</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void changeInt(int a) &#123;</span><br><span class="line">		a = 20;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void changeArr(int a[]) &#123;</span><br><span class="line">		for(int i=0; i&lt;a.length; i++) &#123;</span><br><span class="line">			a[i] = (i+1)*2; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void changeArr2(int a[]) &#123;</span><br><span class="line">		a = new int [5];				//新new一个数组</span><br><span class="line">		for(int i=0; i&lt;a.length; i++) &#123;</span><br><span class="line">			a[i] = i; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java03_02.png" alt></p>
<h1 id="方法块"><a href="#方法块" class="headerlink" title="方法块"></a>方法块</h1><p>上面讲的都是有返回类型，方法名的方法，如果没有呢？那就是方法块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	</span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;static方法块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;main外的方法块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;main方法&quot;);</span><br><span class="line">		&#123;</span><br><span class="line">			int a = 10;</span><br><span class="line">			System.out.println(&quot;main里的方法块&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//a = 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于没有方法名，所以只能直接放到main里使用，而且方法块里的变量，属性，在方法块外是没发使用的，相当于局部变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static方法块</span><br><span class="line">main方法</span><br><span class="line">main里的方法块</span><br></pre></td></tr></table></figure>

<p>结果是不是很意外，分析一下，在执行程序时，先将静态的，类，方法名，常量放到内存的方法区，所以先加载static方法块，然后执行main方法，一步一步执行，为啥没执行main外的方法块呢，因为我们没调用这个类。下次再继续。</p>
<p>方法就这么多记录，有遗漏欢迎在评论区补充，有不足也请多多关照，在评论区留言，也感谢您的观看，下次见。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（二）</title>
    <url>/2019/08/05/java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>本次主要记录的是基本控制语句、数组两块内容</p>
<a id="more"></a>

<h1 id="基本控制语句"><a href="#基本控制语句" class="headerlink" title="基本控制语句"></a>基本控制语句</h1><p>在java中，控制语句有顺序结构、选择结构、循环结构三类。而顺序结构我们写一般的代码，一行一行的写下去，就像看书一样，有顺序，一行一页。</p>
<p>本次主要记录的是选择结构和循环结构。</p>
<hr>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>选择也称为判断，如果…就…，只有满足条件才执行响应的语句块。</p>
<hr>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>如果第一个if执行，输出大数，如果第二个if执行，输出小数。有多少个if，就进行几次判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = (int)(Math.random()*10+1);	</span><br><span class="line">//random()是Math类的静态方法，产生[0,1)之间的随机数，为浮点型</span><br><span class="line">//random()*10，就是产生[0,10)之间的随机数，再加1,产生[1,11)之间的浮点型随机数，最后转为int型</span><br><span class="line"></span><br><span class="line">System.out.println(a);</span><br><span class="line">if(a&gt;=5) &#123;	//()里填的条件语句是布尔表达式，为真执行语句</span><br><span class="line">	System.out.println(&quot;大数&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(a&lt;5) &#123;</span><br><span class="line">	System.out.println(&quot;小数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_01.png" alt></p>
<hr>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h3><p>我们把上面的代码改改，变成if-else语句，变量a只需要判断一次，如果if不执行，那么else执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = (int)(Math.random()*10+1);	</span><br><span class="line"></span><br><span class="line">System.out.println(a);</span><br><span class="line">if(a&gt;=5) &#123;	//()里填的条件语句是布尔表达式，为真才执行语句</span><br><span class="line">	System.out.println(&quot;大数&quot;);</span><br><span class="line">&#125;else &#123;		//if里不执行，那表达式为假，就跳到else执行</span><br><span class="line">	System.out.println(&quot;小数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="if-elseif-else语句"><a href="#if-elseif-else语句" class="headerlink" title="if-elseif-else语句"></a>if-elseif-else语句</h3><p>如果我们要输出成绩怎么办，优、良、中、及格、不及格，我们用if和if-elseif-else进行对比。</p>
<p>以下为了方便直观，把判断句的语句块都去掉了，但很容易出现问题。所以请记住，一定要打{}。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = (int)(Math.random()*100+1);	</span><br><span class="line">System.out.println(a);</span><br><span class="line">//先用if来操作</span><br><span class="line">if(a &lt; 60) System.out.println(&quot;不及格&quot;);</span><br><span class="line">if(a&gt;=60 &amp;&amp; a &lt; 70) System.out.println(&quot;及格&quot;);</span><br><span class="line">if(a&gt;=70 &amp;&amp; a &lt; 80) System.out.println(&quot;中等&quot;);</span><br><span class="line">if(a&gt;=80 &amp;&amp; a &lt; 90) System.out.println(&quot;良好&quot;);</span><br><span class="line">if(a &gt;= 90) System.out.println(&quot;优秀&quot;);</span><br><span class="line">System.out.println(&quot;--------------------&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//现在用if-else if-else操作</span><br><span class="line">if(a&gt;=90) System.out.println(&quot;优秀&quot;);		//如果大于等于90执行这条语句</span><br><span class="line">else if(a&gt;=80) System.out.println(&quot;良好&quot;);	//否则，大于等于80执行这条语句</span><br><span class="line">else if(a&gt;=70) System.out.println(&quot;中等&quot;);	//再否则， 大于等于70执行这条语句</span><br><span class="line">else if(a&gt;=60) System.out.println(&quot;及格&quot;);	//再再否则， 大于等于60执行这条语句</span><br><span class="line">else System.out.println(&quot;不及格&quot;);		//再再再再否则，终于输出最后一条语句</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_02.png" alt></p>
<hr>
<h3 id="嵌套的if"><a href="#嵌套的if" class="headerlink" title="嵌套的if"></a>嵌套的if</h3><p>我们可以在if里再加判断句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(布尔表达式)&#123;</span><br><span class="line">	if()&#123;</span><br><span class="line">		if()&#123;&#125;</span><br><span class="line">		else if()&#123;&#125;</span><br><span class="line">		else &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用嵌套的if-else来输出成绩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(a&gt;=90) &#123;</span><br><span class="line">	System.out.println(&quot;优秀&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	if(a&gt;=80) &#123;</span><br><span class="line">	System.out.println(&quot;良好&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if(a&gt;=70) &#123;</span><br><span class="line">			System.out.println(&quot;中等&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if(a&gt;=60) &#123;</span><br><span class="line">				System.out.println(&quot;及格&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				System.out.println(&quot;不及格&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把{}都拿掉，是不是很像if-elseif-else类型。</p>
<p>总结一下if条件语句，如果只满足一个条件才执行，那就用if单条语句，如果判断对立面，那就用if-else语句，如果有多判断多选择，就用if-elseif-else。好像说的废话一样。。。怎么方便怎么用就行。</p>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>此switch非彼switch，不是游戏机，没有任天堂，就是用来判断的，是多选择语句，和if-else if-else类似。但是switch可以很简单用字符串来判断。你也可以在case里嵌套switch，实现嵌套判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String[] game = &#123;&quot;ps4&quot;, &quot;xbox&quot;, &quot;switch&quot;&#125;;	//这是字符串数组，马上讲数组了，而字符串会专门讲，很重要</span><br><span class="line">int i = (int)(Math.random()*3);			//数组从0开始，所以这里随机[0,3)就行</span><br><span class="line"></span><br><span class="line">System.out.println(i);</span><br><span class="line"></span><br><span class="line">switch(game[i]) &#123;</span><br><span class="line">	case &quot;ps4&quot;:</span><br><span class="line">		System.out.println(&quot;大家好，我是索尼游戏机&quot;);</span><br><span class="line">		break;		//break是停止语句，接下来语句块内的内容不执行，一般在循环语句块用</span><br><span class="line">	case &quot;xbox&quot;:</span><br><span class="line">		System.out.println(&quot;大家好，我是微软游戏机&quot;);</span><br><span class="line">		break;		//如果没有break,当i=0时，会输出全部内容</span><br><span class="line">	case &quot;switch&quot;:</span><br><span class="line">		System.out.println(&quot;大家好，我是任天堂游戏机&quot;);</span><br><span class="line">		break;</span><br><span class="line">	default:		//相当于else,可以把case &quot;switch&quot;去掉，把输出任天堂放到这里</span><br><span class="line">		break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_03.png" alt></p>
<hr>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>只要满足相应的条件，就一直执行下去。</p>
<hr>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(初始值; 循环条件; 循环走向)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">初始值:循环从开始的地方</span><br><span class="line">循环条件:循环在什么情况下满足条件</span><br><span class="line">循环走向:循环是递增还是递减,等比数列还是等差数列进行取值</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=0; i&lt;=10; i++) &#123;</span><br><span class="line">	//System.out.print(i+&apos; &apos;); 这里把char自动转型为int，空格为32，和i加在一起(i+32),输出3233343536373839404142</span><br><span class="line">	System.out.print(i+&quot; &quot;); 	//这样才打印[0,10] 输出0 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line">&#125;</span><br><span class="line">//原因:char是一个字符，能与int相加转型为int型，而&quot; &quot;是字符串(String)</span><br><span class="line">//&quot; &quot;里有两个值，&apos; &apos;和&apos;\0&apos;组成，int不会与String相加</span><br><span class="line"></span><br><span class="line">//但String放到+前，会把之后的内容拼接在一起,下面把循环输出改一改</span><br><span class="line">for(int i=0; i&lt;=10; i++) &#123;</span><br><span class="line">	System.out.print(i+2+&quot; &quot;+i+2+&apos;,&apos;);	//输出2 02,3 12,4 22,5 32,6 42,7 52,8 62,9 72,10 82,11 92,12 102,</span><br><span class="line">&#125;</span><br><span class="line">//&quot; &quot;前i和2相加，之后把i和2还有&apos;,&apos;拼接在一起,所以用String类型，要注意放的位置</span><br></pre></td></tr></table></figure>

<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><p>增强for循环一般只是输出变量的数值。下面打印0~9的数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [] a = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">//for(Object 临时变量名:要打印的变量名)</span><br><span class="line">//增强for循环不仅可以用于基本的数据类型，还能用于类，类都继承了Object对象</span><br><span class="line">for(int temp:a) &#123;</span><br><span class="line">	System.out.print(temp+&quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环只有循环条件，初始值只能在循环体外定义。</p>
<p>下面输出0到10的数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">while(i&lt;=10) &#123;</span><br><span class="line">	System.out.print(i+&quot; &quot;);</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for和while都是比较常用的循环。</p>
<hr>
<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i=5;</span><br><span class="line">do &#123;</span><br><span class="line">	System.out.print(i+&quot; &quot;);</span><br><span class="line">	i++;</span><br><span class="line">&#125;while(i&lt;0);</span><br></pre></td></tr></table></figure>

<p>do-while和while有啥区别呢，那就是do-while第一次无论 有没有满足条件，都先执行一次，而while、乃至for都是先要满足条件才执行。而上面的这段代码，5本来就小于0，而do-while会打印了5，才来判断是否满足条件。</p>
<hr>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>我们用for和while分别打印乘法表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1; i&lt;=9; i++) &#123;</span><br><span class="line">	for(int j=1; j&lt;=i; j++) &#123;</span><br><span class="line">		System.out.print(j+&quot;*&quot;+i+&apos;=&apos;+(i*j)+&apos; &apos;);	//之前说过&quot;&quot;之后是字符串拼接，所以(i*j)打了括号，当然不打括号也行，*优先级大于+</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------------------------&quot;);</span><br><span class="line"></span><br><span class="line">int i=1;</span><br><span class="line">while(i&lt;=9) &#123;</span><br><span class="line">	int j=1;</span><br><span class="line">	while(j&lt;=i) &#123;</span><br><span class="line">		System.out.print(j+&quot;*&quot;+i+&apos;=&apos;+(i*j)+&apos; &apos;);</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_04.png" alt></p>
<p>当然，如果想输出格式化对齐，最简单的办法就是用C语言的格式输出。</p>
<p>System.out.printf(“%d*%d = %2d  “,j,i,i*j);</p>
<hr>
<h2 id="、-amp-amp-、"><a href="#、-amp-amp-、" class="headerlink" title="!、&amp;&amp;、||"></a>!、&amp;&amp;、||</h2><p>当然，它们也是参与布尔表达式的运算，常常在条件语句和循环语句出现，前面也提及过，if()里进行的是布尔表达式，循环里的循环条件也是布尔表达式。我们来一起用用吧。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">名称</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">!</td>
<td align="center">非</td>
<td align="center">肯变否，否变肯</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
<td align="center">与</td>
<td align="center">全真才真</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">或</td>
<td align="center">全假才假</td>
</tr>
</tbody></table>
<p>条件语句经常和循环语句一起使用，我们来看看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//输出1000年到2999年之间有多少闰年</span><br><span class="line">for(int i=1000; i&lt;= 2999; i++) &#123;</span><br><span class="line">	if((i%4==0 &amp;&amp; i%100!=0) || i%400==0) &#123;	//里面可以不用加()，!的优先级&gt;&amp;&amp;&gt;&gt;||</span><br><span class="line">		System.out.println(i+&quot;\t&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">//闰年一定可以被4整除，而千年是闰年，还能被400整除，可是百年大部分都不是闰年，但它能被100整除</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 2, b = 3, c = 0;</span><br><span class="line">if(!(c!=0) &amp;&amp; a&gt;1) &#123;</span><br><span class="line">	System.out.println(&quot;c不是不是0，并且a的值大于1&quot;); //有点拗，c!=0，是false,又加个否定，等价于c==0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(a&gt;2 &amp;&amp; (c++)&gt;=0) &#123;	</span><br><span class="line">	System.out.println(&quot;有输出吗?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;c:&quot;+c);</span><br><span class="line">//看的出来， a&gt;2不成立，没有执行if里的内容，&amp;&amp;后面也没有执行</span><br><span class="line"></span><br><span class="line">if((c++)&gt;=0 &amp;&amp; a&gt;2) &#123;	</span><br><span class="line">	System.out.println(&quot;有输出吗?&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//更改一下位置，c++,c变为1，条件成立，但a&gt;2不成立，没有执行if里的内容</span><br><span class="line">System.out.println(&quot;c:&quot;+c);</span><br><span class="line"></span><br><span class="line">if(a&gt;2 || (c++)&gt;=0) &#123;</span><br><span class="line">	System.out.println(&quot;c:&quot;+c);</span><br><span class="line">&#125;</span><br><span class="line">// ||有一个成立就行，所以if里打印了c的值</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_05.png" alt></p>
<hr>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>break是强制退出循环，不执行剩余的内容；而continue是跳过本次循环的内容。</p>
<p>下面是嵌套循环，在j==3进行了处理，break每次到j==3时，跳出内循环，进行下一次外循环。而continue是跳过本次内循环，进行下一次内循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i=1; i&lt;5; i++) &#123;</span><br><span class="line">	for(int j=1; j&lt;5; j++) &#123;</span><br><span class="line">		if(j==3) break;</span><br><span class="line">		System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">for(int i=1; i&lt;5; i++) &#123;</span><br><span class="line">	for(int j=1; j&lt;5; j++) &#123;</span><br><span class="line">		if(j==3) continue;</span><br><span class="line">		System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_06.png" alt></p>
<p>在C语言中，有一个语句叫goto，很少用，因为太调皮了。能够从一个语句跳转到另一个语句，用起来很爽，但太乱了，所以java中就只成为保留字，没有任何意义。但是，break和continue却有点像goto，不执行接下来的语句，执行另外的语句，只是限制在了循环里。而它只是不执行内循环接下来的语句，如果我们也不想执行外循环接下来的语句呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:for(int i=1; i&lt;5; i++) &#123;</span><br><span class="line">	for(int j=1; j&lt;5; j++) &#123;</span><br><span class="line">		if(j==3) break a;</span><br><span class="line">		System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(&quot;------------------------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">a:for(int i=1; i&lt;5; i++) &#123;</span><br><span class="line">	for(int j=1; j&lt;5; j++) &#123;</span><br><span class="line">		if(j==3) continue a;</span><br><span class="line">		System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();	//这条语句就成了摆设，可以放在第一个循环下面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_07.png" alt></p>
<p>也差不多实现和goto一样的意思，想跳哪就去哪，只是限制在循环里的操作。如果里面的判断再多点，估计也就像goto一样看不懂了，所以我感觉自己玩玩挺好的，真正拿来写代码，那有点得罪人的意思了。</p>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>当存在多个相同数据类型的变量，我们用x1,x2,x3,x4…进行数据操作时效率太低，因此才有了数组。数组分为一维数组在，和多维数组，我们最常用的应该就是一维数组在和二维数组。而这个维度，指的只是空间的增多而已。一维只是一行元素，二维在一维的每个元素又拉出来一列，构成一个矩阵。三维也是只在每行每列的每个元素又来出来一纵，构成一个像魔方一样的立体。四维也就只是再在每个元素又拉出一行元素，以此类推。</p>
<hr>
<h2 id="数组的声明和赋值"><a href="#数组的声明和赋值" class="headerlink" title="数组的声明和赋值"></a>数组的声明和赋值</h2><p>好像有三种吧。但好像我一般只用两种。</p>
<hr>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>第一种是声明数组类型和长度，然后赋值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//数组声明</span><br><span class="line">int []a = new int [10];		//[0,10)</span><br><span class="line">//int a[] = new int [10]; //这种也可以，C/C++的规范</span><br><span class="line">//数组赋值，数字下标从0开始计算</span><br><span class="line">a[0] = 0;</span><br><span class="line">a[1] = 1;</span><br><span class="line">a[2] = 2;</span><br><span class="line">//也可以循环赋值</span><br><span class="line">for(int i=3; i&lt;10; i++) &#123;</span><br><span class="line">	a[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(a));		//一定要引入 import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">//打印出[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>第二种是声明数组类型写内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int []a = new int[] &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">System.out.println(Arrays.toString(a));		//一定要引入 import java.util.Arrays;</span><br><span class="line">//打印内容和上面一样</span><br></pre></td></tr></table></figure>

<p>第三种是直接写内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int []a =&#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">for(int i=0; i&lt;a.length; i++) &#123;	//也可以用循环打印结果，length是获取数组的长度</span><br><span class="line">	System.out.print(a[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">//输出 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [][]a = new int [3][]; //告诉编译器二维数组有三行，每行多少个就看你自己写的</span><br><span class="line">//int [][]a = new int [3][4]; //也可以直接写死，有三行，有四列</span><br><span class="line">a[0] = new int[3];</span><br><span class="line">a[0][0] = 0;</span><br><span class="line">a[0][1] = 1;</span><br><span class="line">a[0][2] = 2;</span><br><span class="line">a[1] = new int[] &#123;0,1,2,3,4&#125;;</span><br><span class="line">//a[2] = &#123;0,1&#125;是不行的，否则就是一维数组，但我们声明的是二维</span><br><span class="line">a[2] = new int[] &#123;0,1&#125;;</span><br><span class="line">for(int i=0; i&lt;a.length; i++) &#123;</span><br><span class="line">	for(int j=0; j&lt;a[i].length; j++) &#123;</span><br><span class="line">		System.out.print(a[i][j]+&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java02_08.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [][]a = new int[][] &#123;&#123;0,1,2&#125;,&#123;0,1,2,3,4&#125;,&#123;0,1&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>二维数组也可以像一维数组一样声明和使用，但它列可以是不固定的，有多长看自己的喜爱。但我一般喜欢用固定，方便两层for循环输入数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [][]a = new int[3][4];</span><br><span class="line">for(int i=0; i&lt;a.length; i++) &#123;</span><br><span class="line">	for(int j=0; j&lt;a[i].length; j++) &#123;</span><br><span class="line">		a[i][j] = i*j+i+j;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.deepToString(a));	//声明 import java.util.Arrays;</span><br><span class="line">//输出 [[0, 1, 2, 3], [1, 3, 5, 7], [2, 5, 8, 11]]</span><br></pre></td></tr></table></figure>

<p>数组还有多维数组，当然，可不要搞迷糊了。这次就到这里啦。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础（一）</title>
    <url>/2019/07/30/java%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>本次主要记录的是基本数据类型、数据类型转换、基本运算符和进制表示四块内容。</p>
<a id="more"></a>

<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>java中基本数据类型有八种基本类型，包括整数型、浮点型、字符型和布尔类型这几类。如有不足，多多指教。</p>
<hr>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>java中整数类型有byte、short、int、long共四种。占八种基本数据类型的一半。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">默认值</th>
<th align="center">位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">-128~127</td>
<td align="center">0</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">-32768~32767</td>
<td align="center">0</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">-2147483658~2147483657</td>
<td align="center">0</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">-2^31~2^31-1</td>
<td align="center">0L</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p>其中，整数的默认类型是int，所以使用long类型时，如果数据范围超过int，要在其值后加上L/l,来转型为long。但l和1(一)太相像，所以通常用大写的L。而byte和short就不需要类型转换，因为它们的数据范围本身比int小，自然不会超过int表示范围。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这些都在自己的数据范围内</span><br><span class="line">byte a = 18;				//输出 18</span><br><span class="line">short b = 1000;				//输出 1000</span><br><span class="line">int c = 40000;				//输出 40000</span><br><span class="line">long d = 3000000000L;;			//输出 3000000000</span><br></pre></td></tr></table></figure>

<p>而下面则是错误示范，还没运行，编译器自动提示错误：前两个是类型不匹配，无法从int转为byte/short，后两个都是超过int数据类型的范围。更能说明long的默认数据类型是int，因为他没超过long的数据范围。</p>
<p><img src="/imgs-java/java01_01.png" alt><br><img src="/imgs-java/java01_02.png" alt></p>
<hr>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">默认值</th>
<th align="center">位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">1.4E-45~3.4028235E38</td>
<td align="center">0.0f</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">4.9E-324~1.7976931348623157E308</td>
<td align="center">0.0d</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p>浮点类型数据范围挺大的，但不太精确，做运算都有可能有误差。不过double则要比float类型精确些，而且在java中，浮点类型的默认类型是double。所以，我们通常使用double更多。当然也可以使用float，不过要在其值加上f，否则编译器会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//float使用</span><br><span class="line">float f1 = 1.2f; 	//f大小写都行</span><br><span class="line"></span><br><span class="line">//double使用</span><br><span class="line">double d1 = 1.5;</span><br><span class="line">double d2 = 1.7d;	//可以在后面加d或D</span><br><span class="line"></span><br><span class="line">//使用科学计数法，以double为例</span><br><span class="line">double d3 = 314e-2;	//输出 3.14</span><br><span class="line">double d4 = 314e2;	//输出31400.0</span><br></pre></td></tr></table></figure>

<p>以下是以doubl为例，进行的运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double a = 12.3;</span><br><span class="line">double b = 12.3;</span><br><span class="line">double c = 24.6;</span><br><span class="line">double e = a + b;</span><br><span class="line">System.out.println(e);</span><br><span class="line">System.out.println(a == b);</span><br><span class="line">System.out.println(c == e);</span><br><span class="line">double d = a + c;</span><br><span class="line">double f = 36.9;</span><br><span class="line">System.out.println(d);</span><br><span class="line">System.out.println(d == f);</span><br></pre></td></tr></table></figure>

<p><img src="/imgs-java/java01_04.png" alt></p>
<p>这是以加法为例，说明浮点类型在进行运算的不可靠。而可能这几行代码在你的电脑就全是true。当然这你可能会有疑惑，浮点计算不可靠，那咋办？其实java有自己的类进行浮点运算，那就是BigDecimal，它属于Math类中，以后讲常用类会提及。</p>
<hr>
<h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>java中字符类型是char表示，数据范围从0~65525，其默认值为\u0000, 在内存中占16位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char c = &apos;A&apos;;			//注意要打单引号，双引号就是字符串啦</span><br><span class="line">System.out.println(c);		//输出 A</span><br><span class="line">int a = 97;			//也可以把整型强制转换成char类型，后面会提及类型转换</span><br><span class="line">System.out.println((char)a);	//输出 a</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>java中布尔用boolean表示， 它只有两个取值true和false。true为真，false为假，默认值为false。 在内存中占1位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean flag = true;</span><br><span class="line">if(flag) &#123; 		//等价于 flag==true</span><br><span class="line">	//if条件语句只有true时，才执行</span><br><span class="line">	System.out.println(&quot;flag为&quot; + flag);</span><br><span class="line">&#125;</span><br><span class="line">//输出 flag为true</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><p>数据转换分为两种，一种是自动转换，容量小的自动转换成容量大的，另一种是强制转换(强制把某种类型转换成另一种类型)，强转可能会出现精度损失。</p>
<p>什么是精度损失？比如1.9的浮点型，强制转为整型，就变成1，小数部分直接舍弃。</p>
<hr>
<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double</p>
<p>char–&gt;int<br>当然整型转换成浮点型，有可能会出现精度的损失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byte bt = 127;</span><br><span class="line">int bc = bt;</span><br><span class="line">System.out.println(bc);		//输出 127</span><br><span class="line"></span><br><span class="line">int a = 12;</span><br><span class="line">double b = a;</span><br><span class="line">System.out.println(b);		//输出 12.0</span><br><span class="line"></span><br><span class="line">long c = 1234567890123456789L;</span><br><span class="line">float d = c;</span><br><span class="line">double dou = c;</span><br><span class="line">//电脑不同，可能输出的结果也有一点点差别</span><br><span class="line">System.out.println(d);		//输出 1.23456794E18</span><br><span class="line">System.out.println(dou);	//输 1.23456789012345677E18</span><br><span class="line"></span><br><span class="line">char ch = &apos;\u0010&apos;;		//可以看的出来是char占16位</span><br><span class="line">int  ch2 = ch;</span><br><span class="line">System.out.println(ch2); 	//输出16</span><br></pre></td></tr></table></figure>

<p>从代码中，这些都是自动转换，但也有人会问，为啥long都能自动转换为float，long占64位，float占32位，但java自动转换不是看谁在内存占的位数大就转谁，而是看容量。浮点型中，容量是不能直接算出来的，而float的最大值远远大于long的最大值，所以long能自动转换为float。但数值一大，就会出现精度损失。</p>
<hr>
<h2 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h2><p>一般把容量大的转换成容量小的，但转换的变量数据不能超过转换后的容量，虽然编译器不会报错，但输出结果可能是错误的。</p>
<p>以整型为例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 18;</span><br><span class="line">byte a1 = (byte)a;	//把int型强制转换成byte型，并且18在byte范围内</span><br><span class="line">System.out.println(a1);	//输出 18</span><br><span class="line">a = 128;	//128已经超过byte数据范围</span><br><span class="line">a1 = (byte)a;</span><br><span class="line">System.out.println(a1);	//输出错误答案 -128</span><br></pre></td></tr></table></figure>

<p>可以看出强制转型一定要在合理范围内，比如说，两个杯子，一个大杯子是满的，另一个小杯子是空，我们无法把大杯子的水都倒在小杯子里。反过来我们可以把装满水的小杯子倒在空的大杯子，不过这是自动转型啦。</p>
<p>强制把浮点型转换成整型型，可能会出行精度损失。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double d = 1.9;	//如果浮点本身是没有小数，转整型就不会出行精度损失</span><br><span class="line">int a = (int)d;</span><br><span class="line">System.out.println(a);	//输出 1</span><br><span class="line">System.out.println(d);	//输出1.9 转型是不改变原变量的值</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">名称</th>
<th align="center">例子(int型)</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">加法</td>
<td align="center">a = 1+2</td>
<td align="center">a = 3</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减法</td>
<td align="center">a = 2-1</td>
<td align="center">a = 1</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘法</td>
<td align="center">a = 5*2</td>
<td align="center">a = 10</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">除法</td>
<td align="center">a = 5/2</td>
<td align="center">a = 2</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余/取模</td>
<td align="center">a = 5%2</td>
<td align="center">a = 1</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增</td>
<td align="center">a1 = a2 = 2; b = a1++; c = ++a2</td>
<td align="center">b = 2; c = 3</td>
</tr>
<tr>
<td align="center">- -</td>
<td align="center">自减</td>
<td align="center">a1 = a2 = 2; b = a1- -; c = - -a2</td>
<td align="center">b = 2; c = 1</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">取反</td>
<td align="center">a = ~6</td>
<td align="center">a = -7</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">与</td>
<td align="center">a = 5; b = 3; c = a&amp;b</td>
<td align="center">c = 1</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">或</td>
<td align="center">a = 5; b = 3; c = a|b</td>
<td align="center">c = 7</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">异或</td>
<td align="center">a = 5, b = 3; c = a^b</td>
<td align="center">c = 6</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移(*2)</td>
<td align="center">a = 1&lt;&lt;2</td>
<td align="center">a = 4</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移(/2)</td>
<td align="center">a = 8&gt;&gt;3</td>
<td align="center">a = 1</td>
</tr>
</tbody></table>
<p>以上就是java中最常用的运算符，加减乘数是基本的四则运算，整数和浮点型可以一起运算，但是，低的数据类型会向高的数据类型自动转换。如果不同类型进行运算，赋值的变量数据类型要是最大的那个。</p>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a1 = 12;</span><br><span class="line">long a2 = 23;			//23一开始是int型，赋值个a2变成了long型</span><br><span class="line">//a1 = a1+a2;			//a1和a2相加自动向long类型转换，所以会报错</span><br><span class="line">//但我们可以进行下面这运算</span><br><span class="line">a1 += a2;			//等价于 a1 =(int)(a1+a2); 把long型强制转换成int型</span><br><span class="line"></span><br><span class="line">//浮点型最注意除法运算</span><br><span class="line">double d = 1.2 + 5 / 2;		//输出 3.2</span><br><span class="line">//在运算过程中,先/，5/2，两个都是整型，结果也是整型2，2+1.2就是结果，这里有转换成2.0+1.2</span><br><span class="line">//那怎么办，办法如下</span><br><span class="line">//把其中一个整型变成浮点型</span><br><span class="line">d = 1.2 + 5.0/2;		//输出 3.2</span><br><span class="line">//d = 1.2 + (double)5/2;    这样也是可以的，但太麻烦，很少用吧...</span><br><span class="line"></span><br><span class="line">//d = 1.2 + (double)(5/2);  ps:这是错误，和第8行运算一样的结果</span><br></pre></td></tr></table></figure>

<h2 id="求余"><a href="#求余" class="headerlink" title="求余"></a>求余</h2><p>% 就是求一个数除以另一个数得到它的余数，所以称为求余或取模。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a = 10%3;	//输出 1</span><br><span class="line"></span><br><span class="line">//注意，求余结果符号和除数用关</span><br><span class="line">a = -10%3;	//输出 -1</span><br><span class="line">a = 10%-3;	//输出 1</span><br><span class="line">a = -10%-3;	//输出 -1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id><a href="#" class="headerlink" title="~"></a>~</h2><p>这里以前没写，忘了，现在加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对6取反</span><br><span class="line">int a = ~6;</span><br><span class="line">6   	0000 0110</span><br><span class="line">补码		1111 1001</span><br><span class="line">反码		1111 1000</span><br><span class="line">再取反	1000 0111</span><br><span class="line"></span><br><span class="line">第一位是符号位，0代表整数，1代表负数，所以最后答案是-7</span><br></pre></td></tr></table></figure>

<h2 id="和"><a href="#和" class="headerlink" title="++和- -"></a>++和- -</h2><p>自增是自己加1，自减是自己减1，但要注意放的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//++和--都一样，以++为例</span><br><span class="line">int a1 = 2;</span><br><span class="line">int a2 = 2;</span><br><span class="line">int b1 = a1++;		//b1 = 2 运算为 先b1 = a1, 然后a1 += 1</span><br><span class="line">int b2 = ++a2;		//b2 = 3 运算为 先a += 1， 在b2 = a2</span><br><span class="line">			//最后结果a1和a2都为3</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="amp-、"><a href="#amp-、" class="headerlink" title="&amp;、|"></a>&amp;、|</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		int a1 = 5, b1 = 3;</span><br><span class="line">		int c1 = a1&amp;b1;		//输出1</span><br><span class="line">/*</span><br><span class="line"> * 		与运算是真真为真，一真一假为假，假假为假</span><br><span class="line"> * 		而这里的真是二进制的1，假为二进制的0</span><br><span class="line"> * 		5的二进制为 0101</span><br><span class="line"> * 		3的二进制为 0011</span><br><span class="line"> * 		进行与运算  0001    所以答案为1</span><br><span class="line"> */</span><br><span class="line">		int a2 = 5, b2 = 3;</span><br><span class="line">		int c2 = a2|b2;		//输出7</span><br><span class="line">/*</span><br><span class="line"> * 		|运算是真真为真，一真一假为真，假假为假</span><br><span class="line"> * 		所以5|3 为 0101</span><br><span class="line"> * 	                  0011</span><br><span class="line"> * 		          0111  答案为7</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="-1"><a href="#-1" class="headerlink" title="^"></a>^</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		int a = 5, b = 3;</span><br><span class="line">		System.out.println(a^b); 			//输出 6</span><br><span class="line">/*</span><br><span class="line"> * 		原理还是二进制</span><br><span class="line"> * 		5的二进制：0101</span><br><span class="line"> * 		3的二进制：0011</span><br><span class="line"> * 		那么^之后：0110   就是6啦，一真一假为真</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">		int a1 = 2, b1 = 3, c1 = 0;</span><br><span class="line">		if(a1&gt;2 ^ (c1++)&gt;=0) &#123; 				//a1&gt;2假，(c1++)&gt;=0真</span><br><span class="line">			System.out.println(c1);			//输出c1为 1</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(a1==2^b1==3) &#123;</span><br><span class="line">			System.out.println(&quot;有输出吗?&quot;);		//没有输出</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>当然，还有一个!，但是在java中，!只进行表达式运算，而表达式计算的结果为true或false，也就是获得一个布尔值。而其它语言，像C/C++布尔值可以用0表示false，非0表示true，进行简单的运算。</p>
<hr>
<h2 id="lt-lt-和-gt-gt"><a href="#lt-lt-和-gt-gt" class="headerlink" title="&lt;&lt;和&gt;&gt;"></a>&lt;&lt;和&gt;&gt;</h2><p>左移一位是乘2，左移两位是乘4……以此类推。右移一位是除以2，右移两位是除以4……以此类推。通常在乘2或除以2，建议用&lt;&lt;和&gt;&gt;，效率上要比*和/快一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		int a = 1&lt;&lt;2;		//输出 a为4</span><br><span class="line">/*</span><br><span class="line"> * 		1的二进制是0001，把1左移两位，变成0100，变成了4</span><br><span class="line"> */</span><br><span class="line">		int b = 8&gt;&gt;3;</span><br><span class="line">		//同理，1000右移三位，变成0001</span><br><span class="line">		</span><br><span class="line">		//当然不是移一个数，是整体的移动，下面以7为例</span><br><span class="line">		//0111&lt;&lt;1 ---&gt; 1110		变为 14 7*2=14</span><br><span class="line">		//0111&gt;&gt;1 ---&gt; 0011		变为 3  7/2=3</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h1><blockquote>
<p>“世界上只有10中人，一种是懂二进制，另一种是不懂二进制”。</p>
</blockquote>
<p>二进制由0和1组成，而我们的代码最终也会变成二进制运行，计算机也是以二进制进行工作，网络信息也是以二进制在物理层传输。所以二进制对我们来不会很陌生。</p>
<p>初次之外，我们还有八进制、十六进制和常用的10进制，让我们用代码表示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//都表示输入10这个数</span><br><span class="line">int a1 = 10;		//写代码默认十进制	 	十进制:0 1 2 3 4 5 6 7 8 9</span><br><span class="line">int a2 = 0b1010;	//二进制表示10，前面加0b/0B 	二进制:0 1</span><br><span class="line">int a3 = 012;		//八进制表示10, 前面加0就行 	八进制:0 1 2 3 4 5 6 7 </span><br><span class="line">int a4 = 0xA;		//十六进制表示10，前面加0x	十六进制:0 1 2 3 4 5 6 7 8 9 a b c d e f</span><br><span class="line">//那么如何输出各进制的10呢?</span><br><span class="line">System.out.println(Integer.toBinaryString(10));	//二进制</span><br><span class="line">System.out.println(Integer.toOctalString(10));	//八进制</span><br><span class="line">System.out.println(10);				//额...十进制</span><br><span class="line">System.out.println(Integer.toHexString(10));	//十六进制</span><br></pre></td></tr></table></figure>

<p>以上就是本次总结，本来还想写很多，把常用语句也记录上，那样就会太长了，只能等下一篇文章了。如有不足之处，请在下方评论区留言，谢谢您的来访~ ~ ~下次见。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客记</title>
    <url>/2019/07/29/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%AE%B0/</url>
    <content><![CDATA[<p>博客搭建好了，让我这个小萌新说点什么吧，如有不足，各位多多包涵</p>
<a id="more"></a>
<h1 id="为什么要搭建博客"><a href="#为什么要搭建博客" class="headerlink" title="为什么要搭建博客"></a>为什么要搭建博客</h1><p>搭建博客每个人都应该有自己的理由，我的理由是学的东西挺多了，时间一长就忘记了。不想在纸上做笔记，怕弄丢了，而且有新的发现不能在原有的基础上修改，越改越乱。在电脑上也写了一点代码，时间一长也不知道是干啥用的，有的还不容易找到。所有想写点博客，有思路的写，把学习过程写的明明白白。哈哈哈~。<br>当然，也是为了提升自己嘛，耳边总会响起一句话：“你想成为什么样的人？”。我不知道会成为什么样的人，只要还是像当初那样热爱就行。</p>
<hr>
<h1 id="你要用这个博客干啥"><a href="#你要用这个博客干啥" class="headerlink" title="你要用这个博客干啥"></a>你要用这个博客干啥</h1><p>我还只是一个萌新，还有很多东西尚未了解，写不出大佬那样条条有序，严谨的代码。所以写写自己的学习笔记，一些对自己难题的解决分享，说通俗点就是随便写写，把自己的收获分享给大家，当然可能会出现很多错误，也希望各位大佬能严格指出。哈哈哈~。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
