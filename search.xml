<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[太极·magisk]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%A4%AA%E6%9E%81%C2%B7magisk%2F</url>
    <content type="text"><![CDATA[太极·magisk，也被成为太极·面具或太极·阳，是一种不修改系统文件的框架，比以前的xposed框架好一些的框架。当然，这是我的理解….. “无极而太极，太极动而生阳，动极而静，静而生阴，静极复动，一动一静，互为其根，分阴分阳，两仪立焉。” –《太极图说》 为什么要装框架，很多不搞机的用户会问，我也只是菜鸟，我只能以我的眼光说，为了美化自己的手机，使自己的手机变的独特。比如装去广告的插件，管理后台插件，手势插件，状态栏沉浸式等。当然，很多插件现在的系统都有内置，这也使得刷机也变得越来越少。 而我之所以刷机，是为了装应用变量，骗联通的5G体验包，有100G呀，可惜晚了两天，一不做二不休，为了以防万一以后用到，干脆刷了算了。而我们搞机用户也常说，我可以不用，但你不可以没有。 太极·阴首先介绍太极·阴，是不用刷机直接安装的软件，但要先下载软件，可以去关注虚拟框架公众号回复“最新版”下载太极。 想使用的模块(插件)也可以在这公众号下载安装。然后在软件点击那个像放大的按钮，再点击模块管理，勾选你要使用的框架。 但使用某些模块，需要把相应的软件也放到太极里。这里就体现出太极·阴的不好处，你需要把原始应用卸载，然后在太极·阴里安装。每一次软件更新，就要重新安装一遍，由于数据是保存在太极里，所以可能会丢失数据，好像也不可以应用双开。但是别忘了，太极·阴是不用BL解锁和root的，直接安装的软件，适用于现在大部分的手机。 太极·阳因为现在厂商对系统的限制，大部分都有BL锁，才能root。而能够轻松的BL解锁好像只要小米和一加手机吧。我的手机是小米，所以只能以小米为例。 小米BL解锁网址：http://www.miui.com/unlock/index.html 接下来就是刷第三方rec，可以在百度搜索 “某某手机 rec”，例如：小米8 rec 当然小米手机可以在MIUI论坛的http://www.miui.com/space-uid-362247641.html 的帖子找，来刷rec 现在来安装magisk，你可以百度magisk，去它的官网下载，https://forum.xda-developers.com/apps/magisk 第一个帖子就是magisk安装包，现在的版本是2019.6.4，19.3 点进去找到Downloads(下载)，我们只需要下载Latest Stable(最新稳定版)和Magisk Manager。 由于官网打开比较慢，所以，可以去其他网址下载或去酷安下载Magisk Helper(面具助手)。一定要下载Magisk和Magisk Manager。 然后安装Magisk Manager，关机进入rec，然后找到Magisk位置，刷入Magisk。 先刷rec还是先装Magisk Manager看各人喜好，但刷Magisk一定在刷rec之后。 打开软件大致就是这样，点开左上角的按钮，里面一定要有下载的按钮。如果没有那就说明刷的有误….重新再来刷Magisk吧。 接着去下载里面下载”Tai Chi”，以上做那么多步，就是为了这个插件。如果下载里不能下载，可以去虚拟框架回复”面具”下载，然后在magisk或rec下安装这个插件。 然后再点开太极，就会发现面具变为太极·阳，可以直接添加软件到这里面。不用怕更新安装麻烦和导致数据丢失。 在安装了magisk之后，现在你打开设备解锁状态和ROOT权限。咦！竟然又锁上了，其实它们只是表面上锁了，你也不用担心不能用magisk或给应用权限。 PS:因为刷入第三方rec，所以更新系统只能线刷或者在MIUI官方下载完整包在rec里更新，magisk(面具)也可能会掉。。。只能重新刷，所以，请小心使用，不要删除Magisk。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>太极</tag>
        <tag>magisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（三）]]></title>
    <url>%2F2019%2F08%2F06%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本次记录的是方法，在其他语言也被称为函数。 我们写java代码中，main也是方法。public static void main(String[] args){}。其中public是访问控制修饰符，static是非访问修饰符，也称为静态修饰符，void是返回值类型，String[]是参数类型，为字符串数组(要区别字符数组char[]),args是参数名。 为什么要使用方法，为了更好的调用，减少代码冗余度，避免不必要的浪费，也为了减少代码修改的次数。 方法的定义1234修饰符 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2...)&#123; 代码; return 返回值;&#125; 修饰符修饰符:告诉编译器这个方法如何使用。方法中有四个访问控制修饰符：，public、protected、default、private。和两个基本非访问修饰符：final和static。 访问控制修饰符public：公有访问修饰符。可以被所有类访问。 protected：受保护富访问修饰符。对同一包内的类和所有子类使用。 default：默认修饰符。在同一个包内可见。 private：私有访问修饰符。只能是当前类使用。 以default为例，在java中，不是静态方法或类，都要先new一个对象，才能使用相应的方法或类。其它修饰符也可以做，使用不同的包建立class，感受这些修饰符感受差异。 123456789public class FangfaTest &#123; public static void main(String[] args) &#123; FangfaTest ff = new FangfaTest(); System.out.println(ff.add(1,2)); &#125; int add(int a, int b) &#123; return a+b; &#125;&#125; 而public和private应该是最常用的修饰符吧，使用的次数挺多的。当然，这里强调下，在一个类中，只能有唯一一个public类，但可以有多个public方法。 非访问修饰符static：静态修饰符，静态变量和方法可是直接使用。 final：变量一旦赋值，就不能更改，和static使用创建类常量。 static修饰的方法直接使用，不需要创建对象。常用的类Math也是静态类，它里面有很多方法也是静态方法。 123456789101112131415161718192021222324public class FangfaTest &#123; static int a = 1; //静态修饰的变量 final int B = 2; //final修饰的变量，也称为常量，不能更改值 public static void main(String[] args) &#123; System.out.println(add(1,2)); //使用static修饰的方法 a = 2; //修改static修饰的变量 // B= 3; final修饰的常量不能更改值，修饰的类也不能继承 System.out.println(a); FangfaTest ff = new FangfaTest(); System.out.println(ff.add(1.2,2)); //只要不是static修饰的方法，都要先new一个对象 &#125; //下面是方法重载，返回值类型和参数类型不同 final double add(double a, double b) &#123; return a+b; &#125; static int add(int a, int b) &#123; return a+b; &#125;&#125; 以上六种修饰符，不仅可以用在方法上，也可以用在类或类里的数据类型上。当然，修饰符还有其它的，那就要讲到后面的内容慢慢补充。 方法的返回类型方法的返回也就是我们前面记录的八种基本数据类型和现在慢慢补充的引用类型，比如数组，以后的字符串String或者是类。还有无返回类型void。 用基本数据类型int实例: 12345678910public class FangfaTest &#123; public static void main(String[] args) &#123; FangfaTest ff = new FangfaTest(); System.out.println(ff.add(1,2)); &#125; int add(int a, int b) &#123; return a+b; &#125;&#125; 返回类型为void实例： 1234567891011public class FangfaTest &#123; public static void main(String[] args) &#123; FangfaTest ff = new FangfaTest(); ff.add(1,2); &#125; void add(int a, int b) &#123; System.out.println(a+b); return; //虽然没返回值，但return有两个意思，一个结束运行，另一个返回结果。在这只是结束运行。 &#125;&#125; 用类简单写了一个1+2，然后用方法调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FangfaTest &#123; public static void main(String[] args) &#123; //先把对象建立，两个类，两个对象 FangfaTest ff = new FangfaTest(); adds a = new adds(); //设置私有变量a和b的值 a.setA(1); a.setB(2); //输出结果 System.out.println(ff.add(a)); &#125; //公有类的方法 int add(adds a) &#123; //调用了adds类 return a.add(); &#125;&#125;//类的封装，我可以在set方法中设置我的要求，比如是正整数呀，范围多少，增加限制，减少代码出错率class adds&#123; private int a; private int b; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public int getB() &#123; return b; &#125; public void setB(int b) &#123; this.b = b; &#125; public int add() &#123; return this.a+this.b; //关键字this，指当前的类的变量 &#125;&#125; 方法的重载重载，意思就是实现的内容大致一样，只是参数类型不同，返回类型无所谓，但参数类型一定要不一样，否则，编译器不知道用谁。 1234567891011121314151617181920public class Test02 &#123; public static void main(String[] args) &#123; Test02 t = new Test02(); System.out.println(t.add(1, 2)); System.out.println(t.add(1, 2, 3)); System.out.println(t.add(1.2, 2.1)); &#125; int add(int a,int b) &#123; return a+b; &#125; int add(int a,int b, int c) &#123; return a+b+c; &#125; double add(double a, double c) &#123; return a+c; &#125;&#125; 如果把double add()里的参数类型都变成int，那就会编译器报错。所以一定是参数类型不同才能重载。 值传递与引用传递形参:方法中定义的参数。 实参:调用中，传入方法的实际参数。 值传递:只是把值传给方法的参数，但不改变原参数的值。一般只有八种基本数据类型是值传递。 引用传递(址传递):传入方法中，如果方法里的参数改变了数据，那么原参数也改变。一般只是引用类型会改变。 为什么会有值传递和址传递的差异？ 说白了就是指向的对象不同，值传递是在方法调用中，指向一个新的数据变量，址传递因为一开始都指向同一个对象，那么原参数也改变。 1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;public class test03 &#123; public static void main(String[] args) &#123; //基本数据类型，一般是值传递 int a = 10; //一开始a是10 changeInt(a); //方法里把a变为20 System.out.println(a); //值传递并没有改变原a的值 //引用类型，一般是引用传递/址传递 int []arr = new int[] &#123;0,1,2,3,4,5,6,7,8,9&#125;; changeArr(arr); //数组是一个对象，改变同对象的值 System.out.println(Arrays.toString(arr)); //方法中重新new一个对象 changeArr2(arr); //新的方法，重新new一个数组[0,1,2,3,4] System.out.println(Arrays.toString(arr)); //但并没有改变原数组的值，因为它们的指向的地址不同 &#125; public static void changeInt(int a) &#123; a = 20; &#125; public static void changeArr(int a[]) &#123; for(int i=0; i&lt;a.length; i++) &#123; a[i] = (i+1)*2; &#125; &#125; public static void changeArr2(int a[]) &#123; a = new int [5]; //新new一个数组 for(int i=0; i&lt;a.length; i++) &#123; a[i] = i; &#125; &#125;&#125; 方法就这么多记录，有遗漏欢迎在评论区补充，有不足也请多多关照，在评论区留言，也感谢您的观看，下次见。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（二）]]></title>
    <url>%2F2019%2F08%2F05%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本次主要记录的是基本控制语句、数组两块内容 基本控制语句在java中，控制语句有顺序结构、选择结构、循环结构三类。而顺序结构我们写一般的代码，一行一行的写下去，就像看书一样，有顺序，一行一页。 本次主要记录的是选择结构和循环结构。 选择结构选择也称为判断，如果…就…，只有满足条件才执行响应的语句块。 if语句如果第一个if执行，输出大数，如果第二个if执行，输出小数。有多少个if，就进行几次判断。 1234567891011int a = (int)(Math.random()*10+1); //random()是Math类的静态方法，产生[0,1)之间的随机数，为浮点型//random()*10，就是产生[0,10)之间的随机数，再加1,产生[1,11)之间的浮点型随机数，最后转为int型System.out.println(a);if(a&gt;=5) &#123; //()里填的条件语句是布尔表达式，为真执行语句 System.out.println(&quot;大数&quot;);&#125;if(a&lt;5) &#123; System.out.println(&quot;小数&quot;);&#125; if-else语句我们把上面的代码改改，变成if-else语句，变量a只需要判断一次，如果if不执行，那么else执行 12345678int a = (int)(Math.random()*10+1); System.out.println(a);if(a&gt;=5) &#123; //()里填的条件语句是布尔表达式，为真才执行语句 System.out.println(&quot;大数&quot;);&#125;else &#123; //if里不执行，那表达式为假，就跳到else执行 System.out.println(&quot;小数&quot;);&#125; if-elseif-else语句如果我们要输出成绩怎么办，优、良、中、及格、不及格，我们用if和if-elseif-else进行对比。 以下为了方便直观，把判断句的语句块都去掉了，但很容易出现问题。所以请记住，一定要打{}。 1234567891011121314151617int a = (int)(Math.random()*100+1); System.out.println(a);//先用if来操作if(a &lt; 60) System.out.println(&quot;不及格&quot;);if(a&gt;=60 &amp;&amp; a &lt; 70) System.out.println(&quot;及格&quot;);if(a&gt;=70 &amp;&amp; a &lt; 80) System.out.println(&quot;中等&quot;);if(a&gt;=80 &amp;&amp; a &lt; 90) System.out.println(&quot;良好&quot;);if(a &gt;= 90) System.out.println(&quot;优秀&quot;);System.out.println(&quot;--------------------&quot;);//现在用if-else if-else操作if(a&gt;=90) System.out.println(&quot;优秀&quot;); //如果大于等于90执行这条语句else if(a&gt;=80) System.out.println(&quot;良好&quot;); //否则，大于等于80执行这条语句else if(a&gt;=70) System.out.println(&quot;中等&quot;); //再否则， 大于等于70执行这条语句else if(a&gt;=60) System.out.println(&quot;及格&quot;); //再再否则， 大于等于60执行这条语句else System.out.println(&quot;不及格&quot;); //再再再再否则，终于输出最后一条语句 嵌套的if我们可以在if里再加判断句。 12345678if(布尔表达式)&#123; if()&#123; if()&#123;&#125; else if()&#123;&#125; else &#123;&#125; &#125; else &#123;&#125;&#125; 我们用嵌套的if-else来输出成绩 123456789101112131415161718192021if(a&gt;=90) &#123; System.out.println(&quot;优秀&quot;);&#125;else &#123; if(a&gt;=80) &#123; System.out.println(&quot;良好&quot;); &#125; else &#123; if(a&gt;=70) &#123; System.out.println(&quot;中等&quot;); &#125; else &#123; if(a&gt;=60) &#123; System.out.println(&quot;及格&quot;); &#125; else &#123; System.out.println(&quot;不及格&quot;); &#125; &#125; &#125;&#125; 如果把{}都拿掉，是不是很像if-elseif-else类型。 总结一下if条件语句，如果只满足一个条件才执行，那就用if单条语句，如果判断对立面，那就用if-else语句，如果有多判断多选择，就用if-elseif-else。好像说的废话一样。。。怎么方便怎么用就行。 switch语句此switch非彼switch，不是游戏机，没有任天堂，就是用来判断的，是多选择语句，和if-else if-else类似。但是switch可以很简单用字符串来判断。你也可以在case里嵌套switch，实现嵌套判断。 123456789101112131415161718String[] game = &#123;&quot;ps4&quot;, &quot;xbox&quot;, &quot;switch&quot;&#125;; //这是字符串数组，马上讲数组了，而字符串会专门讲，很重要int i = (int)(Math.random()*3); //数组从0开始，所以这里随机[0,3)就行System.out.println(i);switch(game[i]) &#123; case &quot;ps4&quot;: System.out.println(&quot;大家好，我是索尼游戏机&quot;); break; //break是停止语句，接下来语句块内的内容不执行，一般在循环语句块用 case &quot;xbox&quot;: System.out.println(&quot;大家好，我是微软游戏机&quot;); break; //如果没有break,当i=0时，会输出全部内容 case &quot;switch&quot;: System.out.println(&quot;大家好，我是任天堂游戏机&quot;); break; default: //相当于else,可以把case &quot;switch&quot;去掉，把输出任天堂放到这里 break;&#125; 循环语句只要满足相应的条件，就一直执行下去。 for循环123456for(初始值; 循环条件; 循环走向)&#123;&#125;初始值:循环从开始的地方循环条件:循环在什么情况下满足条件循环走向:循环是递增还是递减,等比数列还是等差数列进行取值 123456789101112for(int i=0; i&lt;=10; i++) &#123; //System.out.print(i+&apos; &apos;); 这里把char和int型加在一起，相当于(i+32),输出3233343536373839404142 System.out.print(i+&quot; &quot;); //这样才打印[0,10] 输出0 1 2 3 4 5 6 7 8 9 10 &#125;//原因:char是一个字符，能与int相加转型为int型，而&quot; &quot;是字符串(String)//&quot; &quot;里有两个值，&apos; &apos;和&apos;\0&apos;组成，不会与int型相加//但String会把之后的内容拼接在一起,下面把循环输出改一改for(int i=0; i&lt;=10; i++) &#123; System.out.print(i+2+&quot; &quot;+i+2+&apos; &apos;); //输出2 02 3 12 4 22 5 32 6 42 7 52 8 62 9 72 10 82 11 92 12 102&#125;//&quot; &quot;前i和2相加，之后把i和2还有&apos; &apos;拼接在一起,所以用String类型，要注意放的位置 增强for循环增强for循环一般只是输出变量的数值。下面打印0~9的数。 123456int [] a = &#123;0,1,2,3,4,5,6,7,8,9&#125;;//for(Object 临时变量名:要打印的变量名)//增强for循环不仅可以用于基本的数据类型，还能用于类，类都继承了Object对象for(int temp:a) &#123; System.out.print(temp+&quot; &quot;);&#125; while循环while循环只有循环条件，初始值只能在循环体外定义。 下面输出0到10的数 12345int i=0;while(i&lt;=10) &#123; System.out.print(i+&quot; &quot;); i++;&#125; for和while都是比较常用的循环。 do-while循环12345int i=5;do &#123; System.out.print(i+&quot; &quot;); i++;&#125;while(i&lt;0); do-while和while有啥区别呢，那就是do-while第一次无论 有没有满足条件，都先执行一次，而while、乃至for都是先要满足条件才执行。而上面的这段代码，5本来就小于0，而do-while会打印了5，才来判断是否满足条件。 嵌套循环我们用for和while分别打印乘法表。 123456789101112131415161718for(int i=1; i&lt;=9; i++) &#123; for(int j=1; j&lt;=i; j++) &#123; System.out.print(j+&quot;*&quot;+i+&apos;=&apos;+(i*j)+&apos; &apos;); //之前说过&quot;&quot;之后是字符串拼接，所以(i*j)打了括号，当然不打括号也行，*优先级大于+ &#125; System.out.println();&#125;System.out.println(&quot;------------------------&quot;);int i=1;while(i&lt;=9) &#123; int j=1; while(j&lt;=i) &#123; System.out.print(j+&quot;*&quot;+i+&apos;=&apos;+(i*j)+&apos; &apos;); j++; &#125; System.out.println(); i++;&#125; 当然，如果想输出对其，最简单的办法就是用C语言的格式输出。 System.out.printf(“%d*%d = %2d “,j,i,i*j); !、&amp;&amp;、||、^第一篇写了!、&amp;、|，我还少写了^，没咋用忘了。前面写了!能改变boolean值，&amp;、|参与二进制的相关运算，而今天的&amp;&amp;和||是什么呢？ 当然，它们也是参与布尔表达式的运算，常常在条件语句和循环语句出现，前面也提及过，if()里进行的是布尔表达式，循环里的循环条件也是布尔表达式。我们来一起用用吧。 符号 名称 说明 ! 非 肯变否，否变肯 &amp;&amp; 与 全真才真 || 或 全假才假 ^ 异或 一真一假为真 条件语句经常和循环语句一起使用，我们来看看下面的例子。 1234567//输出1000年到2999年之间有多少闰年for(int i=1000; i&lt;= 2999; i++) &#123; if((i%4==0 &amp;&amp; i%100!=0) || i%400==0) &#123; //里面可以不用加()，!的优先级&gt;&amp;&amp;&gt;&gt;|| System.out.println(i+&quot;\t&quot;); &#125;//闰年一定可以被4整除，而千年是闰年，还能被400整除，可是百年大部分都不是闰年，但它能被100整除&#125; 123456789101112131415161718192021int a = 2, b = 3, c = 0;if(!(c!=0) &amp;&amp; a&gt;1) &#123; System.out.println(&quot;c不是不是0，并且a的值大于1&quot;); //有点拗，c!=0，是false,又加个否定，等价于c==0&#125;if(a&gt;2 &amp;&amp; (c++)&gt;=0) &#123; System.out.println(&quot;有输出吗?&quot;);&#125;System.out.println(&quot;c:&quot;+c);//看的出来， a&gt;2不成立，没有执行if里的内容，&amp;&amp;后面也没有执行if((c++)&gt;=0 &amp;&amp; a&gt;2) &#123; System.out.println(&quot;有输出吗?&quot;);&#125;//更改一下位置，c++,c变为1，条件成立，但a&gt;2不成立，没有执行if里的内容System.out.println(&quot;c:&quot;+c);if(a&gt;2 || (c++)&gt;=0) &#123; System.out.println(&quot;c:&quot;+c);&#125;// ||有一个成立就行，所以if里打印了c的值 123456789101112131415161718 //这是异或的示例 int a = 5, b = 3; System.out.println(a^b); //输出 6/* * 原理还是二进制 * 5的二进制：0101 * 3的二进制：0011 * 那么^之后：0110 就是6啦，一真一假为真 */ int a1 = 2, b1 = 3, c1 = 0; if(a1&gt;2 ^ (c1++)&gt;=0) &#123; //a1&gt;2假，(c1++)&gt;=0真 System.out.println(c1); //输出c1为 1 &#125; if(a1==2^b1==3) &#123; System.out.println(&quot;有输出吗?&quot;); //没有输出 &#125; break和continuebreak是强制退出循环，不执行剩余的内容；而continue是跳过本次循环的内容。 下面是嵌套循环，在j==3进行了处理，break每次到j==3时，跳出内循环，进行下一次外循环。而continue是跳过本次内循环，进行下一次内循环。 12345678910111213141516for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) break; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println();&#125;System.out.println(&quot;------------------------------------------------------&quot;);for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) continue; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println();&#125; 在C语言中，有一个语句叫goto，很少用，因为太调皮了。能够从一个语句跳转到另一个语句，用起来很爽，但太乱了，所以java中就只成为保留字，没有任何意义。但是，break和continue却有点像goto，不执行接下来的语句，执行另外的语句，只是限制在了循环里。而它只是不执行内循环接下来的语句，如果我们也不想执行外循环接下来的语句呢？ 1234567891011121314151617a:for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) break a; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println();&#125;System.out.println();System.out.println(&quot;------------------------------------------------------&quot;);a:for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) continue a; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println(); //这条语句就成了摆设，可以放在第一个循环下面&#125; 也差不多实现和goto一样的意思，想跳哪就去哪，只是限制在循环里的操作。如果里面的判断再多点，估计也就像goto一样看不懂了，所以我感觉自己玩玩挺好的，真正拿来写代码，那有点得罪人的意思了。 数组当存在多个相同数据类型的变量，我们用x1,x2,x3,x4…进行数据操作时效率太低，因此才有了数组。数组分为一维数组在，和多维数组，我们最常用的应该就是一维数组在和二维数组。而这个维度，指的只是空间的增多而已。一维只是一行元素，二维在一维的每个元素又拉出来一列，构成一个矩阵。三维也是只在每行每列的每个元素又来出来一纵，构成一个像魔方一样的立体。四维也就只是再在每个元素又拉出一行元素，以此类推。 数组的声明和赋值好像有三种吧。但好像我一般只用两种。 一维数组第一种是声明数组类型和长度，然后赋值。 1234567891011121314//数组声明int []a = new int [10]; //[0,10)//int a[] = new int [10]; //这种也可以，但好像不规范//数组赋值，数字下标从0开始计算a[0] = 0;a[1] = 1;a[2] = 2;//也可以循环赋值for(int i=3; i&lt;10; i++) &#123; a[i] = i;&#125;System.out.println(Arrays.toString(a)); //一定要引入 import java.util.Arrays;//打印出[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 第二种是声明数组类型写内容 123int []a = new int[] &#123;0,1,2,3,4,5,6,7,8,9&#125;;System.out.println(Arrays.toString(a)); //一定要引入 import java.util.Arrays;//打印内容和上面一样 第三种是直接写内容 12345int []a =&#123;0,1,2,3,4,5,6,7,8,9&#125;;for(int i=0; i&lt;a.length; i++) &#123; //也可以用循环打印结果，length是获取数组的长度 System.out.print(a[i]+&quot; &quot;);&#125;//输出 0 1 2 3 4 5 6 7 8 9 二维数组1234567891011int [][]a = new int [3][]; //告诉编译器二维数组有三行，每行多少个就看你自己写的//int [][]a = new int [3][4]; //也可以直接写死，有三行，有四列a[0] = new int[] &#123;0,1,2&#125;;a[1] = new int[] &#123;0,1,2,3,4&#125;;a[2] = new int[] &#123;0,1&#125;;for(int i=0; i&lt;a.length; i++) &#123; for(int j=0; j&lt;a[i].length; j++) &#123; System.out.print(a[i][j]+&quot; &quot;); &#125; System.out.println();&#125; 1int [][]a = new int[][] &#123;&#123;0,1,2&#125;,&#123;0,1,2,3,4&#125;,&#123;0,1&#125;&#125;; 二维数组也可以像一维数组一样声明和使用，但它列可以是不固定的，有多长看自己的喜爱。但我一般喜欢用固定，方便两层for循环输入数据。 12345678int [][]a = new int[3][4];for(int i=0; i&lt;a.length; i++) &#123; for(int j=0; j&lt;a[i].length; j++) &#123; a[i][j] = i*j+i+j; &#125; &#125;System.out.println(Arrays.deepToString(a)); //声明 import java.util.Arrays;//输出 [[0, 1, 2, 3], [1, 3, 5, 7], [2, 5, 8, 11]] 数组内容虽然写的少，要点也有点少。但它真的很重要，如果写算法题，遇到二叉树呀，图呀，动态规划之类的题，或搜索呀。必不可少就是数组，因为数组才能表示上一次的递推和下一次的联系、关系。而这些题也很能锻炼写代码的逻辑思维，或者用数组模拟单链表的插入和删除、遍历。这些真的考验思维能力。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（一）]]></title>
    <url>%2F2019%2F07%2F30%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本次主要记录的是基本数据类型、数据类型转换、基本运算符和进制表示四块内容。 基本数据类型java中基本数据类型有八种基本类型，包括整数型、浮点型、字符型和布尔类型这几类。如有不足，多多指教。 整数类型java中整数类型有byte、short、int、long共四种。占八种基本数据类型的一半。 类型 范围 默认值 位 byte -128~127 0 8 short -32768~32767 0 16 int -2147483658~2147483657 0 32 long -2^31~2^31-1 0L 64 其中，整数的默认类型是int，所以使用long类型，由于数据范围比int大，要在其值后加上L/l,来表明它是long类型。但l和1(一)太相像，所以通常用大写的L。而byte和short就不需要类型转换，因为它们的数据范围本身比int小，自然不会超过int表示范围。 12345//这些都在自己的数据范围内byte a = 18; //输出 18short b = 1000; //输出 1000int c = 40000; //输出 40000long d = 3000000000L;; //输出 3000000000 而下面则是错误示范，还没运行，编译器自动提示错误：前两个是类型不匹配，无法从int转为byte/short，后两个都是超过int数据类型的范围。更能说明long的默认数据类型是int，因为他没超过long的数据范围。 浮点类型java中浮点类型有float和double共两种。 类型 范围 默认值 位 float 1.4E-45~3.4028235E38 0.0f 32 double 4.9E-324~1.7976931348623157E308 0.0d 64 浮点类型数据范围挺大的，但不太精确，做运算都有可能有误差。不过double则要比float类型精确些，而且在java中，浮点类型的默认类型是double。所以，我们通常用double更多。当然也可以使用float，不过要在其值加上f，否则编译器会报错。 12345678910//float使用float f1 = 1.2f; //f大小写都行//double使用double d1 = 1.5;double d2 = 1.7d; //可以在后面加d或D//使用科学计数法，以double为例double d3 = 314e-2; //输出 3.14double d4 = 314e2; //输出31400.0 以下是以doubl为例，进行的运算。 1234567891011double a = 12.3;double b = 12.3;double c = 24.6;double e = a + b;System.out.println(e);System.out.println(a == b);System.out.println(c == e);double d = a + c;double f = 36.9;System.out.println(d);System.out.println(d == f); 这是以加法为例，说明浮点类型在进行运算的不可靠。而可能这几行代码在你的电脑就全是true。当然这你可能会有疑惑，浮点计算不可靠，那银行算金额咋办，我觉得可能是他们内部自己用字符串转换成char数组，找到’.’的位置，在把数组每个值与另一个数组对应的值进行运算，这想想挺麻烦的，但其实java有自己的类进行浮点运算，那就是BigDecimal，它属于Math类中，以后讲常用类会提及。 字符类型java中字符类型是char表示，数据范围从0~65525，其默认值为\u0000, 在内存中占16位。 1234char c = &apos;A&apos;; //注意要打单引号，双引号就是字符串啦System.out.println(c); //输出 Aint a = 97; //也可以把整型强制转换成char类型，后面会提及类型转换System.out.println((char)a); //输出 a 布尔类型java中布尔用boolean表示， 它只有两个取值true和false。true为真，false为假，默认值为false。 在内存中占1位。 123456boolean flag = true;if(flag) &#123; //等价于 flag==true //if条件语句只有true时，才执行 System.out.println(&quot;flag为&quot; + flag);&#125;//输出 flag为true 数据类型转换数据转换分为两种，一种是自动转换，容量小的自动转换成容量大的，另一种是强制转换(强制把某种类型转换成另一种类型)，强转可能会出现精度损失。 什么是精度损失？比如1.9的浮点型，强制转为整型，就变成1，小数部分直接舍弃。 自动转换byte–&gt;short–&gt;char–&gt;int–&gt;long–&gt;float–&gt;double当然整型转换成浮点型，有可能会出现精度的损失。 123456789101112131415161718byte bt = 127;int bc = bt;System.out.println(bc); //输出 127int a = 12;double b = a;System.out.println(b); //输出 12.0long c = 1234567890123456789L;float d = c;double dou = c;//电脑不同，可能输出的结果也有一点点差别System.out.println(d); //输出 1.23456794E18System.out.println(dou); //输 1.23456789012345677E18char ch = &apos;\u0010&apos;; //可以看的出来是char占16位int ch2 = ch;System.out.println(ch2); //输出16 从代码中，这些都是自动转换，但也有人会问，为啥long都能自动转换为float，long占64位，float占32位，但java自动转换不是看谁在内存占的位数大就转谁，而是看容量。浮点型中，容量是不能直接算出来的，而float的最大值远远大于long的最大值，所以long能自动转换为float。但数值一大，就会出现精度损失。 强制转型一般把容量大的转换成容量小的，但转换的变量数据不能超过转换后的容量，虽然编译器不会报错，但输出结果可能是错误的。 以整型为例: 123456int a = 18;byte a1 = (byte)a; //把int型强制转换成byte型，并且18在byte范围内System.out.println(a1); //输出 18a = 128; //128已经超过byte数据范围a1 = (byte)a;System.out.println(a1); //输出 -128 可以看出强制转型一定要在合理范围内，比如说，两个杯子，一个大杯子是满的，另一个小杯子是空，我们无法把大杯子的水都倒在小杯子里。反过来我们可以把装满水的小杯子倒在空的大杯子，不过这是自动转型啦。 强制把浮点型转换成整型型，可能会出行精度损失。 1234double d = 1.9; //如果浮点本身是没有小数，转整型就不会出行精度损失int a = (int)d;System.out.println(a); //输出 1System.out.println(d); //输出1.9 转型是不改变原变量的值 基本运算符 运算符 名称 例子(int型) 结果 + 加法 a = 1+2 a = 3 - 减法 a = 2-1 a = 1 * 乘法 a = 5*2 a = 10 / 除法 a = 5/2 a = 2 % 求余/取模 a = 5%2 a = 1 ++ 自增 a1 = a2 = 2; b = a1++; c = ++a2 b = 2; c = 3 - - 自减 a1 = a2 = 2; b = a1- -; c = - -a2 b = 2; c = 1 &amp; 与 a = 5; b = 3; c = a&amp;b c = 1 | 或 a = 5; b = 3; c = a|b c = 7 ! 非 boolean flag = false;flag = !flag; flag = true &lt;&lt; 左移(*2) a = 1&lt;&lt;2 a = 4 &gt;&gt; 右移(/2) a = 8&gt;&gt;3 a = 1 以上就是java中最常用的运算符，加减乘数是基本的四则运算，整数和浮点型可以一起运算，但是，低的数据类型会向高的数据类型自动转换。如果不同类型进行运算，赋值的变量数据类型要是最大的那个。 四则运算123456789101112131415int a1 = 12;long a2 = 23; //23一开始是int型，赋值个a2变成了long型//a1 = a1+a2; //a1和a2相加向long类型转换，所以会报错//但我们可以进行下面这运算a1 += a2; //等价于 a1 =(int)(a1+a2); 把long型强制转换成int型//浮点型最注意除法运算double d = 1.2 + 5 / 2; //输出 3.2//在运算过程中,先/，5/2，两个都是整型，结果也是整型2，2+1.2就是结果，这里好像是转换成2.0+1.2//那怎么办，办法如下//把其中一个整型变成浮点型d = 1.2 + 5.0/2; //输出 3.2//d = 1.2 + (double)5/2; 这样也是可以的，但太麻烦，很少用吧...//d = 1.2 + (double)(5/2); ps:这是错误，和第8行运算一样的结果 求余% 就是求一个数除以另一个数得到它的余数，所以称为求余或取模。 123456int a = 10%3; //输出 1//注意，求余结果符号和除数用关a = -10%3; //输出 -1a = 10%-3; //输出 1a = -10%-3; //输出 -1 ++和- -自增是自己加1，自减是自己减1，但要注意放的位置。 123456//++和--都一样，以++为例int a1 = 2;int a2 = 2;int b1 = a1++; //b1 = 2 运算为 先b1 = a1, 然后a1 += 1int b2 = ++a2; //b2 = 3 运算为 先a += 1， 在b2 = a2 //最后结果a1和a2都为3 &amp;、|、！12345678910111213141516171819 int a1 = 5, b1 = 3; int c1 = a1&amp;b1; //输出1/* * 与运算是真真为真，一真一假为假，假假为假 * 而这里的真是二进制的1，假为二进制的0 * 5的二进制为 0101 * 3的二进制为 0011 * 进行与运算 0001 所以答案为1 */ int a2 = 5, b2 = 3; int c2 = a2|b2; //输出7/* * |运算是真真为真，一真一假为真，假假为假 * 所以5|3 为 0101 * 0011 * 0111 答案为7 */ boolean flag = false; //一开始flag为假(false） flag = !flag; //!flag意思是 不是假， 那么flag就是真(true) !有否定的意思 &lt;&lt;和&gt;&gt;左移一位是乘2，左移两位是乘4……以此类推。右移一位是除以2，右移两位是除以4……以此类推。通常在乘2或除以2，建议用&lt;&lt;和&gt;&gt;，效率上要比*和/快一点。 12345678910 int a = 1&lt;&lt;2; //输出 a为4/* * 1的二进制是0001，把1左移两位，变成0100，变成了4 */ int b = 8&gt;&gt;3; //同理，1000右移三位，变成0001 //当然不是移一个数，是整体的移动，下面以7为例 //0111&lt;&lt;1 ---&gt; 1110 变为 14 7*2=14 //0111&gt;&gt;1 ---&gt; 0011 变为 3 7/2=3 进制表示 “世界上只有10中人，一种是懂二进制，另一种是不懂二进制”。 二进制由0和1组成，而我们的代码最终也会变成二进制运行，计算机也是以二进制进行工作，网络信息也是以二进制在物理层传输。所以二进制对我们来不会很陌生。 初次之外，我们还有八进制、十六进制和常用的10进制，让我们用代码表示。 12345678910//都表示输入10这个数int a1 = 10; //写代码默认十进制 十进制:0 1 2 3 4 5 6 7 8 9int a2 = 0b1010; //二进制表示10，前面加0b/0B 二进制:0 1int a3 = 012; //八进制表示10, 前面加0就行 八进制:0 1 2 3 4 5 6 7 int a4 = 0xA; //十六进制表示10，前面加0x 十六进制:0 1 2 3 4 5 6 7 8 9 a b c d e f//那么如何输出各进制的10呢?System.out.println(Integer.toBinaryString(10)); //二进制System.out.println(Integer.toOctalString(10)); //八进制System.out.println(10); //额...十进制System.out.println(Integer.toHexString(10)); //十六进制 以上就是本次总结，本来还想写很多，把常用语句也记录上，那样就会太长了，只能等下一篇文章了。如有不足之处，请在下方评论区留言，谢谢您的来访~ ~ ~下次见。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客记]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[博客搭建好了，让我这个小萌新说点什么吧，如有不足，各位多多包涵 为什么要搭建博客搭建博客每个人都应该有自己的理由，我的理由是学的东西挺多了，时间一长就忘记了。不想在纸上做笔记，怕弄丢了，而且有新的发现不能在原有的基础上修改，越改越乱。在电脑上也写了一点代码，时间一长也不知道是干啥用的，有的还不容易找到。所有想写点博客，有思路的写，把学习过程写的明明白白。哈哈哈~。当然，也是为了提升自己嘛，耳边总会响起一句话：“你想成为什么样的人？”。我不知道会成为什么样的人，只要还是像当初那样热爱就行。 你要用这个博客干啥我还只是一个萌新，还有很多东西尚未了解，写不出大佬那样条条有序，严谨的代码。所以写写自己的学习笔记，一些对自己难题的解决分享，说通俗点就是随便写写，把自己的收获分享给大家，当然可能会出现很多错误，也希望各位大佬能严格指出。哈哈哈~。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
