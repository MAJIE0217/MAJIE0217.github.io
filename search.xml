<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础（七）]]></title>
    <url>%2F2019%2F09%2F15%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这次记录几个常用的类，有Arrays、Math和Data这几个。而更新内容也会越来越少，主要是后面的我也不太….说一下计划，之后记录内部类，泛型和容器，异常，io，多线程，java基础篇也就完结啦。当然，学编程最重要的是逻辑思维，所以少不了数据结构。为了能成为全栈工程师，前端、数据库、servlet也很重要，共勉吧。也许有人会说少了框架，那东西，只是帮助开发，会用就行。基础才最重要。 Arrays工具类Arrays类为数组提供一些方法，还有一个单词Array，网上对它的解释为java中最基本的一个存储结构，两者还是不同的。 而Arrays里面的方法基本都是静态方法，所以可以不用new对象，直接使用。下面就介绍Arrays静态类提供常用的方法吧。 方法名 说明 sort(Object) 顺序排序，实现方法看着是归并排序 toString（Object） 返回数组元素的值 length 返回数组的长度 equals(Object) 比较两个对象的内容是否相等 binarySearch（Object, int） 二分查找该数在数组的位置 copyOf(Object, int) 复制数组的内容从0到int之间 copyOfRange(Object, int, int) 复制数组的内容 1234567891011121314151617181920212223242526272829import java.util.Arrays; //Arrays是外部类，要先引入public class frequentClass &#123; public static void main(String[] args) &#123; int[] a = new int []&#123;3,4,1,7,5,9&#125;; int[] b = &#123;1,4,7,0,4,2,6,5&#125;; Arrays.sort(a); //把数组a排序 System.out.println(Arrays.toString(a)); //打印 [1, 3, 4, 5, 7, 9]。如果直接写a，打印的是a的哈希地址 int c = Arrays.binarySearch(a, 4); //查找数组a，3所在的位置，该数组一定是有序数组 System.out.println(c); //打印 2 System.out.println(Arrays.binarySearch(b, 4)); //4也在数组b里，但不是有序，所以打印莫名其妙的数-7 a = Arrays.copyOf(b, 5); //把数组b从[0，5)复制给数组a System.out.println(Arrays.toString(a)); //打印 [1, 4, 7, 0, 4] a = Arrays.copyOfRange(b, 0, b.length); //把数组从选定的开始位置到结束位置复制给a，这里从[0,b.length) //数组length不用打括号，String的length()才有括号 System.out.println(Arrays.toString(b)); //[1, 4, 7, 0, 4, 2, 6, 5] System.out.println(Arrays.toString(a)); //[1, 4, 7, 0, 4, 2, 6, 5] System.out.println(a.equals(b)); //打印 false。这里比较的是数组a和数组b的对象是否相等，要注意区别 System.out.println(Arrays.equals(a, b)); //打印 true。比较数组a和数组b的内容是否相等 &#125;&#125; Math类数学类，提供很多数学上的计算，所以有很多，这里简要几个说明。 方法名 说明 abs(Long |int |double |float) 任意负数取正 sin(double) 三角函数的求解，还有其它，这里写一个做示范 ceil(double) 向上取整，类似于把浮点数加1再强制取整 floor(double) 向下取整，类似于把double强制转换为int型 sqrt(double) 开方 √double pow(double,double) 求几次方，两者都是double，所以求整数的次方，可能会有精度问题，建议手写整数的次方 random(double) 求[0,1)之间的伪随机数 123456789101112131415161718//Math默认在java.lang包,不需要导入包名public class frequentClass &#123; public static void main(String[] args) &#123; //Math类的两个常量 System.out.println(Math.E); //打印 2.718281828459045 System.out.println(Math.PI); //打印 3.141592653589793 System.out.println(Math.abs(-12)); //打印 12 System.out.println(Math.sin(30*Math.PI/180)); //打印 0.49999999999999994。sin30°= 1/2，精度问题 System.out.println(Math.ceil(1.2)); //打印 2.0 System.out.println(Math.floor(1.5)); //打印 1.0 System.out.println(Math.sqrt(25)); //打印 5.0 System.out.println(Math.pow(2, 4)); //打印 16.0 System.out.println(Math.random()); //打印[0,1)之间的伪随机数 System.out.println((int)(Math.random()*10+1)); //打印[1,10]之间的随机整数 &#125; DateDate类在以前是一个很强的类，所以就被削弱了，很多方法都给了Calendar类。下面这是它的使用方法。 12345678910111213141516171819202122232425262728293031323334import java.util.Date;public class frequentClass &#123; public static void main(String[] args) &#123; Date d = new Date(); //新建一个Date()对象 System.out.println(d); //打印 Sun Sep 15 17:25:25 CST 2019，打印的是当前时间 System.out.println(new Date(1000)); //打印 Thu Jan 01 08:00:01 CST 1970 //设置从1970年1月1号0时0分0秒到1000毫秒的时间 //可能由于时差的问题，所以显示的是8点 System.out.println(d.getTime()); //打印 1568539525671,获取当前时间的毫秒 d.setTime(1000); //和new Date(long)一样，设置纪元时间后的1000毫秒 System.out.println(d); //打印 Thu Jan 01 08:00:01 CST 1970 System.out.println(d.before(new Date(1200))); //打印 true。1000是否在1200之前 System.out.println(d.after(new Date(1200))); //打印 false。1000是否在1200之后 Date d1 = new Date(2000); Date d2 = new Date(1500); System.out.println(d1.compareTo(d2)); //打印1， 如果d1比d2大，相等返回0，小于返回-1 //下面则是被废弃的方法，能用，但不建议使用 d = new Date(); System.out.println(&quot;获取年:&quot;+(d.getYear()+1900));//获取年:2019 System.out.println(&quot;获取月:&quot;+d.getMonth()); //获取月:8。当然现在9月，因为英语日期不是按数字的，所以也是从0开始 System.out.println(&quot;获取日:&quot;+d.getDate()); //获取日:15 System.out.println(&quot;获取时:&quot;+d.getHours()); //获取时:17 System.out.println(&quot;获取分:&quot;+d.getMinutes()); //获取分:34 System.out.println(&quot;获取秒:&quot;+d.getSeconds()); //获取秒:29 System.out.println(&quot;获取星期:&quot;+d.getDay()); //获取星期:0。星期也是从0开始，0是星期天 &#125;&#125; CalendarCalendar则替代了Date类废弃的方法，但，首先，我们先认识时间在java的字段表示。 YEAR MONTH WEEK_OF_YEAR WEEK_OF_MONTH DATE DAY_OF_MONTH DAY_OF_YEAR 年 月 本年的周数 本月的周数 本月的日期 本月的日期 本年的日数 DAY_OF_WEEK AM_PM HOUR HOUR_OF_DAY MINUTE SECOND MILLISECOND 星期几 早上_下午 小时(12小时制) 小时(24小时制) 分钟 秒钟 毫秒 SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY 星期天 星期一 星期二 星期三 星期四 星期五 星期六 JANUARY FEBRUARY MARCH APRIL MAY JUNE JULY 一月 二月 三月 四月 五月 六月 七月 AUGUST SEPTEMBER OCTOBER NOVEMBER DECEMBER AM PM 八月 九月 十月 十一月 十二月 上午 下午 下面是日期的获取。 1234567891011121314151617181920import java.util.Calendar; //Calendar也是外部类public class frequentClass &#123; public static void main(String[] args) &#123; Calendar c = Calendar.getInstance(); //获取当前时间 System.out.println(&quot;年:&quot;+c.get(Calendar.YEAR)); System.out.println(&quot;月:&quot;+c.get(Calendar.MONTH)); //月份从0开始 System.out.println(&quot;日:&quot;+c.get(Calendar.DATE)); System.out.println(&quot;日:&quot;+c.get(Calendar.DAY_OF_MONTH)); System.out.println(&quot;时:&quot;+c.get(Calendar.HOUR)); //12小时制 System.out.println(&quot;时:&quot;+c.get(Calendar.HOUR_OF_DAY)); //24小时制 System.out.println(&quot;分:&quot;+c.get(Calendar.MINUTE)); System.out.println(&quot;秒:&quot;+c.get(Calendar.SECOND)); //星期日为第一天 System.out.println(&quot;星期:&quot;+c.get(Calendar.DAY_OF_WEEK)); System.out.println(&quot;本月第几周:&quot;+c.get(Calendar.WEEK_OF_MONTH)); System.out.println(&quot;本年第几周:&quot;+c.get(Calendar.WEEK_OF_YEAR)); System.out.println(&quot;上午？下午？&quot;+c.get(Calendar.AM_PM)); //上午返回0，下午返回1 &#125;&#125; 下面是设置时间。 我们也要先认识日期在SimpleDateFormat类的表示格式。 y M w W D d H k K h 年 本年的月份 本年的周数 本月的周数 本年的天数 本月的天数 小时[0,23] 小时[1,24] 小时[0,11] 小时[1,12] m s S a F E 分钟 秒 毫秒 AM/PM 本月的周数 星期几 个数只是表示占的位置，比如1999年，用yyyy表示1999，yy表示99。 123456789101112131415161718192021import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class frequentClass &#123; public static void main(String[] args) throws ParseException &#123; //throws抛出异常 Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(); //设置输出日期格式 String str = sdf.format(d); //把日期转换成字符串 System.out.println(str); //打印 19-9-15 下午6:51 str = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()); System.out.println(str); //打印 2019-09-15 18:51:45 sdf = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;); str = &quot;2000/1/2 3:4:5&quot;; //输入的格式一定要与上面的一致 Date date = sdf.parse(str); //把字符串转换为日期 System.out.println(date); //打印 Sun Jan 02 03:04:05 CST 2000 &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（六）]]></title>
    <url>%2F2019%2F09%2F13%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这次主要记录抽象类、接口和String的其它学习。 抽象类什么是抽象类呢？定义一个类，我们可以不必完全实现它里面的功能，这就是抽象类。没有具体的方法，就是抽象。 下面是具体的使用。 12345678910111213141516171819202122232425262728abstract class Animal //定义一个抽象类animal&#123; String color; //抽象类里可以有属性 public Animal(String color) &#123; //也有构造方法 this.color = color; &#125; //抽象类有抽象方法，修饰符都是abstract abstract void sound(); //抽象方法可以protected、public、default修饰 protected abstract void nose(); public abstract void eyes(); public void leg() //抽象类也可以实现普通方法 &#123; System.out.println(&quot;短腿&quot;); &#125; /* abstract String skinColor() //抽象方法不能在抽象类实现 &#123; return color; &#125; final abstract void high(); //抽象方法要能够被子类继承和实现 private abstract void hair(); static abstract void weight(); */&#125; 因为抽象类很多方法并未实现，我们也不能new一个抽象类的对象。不能凭空产生一个方法。要想使用抽象类的方法，我们只能继承，如果子类也不能全实现抽象类的方法，那子类也必须是抽象类，直到能全实现方法的子类，我们新建对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class abstractTest &#123; public static void main(String[] args) &#123; Animal cat = new Cat(&quot;白色&quot;); System.out.println(cat.color); //打印 白色 cat.eyes(); //打印 蓝眼睛 cat.leg(); //打印 短腿 &#125;&#125;abstract class Animal //定义一个抽象类animal&#123; String color; //抽象类里可以有属性 public Animal(String color) &#123; //也有构造方法 this.color = color; &#125; //抽象类有抽象方法，修饰符都是abstract abstract void sound(); //抽象方法可以protected、public、default修饰 protected abstract void nose(); public abstract void eyes(); public void leg() //抽象类也可以实现普通方法 &#123; System.out.println(&quot;短腿&quot;); &#125;&#125;abstract class Felidae extends Animal //Felidae并没有实现Animal全部方法，只能定义为抽象类&#123; public Felidae(String color) &#123; super(color); &#125; void sound() &#123; System.out.println(&quot;喵喵喵~~~&quot;); &#125;&#125;class Cat extends Felidae //Cat实现全部方法&#123; public Cat(String color) &#123; super(color); &#125; protected void nose() &#123; System.out.println(&quot;鼻子&quot;); &#125; public void eyes() &#123; System.out.println(&quot;蓝眼睛&quot;); &#125;&#125; 接口接口和抽象类差不多，但是，比抽象类更规范。它不实现任何方法，它的一般只有常量和抽象方法。 123456789101112interface Car&#123; public static final int LENGTH = 280; //定义一个常量 /*public final static*/ int WIDTH = 120; public abstract void sound(); //抽象方法 /*public abstract*/ void weigth(); static void xx() //静态方法，好像不推荐使用 &#123; System.out.println(&quot;--------&quot;); &#125;&#125; 下面是例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &#123; public static void main(String[] args) &#123; Sedan c = new Sedan(); c.sound(); //打印 滴滴滴！！！ c.weigth(); //打印 it System.out.println(c.LENGTH); //打印 280 Car.xx(); //打印 -------- c.color(); //打印 白色 c.feel(); //打印 舒服 &#125; &#125;interface Car&#123; public static final int LENGTH = 280; //定义一个常量 /*public final static*/ int WIDTH = 120; public abstract void sound(); //抽象方法 /*public abstract*/ void weigth(); static void xx() //静态方法，好像不推荐使用 &#123; System.out.println(&quot;--------&quot;); &#125;&#125;interface InterF&#123; void feel();&#125;abstract class CarStyle&#123; abstract void color();&#125;class Sedan extends CarStyle implements Car,InterF //继承只能单继承，但接口可以多继承，接口实现用implements&#123; @Override //表明实现的方法，一般编译器在快捷键输入会自动帮忙生成 public void sound() &#123; System.out.println(&quot;滴滴滴！！！&quot;); &#125; @Override public void weigth() &#123; System.out.println(&quot;1t&quot;); &#125; public void feel()&#123; System.out.println(&quot;舒服&quot;); &#125; @Override void color()&#123; System.out.println(&quot;白色&quot;); &#125;&#125; 抽象类和接口的共同点:1、都有抽象方法。2、都需要被子类继承。 抽象类和接口的不同点:1、抽象类的变量只是普通变量，接口是常量。2、抽象类可以有具体的方法。3、接口相比抽象类讲，定义的是一种规范。4、接口可以多继承。 StringString是不可变的引用类型。使用的时候总会产生很多新的对象，所以就有了StringBuffer和StringBuilder两个类，它们都是继承于AbstractStringBuilder这个抽象类，而都现实了父类的方法，所以它们相当于双胞胎兄弟。 而双胞胎也有差别，它们的差别就是线程是否安全。 StringBuider下实现append()方法 1234@Overridepublic StringBuilder append(Object obj) &#123; return append(String.valueOf(obj));&#125; StringBuffer下实现append()方法 12345public synchronized StringBuffer append(Object obj) &#123; toStringCache = null; super.append(String.valueOf(obj)); return this;&#125; 看得出来，区别不是很大，只是在StringBuffer下，方法都多了一个synchronized修饰符，该修饰符保证线程安全。 线程安全解决啥呢。大致就是我们使用电脑时，不是一个只运行一个软件，而是很多个在同时运行，这时有多个软件修改了一个文件内容和多个软件同时获取该文件内容，在同一时间下，就可能出现错误。所以要保证线程安全，一个一个来，慢慢校验。所以线程安全提供了安全性，但效率会降低。 而StringBuider和StringBuffer方法都差不多一样，所以了解其中一个就行，以Stringbuider为例。 方法名 使用说明 append(Object) 实现多个字符串拼接，可以为任意类型 delete(int, int) 删除起始位置到终止位置(不包括终止位置)之间的元素 deletCharAt(int) 删除该下标的元素 replce(int, int, String 把起始位置到终止位置(不包括终止位置)之间的元素修改为新的字符串 insert(int, Object) 在该下标插入某个元素 123456789101112131415161718192021public static void main(String[] args) &#123; StringBuilder str = new StringBuilder(); str.append(&quot;a&quot;); //拼接任意元素，&quot;a&quot;,12,1.2到str str.append(12); str.append(1.2); System.out.println(str); //打印 a121.2 str.delete(3,5); //删除从3到5之间的元素[3,5) System.out.println(str); //打印 a122 str.deleteCharAt(0); // 删除下标为0的元素 System.out.println(str); //打印 122 str.replace(1, 2, &quot;java&quot;); //下标[1,2)变换为&quot;java&quot; System.out.println(str); //打印 1java2 str.insert(1, &quot;hello&quot;); //在下标为1处插入字符串&quot;hello&quot; System.out.println(str); //打印 1hellojava2 str.insert(0, true); //在下标为0处插入布尔值true System.out.println(str); //打印 true1hellojava2&#125; 这是都是StringBuider常用的方法，当然还有indexOf()、lastIndexOf()这样的字符匹配，length()长度，equals()比较内容等等，这些以前也用过的方法。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2019%2F09%2F11%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[十进制是我们常常使用的。但是，在计算机中，通用进制是2进制，所以本次写进制转换。在java基础（一）最后一段也用java的类快速转换，今天就简单的实现。 代码略长，简单讲一下，如果是整数，对2取余，最把每次得到的余数倒着写一遍。如果有小数，整数同上，但小数部分乘2，积满1写1并-1，不满写0继续乘。 注意：如果是负整数，我们要先算原码再求反码最后补码才是答案。而小数，要进过偏移，组合才是答案。 以下代码注意:浮点数可能和java类写的答案有误差…..不知道怎么解决…. :P 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355import java.util.Scanner; //如果要使用其他包的类或类库，一定要导入相应的包，否则运行时虚拟局不知道在哪/** //文档注释，说明类的使用，其方法、字段的说明等等 * 测试十进制的任意数字，转换成二进制、十六进制的方式 * @author KEKEXI * */public class BinaryConversion &#123; //类名：进制转换 public static void main(String[] args) &#123; System.out.print(&quot;请输入十进制的数:&quot;); Scanner sc = new Scanner(System.in); //定义一个输入的引用 sc String num = sc.next(); //输入一个浮点型sc.next()，并赋值给num ChangeNum cn = new ChangeNum(num); cn.getNumbers(); //把字符串转换成数字，分为整数部分和浮点数部分 System.out.print(&quot;输出转换成的二进制：&quot;); if(cn.judgeNum()) //判断num是整数呢，还是浮点数 &#123; Binary br = new Binary(cn.getIntPart()); //输出二进制和十六进制 br.pinrtNum(); System.out.println(&quot;JAVA类的整数二进制:&quot;+Integer.toBinaryString(Integer.parseInt(num))); //比较输出是否和java写的一样 System.out.print(&quot;\n输出转换成的十六进制：&quot;); Hexadecimal hc = new Hexadecimal(br.getA()); hc.printHX(); System.out.println(&quot;JAVA类的整数十六进制:&quot;+Integer.toHexString(Integer.parseInt(num))); &#125; else &#123; BinaryDouble bd = new BinaryDouble(cn.getIntPart(), cn.getDouPart()); bd.pinrtNum(); System.out.println(&quot;JAVA类的浮点型二进制:&quot;+Integer.toBinaryString(Float.floatToIntBits(Float.parseFloat(num)))); System.out.print(&quot;\n输出转换成的十六进制：&quot;); Hexadecimal hc = new Hexadecimal(bd.getA()); hc.printHX(); System.out.println(&quot;JAVA类的浮点型十六进制:&quot;+Integer.toHexString(Float.floatToIntBits(Float.parseFloat(num)))); &#125; &#125;&#125;//获取整型和浮点型class ChangeNum&#123; private String num; //private私有属性，提升代码安全性 private int intPart; private int douPart; public ChangeNum(String num) //构造方法，获取num &#123; this.num = num; &#125; public ChangeNum() &#123;&#125; //默认构造方法，在这不需要 public boolean judgeNum() //判断是否整数的方法 &#123; int k = 0; //定义k，找到&apos;.&apos;的位置，看看有没有&quot;假浮点数&quot;，如12.0000，有就化为整数型 boolean flag = false; //判断是否为&quot;假浮点数&quot; for(int i=0; i&lt;this.num.length(); i++) &#123; if(this.num.charAt(i) == &apos;.&apos;) &#123; k = i; flag = true; break; &#125; &#125; int sum = 0; //定义sum，计算小数点后相加的和是否为0，为0说明是假浮点数 if(flag) &#123; for(int i=k+1; i&lt;num.length(); i++) &#123; sum += num.charAt(i)-&apos;0&apos;; //字符的&apos;0&apos;是48，所以要减去&apos;0&apos;或48才是0 &#125; &#125; if(sum == 0) return true; return false; //为浮点型，返回false &#125; public void getNumbers() //浮点数分割，获取整数和浮点数部分 &#123; if(judgeNum()) &#123; this.intPart = (int)Double.parseDouble(num); //可能为&quot;假浮点数&quot;，先转为double，在转为int &#125; else &#123; String[] str = this.num.split(&quot;\\.&quot;); //字符串切割，.为特殊字符，要用\\表示才是普通. //只要整数部分和浮点数部分，字符就2个 this.intPart = Integer.parseInt(str[0]); //this,指当前类，给当前类的intPart变量赋值 this.douPart = Integer.parseInt(str[1]); &#125; &#125; public int getIntPart() //变量为私有，要设置和获取该变量，有set和get方法， &#123; //设置只能我设置，你只能获取，封装性 return intPart; &#125; public int getDouPart() &#123; return douPart; &#125;&#125;//整型class Binary&#123; private int[] a = new int[32]; //定义a数组，装二进制数，可以为32，也可以为64，都行 private int i = a.length-1; //i为0还是数组长度在输出上有关系 //为0要把数组逆输出，因为我们最先计算的数放到了前面 //比如2，先得a[0]=0, a[1]=1, 答案应该为10，逆输出 //而i=数组长度，a[1]=1,a[0]=0,顺输出 private int intPart; //整数部分就算一个整数，定义该变量就行 Binary(int intPart) &#123; this.intPart = intPart; intNum(this.intPart, a); &#125; public Binary() &#123;&#125; //因为有继承关系，要创建默认构造方法 public void intNum(int intPart, int[] a/*, int i*/) //计算二进制的值 &#123; if(intPart &lt; 0) //如果整数是负的，变为正，一切都以正数处理 &#123; intPart = -intPart; a[0] = 1; //符号位变为1，1为负数，0为正数 &#125; while(intPart != 0) &#123; a[i--] = intPart%2; //变为啥，就取啥余，其他进制类同，所以很简单 //位移符，&gt;&gt;右移为除，&lt;&lt;左移为乘 // &gt;&gt;1右移一位为除以2的一次方(2^1) intPart &gt;&gt;= 1; // &gt;&gt;2右移两位为除以2的2次方(2^2) &#125; &#125; public void complementCode(int[] a) //求补码，正数原码 = 反码 = 补码，所以不用求 &#123; if(a[0] == 1) //先判断符号位 &#123; for(int i=1; i&lt;a.length; i++) //先求反码，除符号位，1变0，0变1 &#123; //if(a[i] == 1) a[i] = 0; //else a[i] = 1; //a[i] = a[i]==0 ? 1:0; a[i] = (a[i]+1)%2; &#125; a[a.length-1] += 1; //补码 = 反码+1 for(int i=a.length-1; i&gt;0; i--) //如果有进位，进位变0，前一位加1 &#123; if(a[i] == 2) &#123; a[i] = 0; a[i-1] += 1; &#125; &#125; &#125; &#125; public void pinrtNum() &#123; complementCode(a); //调用补码方法 for(int j=0; j&lt;a.length; j++) //打印输出，没4位空一格，好看 &#123; if(j%4 == 0 &amp;&amp; j != 0) System.out.print(&apos; &apos;); System.out.print(a[j]); &#125; System.out.println(); &#125; public int[] getA() &#123; return a; &#125;&#125;//浮点型class BinaryDouble extends Binary //继承父类&#123; private int[] a = new int[32]; //由于父类私有，在重新定义，也可以把父类的修饰符改改 private int i = 0; private int intPart; private int douPart; public BinaryDouble()&#123;&#125; public BinaryDouble(int intPart,int douPart) &#123; this.intPart = intPart; this.douPart = douPart; DouNum(intPart, douPart); &#125; public void DouNum(int intPart, int douPart) &#123; if(intPart &lt; 0) //判断是否为负数 &#123; a[0] = 1; //获取符号位 intPart = -intPart; &#125; //求整数部分 int[] numInt = new int[a.length-1]; //a[0]为符号位，所以结果只能比数组a少1 int intI = numInt.length-1; //还是倒着求二进制 int intPartT = intPart; //intPart要用两次，所以这里临时变量求解 while(intPartT != 0) //本来要用父类的intNum()方法，但无奈，不可以址传递，intI的值还是31 &#123; numInt[intI] = intPartT%2; intI--; intPartT &gt;&gt;= 1; &#125; int e = 127+numInt.length-intI-2; //length-1-intI-1求移动小数位，在加127的偏移位 int[] E = new int[a.length-1]; int intE = E.length-1; //也是倒着求二进制 while(e != 0) &#123; E[intE] = e%2; intE--; e &gt;&gt;= 1; &#125; for(int j=intE+1; j&lt;E.length; j++) //一开始赋了符号位，现在先赋E &#123; a[++i] = E[j]; &#125; for(int j = intI+2; j&lt;numInt.length; j++) //在赋整数部分 &#123; a[++i] = numInt[j]; &#125; int[] numDou = new int[a.length-1]; //求浮点型部分 int intD = 0; //浮点部分不用倒过来，直接从0开始计算二进制每一位 int t = douPart; int z = 1; //因为是变为整数，相当于算1.0 while(t != 0) &#123; t /= 10; z *= 10; &#125; while(douPart!=0 &amp;&amp; intD&lt;numDou.length) //浮点计算，每次*2，大于&quot;1.0&quot;，numDou[intD] = 1 &#123; douPart &lt;&lt;= 1; numDou[intD++] = douPart&gt;=z ? douPart/z : 0; if(douPart&gt;=z)douPart -= z; &#125; for(int j = 0; j&lt;intD &amp;&amp; i&lt;31; j++) &#123; a[++i] = numDou[j]; &#125; &#125; public void pinrtNum() //重新父类，因为我们不需要算补码 &#123; for(int j=0; j&lt;a.length; j++) &#123; if(j%4 == 0 &amp;&amp; j != 0) System.out.print(&apos; &apos;); System.out.print(a[j]); &#125; System.out.println(); &#125; public int[] getA() &#123; return a; &#125;&#125;class Hexadecimal&#123; private int[] a = new int [32]; private int[] ans = new int[8]; public Hexadecimal(int[] a) &#123; this.a = a; &#125; public void aglormHX() //求16进制 &#123; int k = 0; int j = 3; //每4位为一组，[0,3]四位,把j=3改为2，就是求八进制 for(int i=0; i&lt;a.length; i++) &#123; ans[k] += a[i]&lt;&lt;j; //因为数组a得到的答案为顺序，第一位为2^3,第二位为2^2...2……0 if(j==0) //求完每组，进行下一组 &#123; k++; j = 3; &#125; else j--; &#125; &#125; public void printHX() &#123; aglormHX(); for(int i=0; i&lt;ans.length; i++) &#123; switch(ans[i]) //特殊处理[10,15]的数 &#123; case 10: System.out.print(&apos;A&apos;); break; case 11: System.out.print(&apos;B&apos;); break; case 12: System.out.print(&apos;C&apos;); break; case 13: System.out.print(&apos;D&apos;); break; case 14: System.out.print(&apos;E&apos;); break; case 15: System.out.print(&apos;F&apos;); break; default : System.out.print(ans[i]); break; &#125; &#125; System.out.println(&quot;H&quot;); //&quot;H&quot;表明它是十六进制 &#125;&#125;]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>番外</tag>
        <tag>程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（五）]]></title>
    <url>%2F2019%2F09%2F06%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这次主要记录的是基本数据类型的封装和String的基本使用。 基本数据类型的封装在java中，八种数据类型也可以封装成对象。所以java相较于C++，面向对象更彻底，而相对于只有面向对象的语言，又有容易操作的面向过程的处理。 基本数据类型 封装数据类型 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 而封装的数据类型，保证了数据的安全性，也为我们提供一些方法，比如把字符串转换成整数，小数之类的，重写的equals()方法来比较是否相等。 基本使用123456public static void main(String[] args) &#123; Integer in = new Integer(10); System.out.println(in); //打印 10 &#125; 既然是封装，那也就是对象，需要实例化，看样子和平时int a = 10；没啥区别。 12345678public static void main(String[] args) &#123; Integer in = new Integer(10); Integer in2 = new Integer(10); System.out.println(in == in2); //打印 false System.out.println(in.equals(in2)); //打印 true&#125; 还是 == 的注意，只比较基本变量的值是否相等和对象是否相等，对象相等的条件是引用的地址是否同一个。所以这里不出意外， false。而equals()方法在Object也是比较值或地址是否相等，当在这重写了equals()方法，看下面的代码。 123456public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 下面则是把字符串变为整型各种方法，虽然最后值都是一样。但，运算不一样，parseInt()把它默认当做十进制的1000表示。 12345678910111213141516public static void main(String[] args) &#123; String str = &quot;1000&quot;; int in = Integer.parseInt(str); int in2 = new Integer(str).intValue(); int in3 = new Integer(str); int in4 = Integer.valueOf(str).intValue(); int in5 = Integer.valueOf(str); Integer in6 = Integer.parseInt(str,2); //这里打印的是8，1000在2进制就是8&#125; 但是，如果出现其他字符字母，则运行会报错，下面的代码，我们都知道是11.1，整数为11，但编译器不会把小数点后面的去掉。当然，里面只填11.1，编译器也会直接报错。你可以改为Double类使用浮点数。 123456public static void main(String[] args) &#123; Integer in = new Integer(&quot;11.1&quot;); System.out.println(in);&#125; 装箱与拆箱12345678public static void main(String[] args) &#123; Integer in = 1; //装箱，在虚拟机实际运行的是Integer in = new Integer(1); int in2 = new Integer(1); //拆箱，实际运行的是int in2 = 1； //箱，听起来的感觉就是包装成对象，封装成一个对象，拆解为普通的变量&#125; 装箱与拆箱也改变了一点变化。我们来看看。 1234567891011public static void main(String[] args) &#123; Integer in = 10; Integer in2 = 10; Integer in3 = 130; Integer in4 = 130; System.out.println(in == in2); System.out.println(in3 == in4);&#125; 这两个答案是什么呢？因为是对象，你可以回答都是false。但是，我们先看看它的源代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage. The size of the cache * may be controlled by the &#123;@code -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 1234567891011121314151617181920/** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 12345678910/** * Constructs a newly allocated &#123;@code Integer&#125; object that * represents the specified &#123;@code int&#125; value. * * @param value the value to be represented by the * &#123;@code Integer&#125; object. */public Integer(int value) &#123; this.value = value;&#125; 虽然看着还挺长的，但很多都是注释，注释都是帮助理解的。先看中间的这段代码，看得出来，如果这个数在默认的[low(-128),high(127)]范围外，是直接返回一个数组的值，而这个数组是怎么来的呢？看第一段里从第32行做分水岭，上面操作都在确定数组的范围，下面给cache赋值范围并新建Interger对象赋值。否则在[low,high]范围内呢，返回一个value，而这个value就是它本身。 所以，在装箱中，如果范围在[-128,127]之间，得到的是一个值，不在范围内才是对象。 既然你可以自动装箱和拆箱，那么下面的写法也就是ok的。 12345678910111213public static void main(String[] args) &#123; Integer in = Integer.valueOf(&quot;1000&quot;); int in2 = Integer.valueOf(&quot;1000&quot;); Integer in3 = Integer.valueOf(1000); System.out.println(&quot;in==in2：&quot;+(in==in2)); System.out.println(&quot;in==in3：&quot;+(in==in3)); System.out.println(&quot;in.equals(in3):&quot;+in.equals(in3)); &#125; 写东西总是会发现有意思的事，对象和值用 == 是什么比较？没想到是值，以前都没发现，都是对象.equals(对象)，值==值。 1234567891011121314151617public class test01 &#123; public static void main(String[] args) &#123; System.out.println( 5 == (new a().t=5) ); a a = new a(); a.t = 10; System.out.println(10 == a.t); &#125;&#125;class a&#123; int t;&#125; 打印的两个都是true。 以上是关于Int型的封装Integer的使用，八种基本数据类型，封装都差不多，但也还是有不同，可以试试其他，比如integer的加法比较，Double的大小比较，Boolean的返回的true和false是不是对象等等。 String八种基本数据类型之外的都是引用数据类型，比如数组，String，类，接口。而引用数据类型也就意味着它是对象。 123public static void main(String[] args) &#123; String str = &quot;Hello,World&quot;;&#125; 看，String是类，却没有new，很多人初学可能都以为它是特殊的基本数据类型。但它是类，所以它也可以new。 123456public static void main(String[] args) &#123; String str = &quot;Hello,World&quot;; String str2 = new String(&quot;Hello,World&quot;); System.out.println(str == str2); System.out.println(str2.equals(str));&#125; 那第一个打印啥，是false，为啥？在内存中，常量是一开始加载到方法区的常量池，比如我们定义的Final，或字符串都在常量池，而str2是先在常量池找有没有该常量，有的话直接在堆新建一个对象，没有的话，会在常量池存入该常量，接着在堆里新建对象。一个指向常量池，一个指向堆，所以打印false。 12345public static void main(String[] args) &#123; String str = &quot;Hello,World&quot;; String str2 = &quot;Hello,World&quot;; System.out.println(str == str2);&#125; 这个代码也能说明问题，当我给str赋值时，会去常量池找”Hello,World”这个常量，str2赋值，也会先去常量池找，同时指向同一个地址，那么它们的对象、值也就相等。 String也被称为不可变的字符串，在java中定义如下。 1public final class String 可是，我们在使用中，往往可以加字符串，但是会产生多个对象 1234567891011121314public static void main(String[] args) &#123; //System.identityHashCode(Object) 打印在内存中的地址 String str; //一开始str为null，没有对象，也就没有哈希地址 str = &quot;Hello,World&quot;; //把常量池的&quot;Hello,World&quot;的地址给了str System.out.println(System.identityHashCode(&quot;Hello,World&quot;)); //2018699554 System.out.println(System.identityHashCode(str)); //两个地址在我的电脑上都是上面这一串 str += &quot;! java&quot;; //接着给str又赋值 System.out.println(System.identityHashCode(str)); //1311053135 这是新的str的地址 System.out.println(System.identityHashCode(&quot;! java&quot;)); //118352462 这是该字符串的地址&#125; 这里新建了一次str对象。而对象呢，也就创建了一个，因为”Hello,World”和”! java”一开始就加载到了常量池，使用的时候直接指向在常量池的对象就行。 123456789101112131415161718192021public static void main(String[] args) &#123; //System.identityHashCode(Object) 打印在内存中的地址 String str = new String(&quot;Hello&quot;); System.out.println(System.identityHashCode(str)); //2018699554 System.out.println(System.identityHashCode(&quot;Hello&quot;)); //1311053135 String str2 = new String(&quot;Hello&quot;); System.out.println(System.identityHashCode(str2)); //118352462 System.out.println(System.identityHashCode(&quot;Hello&quot;)); //1311053135 String str3 = &quot;He&quot; + &quot;llo&quot;; System.out.println(System.identityHashCode(str3)); //1311053135 System.out.println(System.identityHashCode(&quot;He&quot;)); //1550089733 System.out.println(System.identityHashCode(&quot;llo&quot;)); //865113938 String str = str+str; System.out.println(System.identityHashCode(str)); //1442407170 System.out.println(System.identityHashCode(&quot;HelloHello&quot;)); //1028566121&#125; 每次地址都不一样，也就说明对象也不一样，一开始str新建String对象，而常量池没有”Hello”，于是先在常量池新建”Hello”对象，接着给str新建对象，所以第5行代码新建了两个对象，我们也看到str和”Hello”地址不一样。而str2也新建”Hello”对象，但是常量池有”Hello”的对象，所以直接在堆里新建一个对象，所以这里只新建str2对象。看得出”Hello”地址没变。 而str3是把”He”和”llo”合在一起，构成一个字符串，去常量池找，所以直接指向常量池的对象地址。没有创建对象。 最后str把str+str，因为字符串不可变，而常量池没有”HelloHello”，所以先在常量池创建新对象”HelloHello”，str也更改对象，获取“helloHello”。创建了两个对象。 所以上面的代码最少创建5个对象， 123456public static void main(String[] args) &#123; String str = String.valueOf(1.21); System.out.println(str); &#125; String自然也可以用装箱和拆箱使用一些方法。 String常用方法 方法 解释 isEmpty() 是否为空，如果空返回true，否则返回flag charAt(int) 返回字符串下标为int的值 length() 返回字符串的长度，从0开始计算，但字符串末尾默认以\0结束 indexOf(String||char) 返回字符或子字符串的最开的出现的下标 lastIndexOf(String||char) 返回最后字符或子字符串的出现的下标 startsWith(String) 是否以当前字符串开头 endsWith(String) 是否以当前字符串结尾 replace(String||char，String||char) 替换字符 toUpperCase() 字符串全变为大写字母 toLowerCase() 字符串全变为小写字母 split(String) 切割字符串 toCharArray() 变为字符数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 public static void main(String[] args) &#123; String str = &quot;&quot;; System.out.println(&quot;str是否为空：&quot; + str.isEmpty()); //str是否为空：true str = &quot;Hello,World&quot;; System.out.println(&quot;str赋值后是否为空：&quot; + str.isEmpty()); //str赋值后是否为空：false System.out.println(&quot;str的下标第四个的值：&quot;+ str.charAt(4)); //str的下标第四个的值：o System.out.println(&quot;str的长度为多少：&quot; + str.length()); //str的长度为多少：11 System.out.println(&quot;返回l最开始出现的的下标：&quot; + str.indexOf(&apos;l&apos;)); //返回l最开始出现的的下标：2 System.out.println(&quot;返回从下标4开始，l最开始出现的下标：&quot; + str.indexOf(&apos;l&apos;,4)); //返回从下标4开始，l最开始出现的下标：9 System.out.println(&quot;返回l最后出现的下标&quot; + str.lastIndexOf(&apos;l&apos;)); //返回l最后出现的下标9 System.out.println(&quot;str是否以hello开头：&quot; + str.startsWith(&quot;Hello&quot;)); //str是否以hello开头：true System.out.println(&quot;str是否以hello结尾：&quot; + str.endsWith(&quot;Hello&quot;)); //str是否以hello结尾：false System.out.println(&quot;把str里的,变为空格&quot; + str.replace(&quot;,&quot;, &quot; &quot;)); //把str里的,变为空格Hello World System.out.println(&quot;str全部转换成大写字母&quot; + str.toUpperCase()); //str全部转换成大写字母HELLO,WORLD System.out.println(&quot;str全部转换成小写字母&quot; + str.toLowerCase()); //str全部转换成小写字母hello,world //以&quot;,&quot;把字符串分割 String[] str2 = str.split(&quot;,&quot;); for(String s:str2)System.out.println(s); /* * Hello * World */ //转换成字符数组 char[] str3 = str.toCharArray(); for(char s:str3) System.out.println(s);/* * H * e * l * l * o * , * W * o * r * l * d */ &#125; 当然，String方法还有重写的equals()、hashCode()等等方法….]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（四）]]></title>
    <url>%2F2019%2F09%2F04%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类和对象前面记录的都是java面向过程的记录，而现在起，则是面向对象的开始。也正是java的魅力所在。 类是对象的抽象化，对象是类的实例化。怎么说呢，类，定义某个事物的特征，比如球，有半径，有材质，有厚度，有弹性。而对象呢，根据具体事物来说明，半径2cm，材质塑料，厚度1mm，弹性一般，这可能就是乒乓球，而其他球也可以根据类的定义来实例化（对象化）。所以才有万物皆对象，我们可以抽象任何事物的特征，根据不同的特征组合来表述现有的事物。 定义一个类从我们学习java开始，就已经接触类。 12345public class HelloWorld &#123; //一个类只要唯一一个公共类 public static void main(String[] args) &#123; //main方法 System.out.println(&quot;Hello, World&quot;); //输出Hello，World &#125;&#125; 怎么用对象呢，都说new一个女朋友，我们把程序改改 12345678910public class HelloWorld &#123; public static void main(String[] args) &#123; HelloWorld hi = new HelloWorld(); //new一个HelloWorld类 hi.printHello(); //使用HelloWorld()类中的非静态方法printHello() &#125; void printHello() //声明一个输出Hello，World的方法 &#123; System.out.println(&quot;Hello,World&quot;); &#125;&#125; 我们分析为这两个的区别。当然首先我们应该也知道，我们写.java的代码，编译器编译为.class的字节码，最后在虚拟机(JVM)运行。这是java之所以流行的原因，跨平台。一次编译，处处运行。 我们的代码都在内存上运行，所以要涉及栈，堆，方法区。栈的特点，连续空间，先进后出，就想乒乓球桶一样，最后放进来的一定最先出来。堆在内存中是随机，无序存放的，不要与数据结构的堆混淆。方法区存放代码块的地方，类，静态的，常量，方法名等等，而方法区是在堆里的。 第一个代码，我们的代码名为HelloWorld，编译器会先找到HelloWorld的类，把该类的相关代码放进方法区，并在栈中开辟一个空间。接着编译器找到main方法，程序运行的入口。一步步运行，只有一个输出，打印，程序运行结束，关闭栈，关闭该程序其它占用的内存（堆）。 第二个代码，前面都一样，从main开始，遇到hi的变量名，放入栈中，hi = null; 然后new一个HelloWordl类的引用，既然new，则又在栈中开辟第二个空间，存放helloWordl类的引用地址，并new的类的引用放到了堆里，里面有printHello方法，使用hi.printHello方法后，关闭第二个栈和该类占用的内存，接着程序结束，关闭第一个栈，关闭该程序其他占用的内存。 构造方法我们在new HelloWorld()方法时，其实调用了HelloWorld的默认构造方法。构造方法也可以重写，下面的例子。 123456789101112131415161718192021public class HelloWorld &#123; private String hi; public HelloWorld()&#123;&#125; //默认构造方法 public HelloWorld(String _hi) &#123; hi = _hi; &#125; public static void main(String[] args) &#123; //HelloWorld hello = new HelloWorld(); HelloWorld hello = new HelloWorld(&quot;你好，世界&quot;); HelloWorld hello2 = new HelloWorld(); hello.printHello(); hello2.printHello(); &#125; void printHello() &#123; System.out.println(&quot;Hello,World！&quot;+hi); &#125;&#125; 构造方法的注意：1、构造方法没有返回类型、返回值。2、如果没有重写（重载：除了方法名和内容其它都可以改变；重写：除了方法名和返回类型其它都可以改变），只会调用默认构造方法。3、重写构造方法，默认构造方法也就没有了，编译器觉得你都自己写了，那我给你的，你也没必要用了。所以还想要默认构造方法，自己写一个。 其它注意：在以前写代码，没有赋值的变量如果被使用，编译器会报错，但在这hello2中，我new的默认构造方法，hi变量没赋值，所以输出String的默认值”null”。简单说明下，在方法内的变量称为局部变量，只归该方法使用，默认没有初始化。而在方法外，类内的的变量称为成员变量(全局变量),能在该类任意一个位置使用，自带初始化，String引用类型，默认值null。 关键字thisthis指向当前类，可以用当前类的变量或构造方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package io.github.java04;public class graphArea &#123; private int a; //长 private int b; //宽 private int c; //高 private int area; //面积 //默认构造方法 graphArea()&#123;&#125; //正方形的面积 public graphArea(int a) &#123; this.a = a; //this.a，当前类的变量， a该方法的变量 &#125; //矩形的面积 public graphArea(int a, int b) &#123; this.a = a; this.b = b; &#125; //长方体的面积 public graphArea(int a, int b, int c) &#123; this(a,b); //this()调用相应的构造方法 this.c = c; &#125; //获取面积 public int getArea() &#123; if(b==0&amp;&amp;c==0) area = a*a; //方法没有局部变量，调用的成员变量 else if(c==0) area = a*b; else area = (a*b+a*c+b*c)*2; return area; &#125; public static void main(String[] args) &#123; //正方形 graphArea cube = new graphArea(3); System.out.println(&quot;正方形的面积：&quot; + cube.getArea()); //矩形 graphArea rect = new graphArea(2, 3); System.out.println(&quot;矩形的面积：&quot; + rect.getArea()); //长方体 graphArea cuboid = new graphArea(2, 3, 4); System.out.println(&quot;长方体的面积：&quot; + cuboid.getArea()); &#125;&#125; 注意：this. ，注意’.’，指代调用当前类的变量。this()调用本类的其他构造方法时，只能放在构造方法的第一行。与this()对应的还有super()指代父类，下面会有记录。 关键字static和final静态的，第三章也简单带过，这里在带过一下 12345678910111213141516171819202122232425262728public class HelloWorld &#123; public static int a = 5; public final static int b = 10; int c = 15; public static void main(String[] args) &#123; HelloWorld h1 = new HelloWorld(); HelloWorld h2 = new HelloWorld(); System.out.println(h1.a); //输出h1.a的值 a = 16; System.out.println(h1.a); //a的值改变了，输出h1.a的值 h1.a = 10; //h1.a的值改变了，输出h2.a的值 System.out.println(h2.a); //b = 15; 常量不可修改 //System.out.println(c); //编译器报错 printHello(); &#125; public static void printHello() &#123; System.out.println(&quot;Hello,World！&quot;); &#125;&#125; static：静态的，一开始加载到方法区，可以在方法中直接使用，如第21行直接调用printHello()方法，没有用类去调用。第12行把a变为16，对应的第19行输出非静态变量c编译器直接报错。既然static是在方法区，如果静态的值改变，那么其它引用的类的a值也改变，参考代码。 final:会用就行，常量，一开始也加载到方法区，当final修饰，所以不可修改，修饰方法也就没有继承，比如Math类，String类等等。 方法区123456789101112131415161718192021222324252627public class HelloWorld &#123; static &#123; System.out.println(&quot;你好，static方法块&quot;); &#125; &#123; System.out.println(&quot;你好，普通方法块&quot;); &#125; public void sayHi() &#123; System.out.println(&quot;sayHi方法&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;main方法执行&quot;); HelloWorld p = new HelloWorld(); System.out.println(&quot;------------&quot;); p.sayHi(); System.out.println(&quot;------------&quot;); new HelloWorld().sayHi(); &#125;&#125; 12345678你好，static方法块main方法执行你好，普通方法块------------sayHi方法------------你好，普通方法块sayHi方法 我们慢慢分析，静态、常量、方法名、类一开始加载到方法区，所以最新输出static方法块，之后开始执行main方法，p引用HelloWorld对象，开辟新的栈，堆加载一个HelloWorld对象，由于static已经加载，所以不在执行static方法块，输出普通的方法块，接着画出横线，使用sayHi()方法.又画出横线，又新建一个对象，开辟新的栈，加载新对象，使用普通方法块，程序结束，关闭所有占用的内存。 面向对象以上是类的简单示例，和对象的基本认识。现在开始就是面向对象的三大特性：封装，继承，多态。 封装在求面积那，就简单封装了一下，用构造方法设置边长，面积只能getArea()获取，我们可以在这些设置或获取的方法中做相应的限制。比如输出一个年龄，如果没有封装，可以随意输入，-1，-10，1000000，可现实中，生物中生命不可能为负数，也不可能活的非常非常的长，可以设置if年龄在0到150之间为正确输入，如果超过，提示用户错误信息。 123456789101112131415161718192021222324252627282930313233public class years &#123; public static void main(String[] args) &#123; System.out.println(&quot;输入年龄，范围在0&lt;year&lt;=150之间：&quot;); _year y = new _year(); y.setYear(151); y.ye = 151; System.out.println(&quot;year:&quot; + y.getYear()); System.out.println(&quot;ye:&quot; + y.ye); &#125;&#125;class _year&#123; private int year; int ye; public int getYear() &#123; if(year == 0) &#123; System.out.println(&quot;年龄错误&quot;); return 0; &#125; return year; &#125; public void setYear(int year) &#123; if(year&gt;0 &amp;&amp; year &lt;=150) this.year = year; &#125;&#125; 封装基本就这样，就像我们现在看电视手机，用户不需要知道内部是怎么样的，怎么运行的，我们也不可以把内部代码放出来给用户修改。只需要给用户一个遥控器，一个触摸屏，保持一个合理的使用方法即可。也像我们的身体，内部怎样工作不清楚，我们只要观四方听八面走万里就行。 继承子类继承父类，为啥，简单一句，提高开发效率，避免代码冗余。但在java中，继承只能单继承，并且所有类都默认继承Object，只有接口才能多继承。 1234567891011121314151617181920212223242526272829303132333435public class AnimalTest &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.age = 10; //a.weight 不可用，private只能在自己的类使用 //a.height 父类不可以用子类的任何属性 a.jiao(); //打印 动物叫了 dog d = new dog(); d.age = 15; d.height = 100; //d.weight 子类不可以用父类的私有属性 d.jiao(); //打印 汪汪汪 &#125;&#125;class Animal extends Object //默认继承Object类，可以不写&#123; int age; private int weight = 100; public void jiao() &#123; System.out.println(&quot;动物叫了&quot;); &#125;&#125;class dog extends Animal&#123; int height; public void jiao() &#123; System.out.println(&quot;汪汪汪&quot;); &#125;&#125; 父类Animal，子类dog，父类的自己的任何属性可以自己调用，但父类不可以调用子类的属性，就像人一样，我们的身体是从父母得来的，而父母的身体自然也不可能是从子女来。子类可以用父类除了私有的任何属性，也可以用自己的属性，也可以定义和父类一样的变量，也可以重写父类的方法。这就是继承。 关键字supersuper()调用的是父类的构造方法，在子类中使用，也是放到构造方法的第一行。所以，this()和super()只能调用任意一个。 12345678910111213141516171819202122232425262728293031323334public class superTest &#123; public static void main(String[] args) &#123; cat c = new cat(); System.out.println(&quot;---------------&quot;); c.eat(); &#125;&#125;class animal&#123; animal() &#123; System.out.println(&quot;我是动物&quot;); &#125; public void eat() &#123; System.out.println(&quot;动物在吃东西&quot;); &#125;&#125;class cat extends animal&#123; cat() &#123; //super(); //默认自动调用，并在方法的第一行 System.out.println(&quot;我是猫&quot;); &#125; public void eat() &#123; super.eat(); System.out.println(&quot;猫在吃猫粮&quot;); &#125;&#125; 上面只是new cat类，程序运行时，默认调用cat的默认构造方法，在cat的构造方法里默认调用了super()，也就是父类的默认构造方法，无论有没有super()，都调用父类的默认构造方法，而父类又向上调用super()，直到Object类的默认构造方法，最后一层层返回，返回到animal的默认构造方法的内容，运行结束又返回到cat的默认方法的内容，最后结束运行。整体就是递归调用的思想。 而横线下面，调用了eat()，在子类中，super.eat()调用了父类的方法。 当然如果父类没有默认的构造方法，但又想用父类的构造方法，就可以用super(参数名)的形式。 多态同种物，不同的形态，就像陆地哺乳动物，眼鼻耳口肢体，外形都可以类似，但各自习惯，能力，体型等不同而产生的各种形态。 1234567891011121314151617181920212223242526272829303132public class AnimalTest &#123; public static void main(String[] args) &#123; Animal a = new dog(); //向上转型，把dog类变为Animal类 a.jiao(); //打印 汪汪汪 //重写了父类的jiao()方法，所以打印了子类的jiao()方法 //a.height 错误，虽然new的是dog()，但父类没有， System.out.println(a.age); //打印的也只是父类的15，并不是子类的10 dog d = (dog)a; //向下转型，a是Animal类，转化为dog类 System.out.println(d.age); //转型后，age的值才是子类的10 &#125;&#125;class Animal&#123; int age = 15; private int weight = 100; public void jiao() &#123; System.out.println(&quot;动物叫了&quot;); &#125;&#125;class dog extends Animal&#123; int height; public void jiao() &#123; System.out.println(&quot;汪汪汪&quot;); &#125;&#125; 把代码改改，用父类的引用指向了子类，简单意义就是多态，有父类的共同特点，也只可以用父类的属性。但是，子类自己定义的属性不能使用，子类与父类一样的变量名，也只使用父类的。这就是动态绑定，如果子类重写父类的方法，则用子类的，没有向父类找，直到找到最后一次重写的方法，如果找到了Object类也没有找到，则编译器自动报错。 toString()toString()是Object类的方法，下面是它默认的方法，我的jdk是1.8，所以可能与其它版本有差异，但大致都差不多。 123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; 可以看的出来，返回了类的名称+@+类的哈希地址下面是示例。 123456789101112package io.github.java04;public class toStringTest &#123; public static void main(String[] args) &#123; car c = new car(); System.out.println(c.toString()); &#125;&#125;class car&#123;&#125; 12//这是得到的答案io.github.java04.car@7852e922 我们一般会重写toString()方法，返回我们想得到的信息，比如类名，结果，而不是一串看不懂的哈希值。 equals()equals()在后面String学习，我们都是通过equals()来判断String的内容是否相等，而不用 == ，因为在java中， == 是判断两个对象是否一样，或基本数据类型才比较值。而不是对象的内容。但是在String中是重写了该方法。下面是Object类的equals()。 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 看的出来，返回的是对象是否相等，并没有比较值，所以我们在用equals()，想比较值是否相等，一定要重写该方法。下面是错误示例。 123456789101112131415161718192021222324public class equalsTest &#123; public static void main(String[] args) &#123; circular c1 = new circular(1); circular c2 = new circular(1); System.out.println(c1.equals(c2)); //打印 false &#125;&#125;class circular&#123; private int radius; public circular(int radius) &#123; this.radius = radius; &#125; public int getRadius() &#123; return radius; &#125;&#125; 下面是重写后的equals()方法。 12345678910111213141516171819202122232425262728293031323334public class equalsTest &#123; public static void main(String[] args) &#123; circular c1 = new circular(1); circular c2 = new circular(1); System.out.println(c1.equals(c2)); //打印 true &#125;&#125;class circular&#123; private int radius; public circular(int radius) &#123; this.radius = radius; &#125; public int getRadius() &#123; return radius; &#125; @Override public boolean equals(Object obj) &#123; if(obj instanceof circular) //instanceof，如果左边的对象是输入右边的类，则返回true &#123; return radius == ((circular)obj).radius; &#125; return this == obj; &#125;&#125; 好久没更了，但一直在想办法进步，努力，提升自己，大家一起加油吧！！！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[太极·magisk]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%A4%AA%E6%9E%81%C2%B7magisk%2F</url>
    <content type="text"><![CDATA[太极·magisk，也被成为太极·面具或太极·阳，是一种不修改系统文件的框架，比以前的xposed框架好一些的框架。当然，这是我的理解….. “无极而太极，太极动而生阳，动极而静，静而生阴，静极复动，一动一静，互为其根，分阴分阳，两仪立焉。” –《太极图说》 为什么要装框架，很多不搞机的用户会问，我也只是菜鸟，我只能以我的眼光说，为了美化自己的手机，使自己的手机变的独特。比如装去广告的插件，管理后台插件，手势插件，状态栏沉浸式等。当然，很多插件现在的系统都有内置，这也使得刷机也变得越来越少。 而我之所以刷机，是为了装应用变量，骗联通的5G体验包，有100G呀，可惜晚了两天，一不做二不休，为了以防万一以后用到，干脆刷了算了。而我们搞机用户也常说，我可以不用，但你不可以没有。 太极·阴首先介绍太极·阴，是不用刷机直接安装的软件，但要先下载软件，可以去关注虚拟框架公众号回复“最新版”下载太极。 想使用的模块(插件)也可以在这公众号下载安装。然后在软件点击那个像放大的按钮，再点击模块管理，勾选你要使用的框架。 但使用某些模块，需要把相应的软件也放到太极里。这里就体现出太极·阴的不好处，你需要把原始应用卸载，然后在太极·阴里安装。每一次软件更新，就要重新安装一遍，由于数据是保存在太极里，所以可能会丢失数据，好像也不可以应用双开。但是别忘了，太极·阴是不用BL解锁和root的，直接安装的软件，适用于现在大部分的手机。 太极·阳因为现在厂商对系统的限制，大部分都有BL锁，才能root。而能够轻松的BL解锁好像只要小米和一加手机吧。我的手机是小米，所以只能以小米为例。 小米BL解锁网址：http://www.miui.com/unlock/index.html 接下来就是刷第三方rec，可以在百度搜索 “某某手机 rec”，例如：小米8 rec 当然小米手机可以在MIUI论坛的http://www.miui.com/space-uid-362247641.html 的帖子找，来刷rec 现在来安装magisk，你可以百度magisk，去它的官网下载，https://forum.xda-developers.com/apps/magisk 第一个帖子就是magisk安装包，现在的版本是2019.6.4，19.3 点进去找到Downloads(下载)，我们只需要下载Latest Stable(最新稳定版)和Magisk Manager。 由于官网打开比较慢，所以，可以去其他网址下载或去酷安下载Magisk Helper(面具助手)。一定要下载Magisk和Magisk Manager。 然后安装Magisk Manager，关机进入rec，然后找到Magisk位置，刷入Magisk。 先刷rec还是先装Magisk Manager看各人喜好，但刷Magisk一定在刷rec之后。 打开软件大致就是这样，点开左上角的按钮，里面一定要有下载的按钮。如果没有那就说明刷的有误….重新再来刷Magisk吧。 接着去下载里面下载”Tai Chi”，以上做那么多步，就是为了这个插件。如果下载里不能下载，可以去虚拟框架回复”面具”下载，然后在magisk或rec下安装这个插件。 然后再点开太极，就会发现面具变为太极·阳，可以直接添加软件到这里面。不用怕更新安装麻烦和导致数据丢失。 在安装了magisk之后，现在你打开设备解锁状态和ROOT权限。咦！竟然又锁上了，其实它们只是表面上锁了，你也不用担心不能用magisk或给应用权限。 PS:因为刷入第三方rec，所以更新系统只能线刷或者在MIUI官方下载完整包在rec里更新，magisk(面具)也可能会掉。。。只能重新刷，所以，请小心使用，不要删除Magisk。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>太极</tag>
        <tag>magisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（三）]]></title>
    <url>%2F2019%2F08%2F06%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本次记录的是方法，在其他语言也被称为函数。 我们写java代码中，main也是方法。public static void main(String[] args){}。其中public是访问控制修饰符，static是非访问修饰符，也称为静态修饰符，void是返回值类型，String[]是参数类型，为字符串数组(要区别字符数组char[]),args是参数名。 为什么要使用方法，为了更好的调用，减少代码冗余度，避免不必要的浪费，也为了减少代码修改的次数。 方法的定义1234修饰符 修饰符 返回值类型 方法名(参数类型 参数名1，参数类型 参数名2...)&#123; 代码; return 返回值;&#125; 修饰符修饰符:告诉编译器这个方法如何使用。方法中有四个访问控制修饰符：，public、protected、default、private。和两个基本非访问修饰符：final和static。 访问控制修饰符public：公有访问修饰符。可以被所有类访问。 protected：受保护富访问修饰符。对同一包内的类和所有子类使用。 default：默认修饰符。在同一个包内可见。 private：私有访问修饰符。只能是当前类使用。 以default为例，在java中，不是静态方法或类，都要先new一个对象，才能使用相应的方法或类。其它修饰符也可以做，使用不同的包建立class，感受这些修饰符感受差异。 123456789public class FangfaTest &#123; public static void main(String[] args) &#123; FangfaTest ff = new FangfaTest(); System.out.println(ff.add(1,2)); &#125; int add(int a, int b) &#123; return a+b; &#125;&#125; 而public和private应该是最常用的修饰符吧，使用的次数挺多的。当然，这里强调下，在一个类中，只能有唯一一个public类，但可以有多个public方法。 非访问修饰符static：静态修饰符，静态变量和方法可是直接使用。 final：变量一旦赋值，就不能更改，和static使用创建类常量。 static修饰的方法直接使用，不需要创建对象。常用的类Math也是静态类，它里面有很多方法也是静态方法。 123456789101112131415161718192021222324public class FangfaTest &#123; static int a = 1; //静态修饰的变量 final int B = 2; //final修饰的变量，也称为常量，不能更改值 public static void main(String[] args) &#123; System.out.println(add(1,2)); //使用static修饰的方法 a = 2; //修改static修饰的变量 // B= 3; final修饰的常量不能更改值，修饰的类也不能继承 System.out.println(a); FangfaTest ff = new FangfaTest(); System.out.println(ff.add(1.2,2)); //只要不是static修饰的方法，都要先new一个对象 &#125; //下面是方法重载，返回值类型和参数类型不同 final double add(double a, double b) &#123; return a+b; &#125; static int add(int a, int b) &#123; return a+b; &#125;&#125; 以上六种修饰符，不仅可以用在方法上，也可以用在类或类里的数据类型上。当然，修饰符还有其它的，那就要讲到后面的内容慢慢补充。 方法的返回类型方法的返回也就是我们前面记录的八种基本数据类型和现在慢慢补充的引用类型，比如数组，以后的字符串String或者是类。还有无返回类型void。 用基本数据类型int实例: 12345678910public class FangfaTest &#123; public static void main(String[] args) &#123; FangfaTest ff = new FangfaTest(); System.out.println(ff.add(1,2)); &#125; int add(int a, int b) &#123; return a+b; &#125;&#125; 返回类型为void实例： 1234567891011public class FangfaTest &#123; public static void main(String[] args) &#123; FangfaTest ff = new FangfaTest(); ff.add(1,2); &#125; void add(int a, int b) &#123; System.out.println(a+b); return; //虽然没返回值，但return有两个意思，一个结束运行，另一个返回结果。在这只是结束运行。 &#125;&#125; 用类简单写了一个1+2，然后用方法调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class FangfaTest &#123; public static void main(String[] args) &#123; //先把对象建立，两个类，两个对象 FangfaTest ff = new FangfaTest(); adds a = new adds(); //设置私有变量a和b的值 a.setA(1); a.setB(2); //输出结果 System.out.println(ff.add(a)); &#125; //公有类的方法 int add(adds a) &#123; //调用了adds类 return a.add(); &#125;&#125;//类的封装，我可以在set方法中设置我的要求，比如是正整数呀，范围多少，增加限制，减少代码出错率class adds&#123; private int a; private int b; public int getA() &#123; return a; &#125; public void setA(int a) &#123; this.a = a; &#125; public int getB() &#123; return b; &#125; public void setB(int b) &#123; this.b = b; &#125; public int add() &#123; return this.a+this.b; //关键字this，指当前的类的变量 &#125;&#125; 方法的重载重载，意思就是实现的内容大致一样，只是参数类型不同，返回类型无所谓，但参数类型一定要不一样，否则，编译器不知道用谁。 1234567891011121314151617181920public class Test02 &#123; public static void main(String[] args) &#123; Test02 t = new Test02(); System.out.println(t.add(1, 2)); System.out.println(t.add(1, 2, 3)); System.out.println(t.add(1.2, 2.1)); &#125; int add(int a,int b) &#123; return a+b; &#125; int add(int a,int b, int c) &#123; return a+b+c; &#125; double add(double a, double c) &#123; return a+c; &#125;&#125; 如果把double add()里的参数类型都变成int，那就会编译器报错。所以一定是参数类型不同才能重载。 值传递与引用传递形参:方法中定义的参数。 实参:调用中，传入方法的实际参数。 值传递:只是把值传给方法的参数，但不改变原参数的值。一般只有八种基本数据类型是值传递。 引用传递(址传递):传入方法中，如果方法里的参数改变了数据，那么原参数也改变。一般只是引用类型会改变。 为什么会有值传递和址传递的差异？ 说白了就是指向的对象不同，值传递是在方法调用中，指向一个新的数据变量，址传递因为一开始都指向同一个对象，那么原参数也改变。 1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;public class test03 &#123; public static void main(String[] args) &#123; //基本数据类型，一般是值传递 int a = 10; //一开始a是10 changeInt(a); //方法里把a变为20 System.out.println(a); //值传递并没有改变原a的值 //引用类型，一般是引用传递/址传递 int []arr = new int[] &#123;0,1,2,3,4,5,6,7,8,9&#125;; changeArr(arr); //数组是一个对象，改变同对象的值 System.out.println(Arrays.toString(arr)); //方法中重新new一个对象 changeArr2(arr); //新的方法，重新new一个数组[0,1,2,3,4] System.out.println(Arrays.toString(arr)); //但并没有改变原数组的值，因为它们的指向的地址不同 &#125; public static void changeInt(int a) &#123; a = 20; &#125; public static void changeArr(int a[]) &#123; for(int i=0; i&lt;a.length; i++) &#123; a[i] = (i+1)*2; &#125; &#125; public static void changeArr2(int a[]) &#123; a = new int [5]; //新new一个数组 for(int i=0; i&lt;a.length; i++) &#123; a[i] = i; &#125; &#125;&#125; 方法块上面讲的都是有返回类型，方法名的方法，如果没有呢？那就是方法块。 12345678910111213141516171819public class Test &#123; static &#123; System.out.println(&quot;static方法块&quot;); &#125; &#123; System.out.println(&quot;main外的方法块&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;main方法&quot;); &#123; int a = 10; System.out.println(&quot;main里的方法块&quot;); &#125; //a = 5; &#125;&#125; 由于没有方法名，所以只能直接放到main里使用，而且方法块里的变量，属性，在方法块外是没发使用的，相当于局部变量。 123static方法块main方法main里的方法块 结果是不是很意外，分析一下，在执行程序时，先将静态的，类，方法名，常量放到内存的方法区，所以先加载static方法块，然后执行main方法，一步一步执行，为啥没执行main外的方法块呢，因为我们没调用这个类。下次再继续。 方法就这么多记录，有遗漏欢迎在评论区补充，有不足也请多多关照，在评论区留言，也感谢您的观看，下次见。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（二）]]></title>
    <url>%2F2019%2F08%2F05%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本次主要记录的是基本控制语句、数组两块内容 基本控制语句在java中，控制语句有顺序结构、选择结构、循环结构三类。而顺序结构我们写一般的代码，一行一行的写下去，就像看书一样，有顺序，一行一页。 本次主要记录的是选择结构和循环结构。 选择结构选择也称为判断，如果…就…，只有满足条件才执行响应的语句块。 if语句如果第一个if执行，输出大数，如果第二个if执行，输出小数。有多少个if，就进行几次判断。 1234567891011int a = (int)(Math.random()*10+1); //random()是Math类的静态方法，产生[0,1)之间的随机数，为浮点型//random()*10，就是产生[0,10)之间的随机数，再加1,产生[1,11)之间的浮点型随机数，最后转为int型System.out.println(a);if(a&gt;=5) &#123; //()里填的条件语句是布尔表达式，为真执行语句 System.out.println(&quot;大数&quot;);&#125;if(a&lt;5) &#123; System.out.println(&quot;小数&quot;);&#125; if-else语句我们把上面的代码改改，变成if-else语句，变量a只需要判断一次，如果if不执行，那么else执行 12345678int a = (int)(Math.random()*10+1); System.out.println(a);if(a&gt;=5) &#123; //()里填的条件语句是布尔表达式，为真才执行语句 System.out.println(&quot;大数&quot;);&#125;else &#123; //if里不执行，那表达式为假，就跳到else执行 System.out.println(&quot;小数&quot;);&#125; if-elseif-else语句如果我们要输出成绩怎么办，优、良、中、及格、不及格，我们用if和if-elseif-else进行对比。 以下为了方便直观，把判断句的语句块都去掉了，但很容易出现问题。所以请记住，一定要打{}。 1234567891011121314151617int a = (int)(Math.random()*100+1); System.out.println(a);//先用if来操作if(a &lt; 60) System.out.println(&quot;不及格&quot;);if(a&gt;=60 &amp;&amp; a &lt; 70) System.out.println(&quot;及格&quot;);if(a&gt;=70 &amp;&amp; a &lt; 80) System.out.println(&quot;中等&quot;);if(a&gt;=80 &amp;&amp; a &lt; 90) System.out.println(&quot;良好&quot;);if(a &gt;= 90) System.out.println(&quot;优秀&quot;);System.out.println(&quot;--------------------&quot;);//现在用if-else if-else操作if(a&gt;=90) System.out.println(&quot;优秀&quot;); //如果大于等于90执行这条语句else if(a&gt;=80) System.out.println(&quot;良好&quot;); //否则，大于等于80执行这条语句else if(a&gt;=70) System.out.println(&quot;中等&quot;); //再否则， 大于等于70执行这条语句else if(a&gt;=60) System.out.println(&quot;及格&quot;); //再再否则， 大于等于60执行这条语句else System.out.println(&quot;不及格&quot;); //再再再再否则，终于输出最后一条语句 嵌套的if我们可以在if里再加判断句。 12345678if(布尔表达式)&#123; if()&#123; if()&#123;&#125; else if()&#123;&#125; else &#123;&#125; &#125; else &#123;&#125;&#125; 我们用嵌套的if-else来输出成绩 123456789101112131415161718192021if(a&gt;=90) &#123; System.out.println(&quot;优秀&quot;);&#125;else &#123; if(a&gt;=80) &#123; System.out.println(&quot;良好&quot;); &#125; else &#123; if(a&gt;=70) &#123; System.out.println(&quot;中等&quot;); &#125; else &#123; if(a&gt;=60) &#123; System.out.println(&quot;及格&quot;); &#125; else &#123; System.out.println(&quot;不及格&quot;); &#125; &#125; &#125;&#125; 如果把{}都拿掉，是不是很像if-elseif-else类型。 总结一下if条件语句，如果只满足一个条件才执行，那就用if单条语句，如果判断对立面，那就用if-else语句，如果有多判断多选择，就用if-elseif-else。好像说的废话一样。。。怎么方便怎么用就行。 switch语句此switch非彼switch，不是游戏机，没有任天堂，就是用来判断的，是多选择语句，和if-else if-else类似。但是switch可以很简单用字符串来判断。你也可以在case里嵌套switch，实现嵌套判断。 123456789101112131415161718String[] game = &#123;&quot;ps4&quot;, &quot;xbox&quot;, &quot;switch&quot;&#125;; //这是字符串数组，马上讲数组了，而字符串会专门讲，很重要int i = (int)(Math.random()*3); //数组从0开始，所以这里随机[0,3)就行System.out.println(i);switch(game[i]) &#123; case &quot;ps4&quot;: System.out.println(&quot;大家好，我是索尼游戏机&quot;); break; //break是停止语句，接下来语句块内的内容不执行，一般在循环语句块用 case &quot;xbox&quot;: System.out.println(&quot;大家好，我是微软游戏机&quot;); break; //如果没有break,当i=0时，会输出全部内容 case &quot;switch&quot;: System.out.println(&quot;大家好，我是任天堂游戏机&quot;); break; default: //相当于else,可以把case &quot;switch&quot;去掉，把输出任天堂放到这里 break;&#125; 循环语句只要满足相应的条件，就一直执行下去。 for循环123456for(初始值; 循环条件; 循环走向)&#123;&#125;初始值:循环从开始的地方循环条件:循环在什么情况下满足条件循环走向:循环是递增还是递减,等比数列还是等差数列进行取值 123456789101112for(int i=0; i&lt;=10; i++) &#123; //System.out.print(i+&apos; &apos;); 这里把char自动转型为int，空格为32，和i加在一起(i+32),输出3233343536373839404142 System.out.print(i+&quot; &quot;); //这样才打印[0,10] 输出0 1 2 3 4 5 6 7 8 9 10 &#125;//原因:char是一个字符，能与int相加转型为int型，而&quot; &quot;是字符串(String)//&quot; &quot;里有两个值，&apos; &apos;和&apos;\0&apos;组成，int不会与String相加//但String放到+前，会把之后的内容拼接在一起,下面把循环输出改一改for(int i=0; i&lt;=10; i++) &#123; System.out.print(i+2+&quot; &quot;+i+2+&apos;,&apos;); //输出2 02,3 12,4 22,5 32,6 42,7 52,8 62,9 72,10 82,11 92,12 102,&#125;//&quot; &quot;前i和2相加，之后把i和2还有&apos;,&apos;拼接在一起,所以用String类型，要注意放的位置 增强for循环增强for循环一般只是输出变量的数值。下面打印0~9的数。 123456int [] a = &#123;0,1,2,3,4,5,6,7,8,9&#125;;//for(Object 临时变量名:要打印的变量名)//增强for循环不仅可以用于基本的数据类型，还能用于类，类都继承了Object对象for(int temp:a) &#123; System.out.print(temp+&quot; &quot;);&#125; while循环while循环只有循环条件，初始值只能在循环体外定义。 下面输出0到10的数 12345int i=0;while(i&lt;=10) &#123; System.out.print(i+&quot; &quot;); i++;&#125; for和while都是比较常用的循环。 do-while循环12345int i=5;do &#123; System.out.print(i+&quot; &quot;); i++;&#125;while(i&lt;0); do-while和while有啥区别呢，那就是do-while第一次无论 有没有满足条件，都先执行一次，而while、乃至for都是先要满足条件才执行。而上面的这段代码，5本来就小于0，而do-while会打印了5，才来判断是否满足条件。 嵌套循环我们用for和while分别打印乘法表。 123456789101112131415161718for(int i=1; i&lt;=9; i++) &#123; for(int j=1; j&lt;=i; j++) &#123; System.out.print(j+&quot;*&quot;+i+&apos;=&apos;+(i*j)+&apos; &apos;); //之前说过&quot;&quot;之后是字符串拼接，所以(i*j)打了括号，当然不打括号也行，*优先级大于+ &#125; System.out.println();&#125;System.out.println(&quot;------------------------&quot;);int i=1;while(i&lt;=9) &#123; int j=1; while(j&lt;=i) &#123; System.out.print(j+&quot;*&quot;+i+&apos;=&apos;+(i*j)+&apos; &apos;); j++; &#125; System.out.println(); i++;&#125; 当然，如果想输出格式化对齐，最简单的办法就是用C语言的格式输出。 System.out.printf(“%d*%d = %2d “,j,i,i*j); !、&amp;&amp;、||当然，它们也是参与布尔表达式的运算，常常在条件语句和循环语句出现，前面也提及过，if()里进行的是布尔表达式，循环里的循环条件也是布尔表达式。我们来一起用用吧。 符号 名称 说明 ! 非 肯变否，否变肯 &amp;&amp; 与 全真才真 || 或 全假才假 条件语句经常和循环语句一起使用，我们来看看下面的例子。 1234567//输出1000年到2999年之间有多少闰年for(int i=1000; i&lt;= 2999; i++) &#123; if((i%4==0 &amp;&amp; i%100!=0) || i%400==0) &#123; //里面可以不用加()，!的优先级&gt;&amp;&amp;&gt;&gt;|| System.out.println(i+&quot;\t&quot;); &#125;//闰年一定可以被4整除，而千年是闰年，还能被400整除，可是百年大部分都不是闰年，但它能被100整除&#125; 123456789101112131415161718192021int a = 2, b = 3, c = 0;if(!(c!=0) &amp;&amp; a&gt;1) &#123; System.out.println(&quot;c不是不是0，并且a的值大于1&quot;); //有点拗，c!=0，是false,又加个否定，等价于c==0&#125;if(a&gt;2 &amp;&amp; (c++)&gt;=0) &#123; System.out.println(&quot;有输出吗?&quot;);&#125;System.out.println(&quot;c:&quot;+c);//看的出来， a&gt;2不成立，没有执行if里的内容，&amp;&amp;后面也没有执行if((c++)&gt;=0 &amp;&amp; a&gt;2) &#123; System.out.println(&quot;有输出吗?&quot;);&#125;//更改一下位置，c++,c变为1，条件成立，但a&gt;2不成立，没有执行if里的内容System.out.println(&quot;c:&quot;+c);if(a&gt;2 || (c++)&gt;=0) &#123; System.out.println(&quot;c:&quot;+c);&#125;// ||有一个成立就行，所以if里打印了c的值 break和continuebreak是强制退出循环，不执行剩余的内容；而continue是跳过本次循环的内容。 下面是嵌套循环，在j==3进行了处理，break每次到j==3时，跳出内循环，进行下一次外循环。而continue是跳过本次内循环，进行下一次内循环。 12345678910111213141516for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) break; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println();&#125;System.out.println(&quot;------------------------------------------------------&quot;);for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) continue; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println();&#125; 在C语言中，有一个语句叫goto，很少用，因为太调皮了。能够从一个语句跳转到另一个语句，用起来很爽，但太乱了，所以java中就只成为保留字，没有任何意义。但是，break和continue却有点像goto，不执行接下来的语句，执行另外的语句，只是限制在了循环里。而它只是不执行内循环接下来的语句，如果我们也不想执行外循环接下来的语句呢？ 1234567891011121314151617a:for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) break a; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println();&#125;System.out.println();System.out.println(&quot;------------------------------------------------------&quot;);a:for(int i=1; i&lt;5; i++) &#123; for(int j=1; j&lt;5; j++) &#123; if(j==3) continue a; System.out.print(i+&quot;:&quot;+j+&apos;\t&apos;); &#125; System.out.println(); //这条语句就成了摆设，可以放在第一个循环下面&#125; 也差不多实现和goto一样的意思，想跳哪就去哪，只是限制在循环里的操作。如果里面的判断再多点，估计也就像goto一样看不懂了，所以我感觉自己玩玩挺好的，真正拿来写代码，那有点得罪人的意思了。 数组当存在多个相同数据类型的变量，我们用x1,x2,x3,x4…进行数据操作时效率太低，因此才有了数组。数组分为一维数组在，和多维数组，我们最常用的应该就是一维数组在和二维数组。而这个维度，指的只是空间的增多而已。一维只是一行元素，二维在一维的每个元素又拉出来一列，构成一个矩阵。三维也是只在每行每列的每个元素又来出来一纵，构成一个像魔方一样的立体。四维也就只是再在每个元素又拉出一行元素，以此类推。 数组的声明和赋值好像有三种吧。但好像我一般只用两种。 一维数组第一种是声明数组类型和长度，然后赋值。 1234567891011121314//数组声明int []a = new int [10]; //[0,10)//int a[] = new int [10]; //这种也可以，C/C++的规范//数组赋值，数字下标从0开始计算a[0] = 0;a[1] = 1;a[2] = 2;//也可以循环赋值for(int i=3; i&lt;10; i++) &#123; a[i] = i;&#125;System.out.println(Arrays.toString(a)); //一定要引入 import java.util.Arrays;//打印出[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 第二种是声明数组类型写内容 123int []a = new int[] &#123;0,1,2,3,4,5,6,7,8,9&#125;;System.out.println(Arrays.toString(a)); //一定要引入 import java.util.Arrays;//打印内容和上面一样 第三种是直接写内容 12345int []a =&#123;0,1,2,3,4,5,6,7,8,9&#125;;for(int i=0; i&lt;a.length; i++) &#123; //也可以用循环打印结果，length是获取数组的长度 System.out.print(a[i]+&quot; &quot;);&#125;//输出 0 1 2 3 4 5 6 7 8 9 二维数组123456789101112131415int [][]a = new int [3][]; //告诉编译器二维数组有三行，每行多少个就看你自己写的//int [][]a = new int [3][4]; //也可以直接写死，有三行，有四列a[0] = new int[3];a[0][0] = 0;a[0][1] = 1;a[0][2] = 2;a[1] = new int[] &#123;0,1,2,3,4&#125;;//a[2] = &#123;0,1&#125;是不行的，否则就是一维数组，但我们声明的是二维a[2] = new int[] &#123;0,1&#125;;for(int i=0; i&lt;a.length; i++) &#123; for(int j=0; j&lt;a[i].length; j++) &#123; System.out.print(a[i][j]+&quot; &quot;); &#125; System.out.println();&#125; 1int [][]a = new int[][] &#123;&#123;0,1,2&#125;,&#123;0,1,2,3,4&#125;,&#123;0,1&#125;&#125;; 二维数组也可以像一维数组一样声明和使用，但它列可以是不固定的，有多长看自己的喜爱。但我一般喜欢用固定，方便两层for循环输入数据。 12345678int [][]a = new int[3][4];for(int i=0; i&lt;a.length; i++) &#123; for(int j=0; j&lt;a[i].length; j++) &#123; a[i][j] = i*j+i+j; &#125; &#125;System.out.println(Arrays.deepToString(a)); //声明 import java.util.Arrays;//输出 [[0, 1, 2, 3], [1, 3, 5, 7], [2, 5, 8, 11]] 数组还有多维数组，当然，可不要搞迷糊了。这次就到这里啦。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（一）]]></title>
    <url>%2F2019%2F07%2F30%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本次主要记录的是基本数据类型、数据类型转换、基本运算符和进制表示四块内容。 基本数据类型java中基本数据类型有八种基本类型，包括整数型、浮点型、字符型和布尔类型这几类。如有不足，多多指教。 整数类型java中整数类型有byte、short、int、long共四种。占八种基本数据类型的一半。 类型 范围 默认值 位 byte -128~127 0 8 short -32768~32767 0 16 int -2147483658~2147483657 0 32 long -2^31~2^31-1 0L 64 其中，整数的默认类型是int，所以使用long类型时，如果数据范围超过int，要在其值后加上L/l,来转型为long。但l和1(一)太相像，所以通常用大写的L。而byte和short就不需要类型转换，因为它们的数据范围本身比int小，自然不会超过int表示范围。 12345//这些都在自己的数据范围内byte a = 18; //输出 18short b = 1000; //输出 1000int c = 40000; //输出 40000long d = 3000000000L;; //输出 3000000000 而下面则是错误示范，还没运行，编译器自动提示错误：前两个是类型不匹配，无法从int转为byte/short，后两个都是超过int数据类型的范围。更能说明long的默认数据类型是int，因为他没超过long的数据范围。 浮点类型 类型 范围 默认值 位 float 1.4E-45~3.4028235E38 0.0f 32 double 4.9E-324~1.7976931348623157E308 0.0d 64 浮点类型数据范围挺大的，但不太精确，做运算都有可能有误差。不过double则要比float类型精确些，而且在java中，浮点类型的默认类型是double。所以，我们通常使用double更多。当然也可以使用float，不过要在其值加上f，否则编译器会报错。 12345678910//float使用float f1 = 1.2f; //f大小写都行//double使用double d1 = 1.5;double d2 = 1.7d; //可以在后面加d或D//使用科学计数法，以double为例double d3 = 314e-2; //输出 3.14double d4 = 314e2; //输出31400.0 以下是以doubl为例，进行的运算。 1234567891011double a = 12.3;double b = 12.3;double c = 24.6;double e = a + b;System.out.println(e);System.out.println(a == b);System.out.println(c == e);double d = a + c;double f = 36.9;System.out.println(d);System.out.println(d == f); 这是以加法为例，说明浮点类型在进行运算的不可靠。而可能这几行代码在你的电脑就全是true。当然这你可能会有疑惑，浮点计算不可靠，那咋办？其实java有自己的类进行浮点运算，那就是BigDecimal，它属于Math类中，以后讲常用类会提及。 字符类型java中字符类型是char表示，数据范围从0~65525，其默认值为\u0000, 在内存中占16位。 1234char c = &apos;A&apos;; //注意要打单引号，双引号就是字符串啦System.out.println(c); //输出 Aint a = 97; //也可以把整型强制转换成char类型，后面会提及类型转换System.out.println((char)a); //输出 a 布尔类型java中布尔用boolean表示， 它只有两个取值true和false。true为真，false为假，默认值为false。 在内存中占1位。 123456boolean flag = true;if(flag) &#123; //等价于 flag==true //if条件语句只有true时，才执行 System.out.println(&quot;flag为&quot; + flag);&#125;//输出 flag为true 数据类型转换数据转换分为两种，一种是自动转换，容量小的自动转换成容量大的，另一种是强制转换(强制把某种类型转换成另一种类型)，强转可能会出现精度损失。 什么是精度损失？比如1.9的浮点型，强制转为整型，就变成1，小数部分直接舍弃。 自动转换byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double char–&gt;int当然整型转换成浮点型，有可能会出现精度的损失。 123456789101112131415161718byte bt = 127;int bc = bt;System.out.println(bc); //输出 127int a = 12;double b = a;System.out.println(b); //输出 12.0long c = 1234567890123456789L;float d = c;double dou = c;//电脑不同，可能输出的结果也有一点点差别System.out.println(d); //输出 1.23456794E18System.out.println(dou); //输 1.23456789012345677E18char ch = &apos;\u0010&apos;; //可以看的出来是char占16位int ch2 = ch;System.out.println(ch2); //输出16 从代码中，这些都是自动转换，但也有人会问，为啥long都能自动转换为float，long占64位，float占32位，但java自动转换不是看谁在内存占的位数大就转谁，而是看容量。浮点型中，容量是不能直接算出来的，而float的最大值远远大于long的最大值，所以long能自动转换为float。但数值一大，就会出现精度损失。 强制转型一般把容量大的转换成容量小的，但转换的变量数据不能超过转换后的容量，虽然编译器不会报错，但输出结果可能是错误的。 以整型为例: 123456int a = 18;byte a1 = (byte)a; //把int型强制转换成byte型，并且18在byte范围内System.out.println(a1); //输出 18a = 128; //128已经超过byte数据范围a1 = (byte)a;System.out.println(a1); //输出错误答案 -128 可以看出强制转型一定要在合理范围内，比如说，两个杯子，一个大杯子是满的，另一个小杯子是空，我们无法把大杯子的水都倒在小杯子里。反过来我们可以把装满水的小杯子倒在空的大杯子，不过这是自动转型啦。 强制把浮点型转换成整型型，可能会出行精度损失。 1234double d = 1.9; //如果浮点本身是没有小数，转整型就不会出行精度损失int a = (int)d;System.out.println(a); //输出 1System.out.println(d); //输出1.9 转型是不改变原变量的值 基本运算符 运算符 名称 例子(int型) 结果 + 加法 a = 1+2 a = 3 - 减法 a = 2-1 a = 1 * 乘法 a = 5*2 a = 10 / 除法 a = 5/2 a = 2 % 求余/取模 a = 5%2 a = 1 ++ 自增 a1 = a2 = 2; b = a1++; c = ++a2 b = 2; c = 3 - - 自减 a1 = a2 = 2; b = a1- -; c = - -a2 b = 2; c = 1 ~ 取反 a = ~6 a = -7 &amp; 与 a = 5; b = 3; c = a&amp;b c = 1 | 或 a = 5; b = 3; c = a|b c = 7 ^ 异或 a = 5, b = 3; c = a^b c = 6 &lt;&lt; 左移(*2) a = 1&lt;&lt;2 a = 4 &gt;&gt; 右移(/2) a = 8&gt;&gt;3 a = 1 以上就是java中最常用的运算符，加减乘数是基本的四则运算，整数和浮点型可以一起运算，但是，低的数据类型会向高的数据类型自动转换。如果不同类型进行运算，赋值的变量数据类型要是最大的那个。 四则运算123456789101112131415int a1 = 12;long a2 = 23; //23一开始是int型，赋值个a2变成了long型//a1 = a1+a2; //a1和a2相加自动向long类型转换，所以会报错//但我们可以进行下面这运算a1 += a2; //等价于 a1 =(int)(a1+a2); 把long型强制转换成int型//浮点型最注意除法运算double d = 1.2 + 5 / 2; //输出 3.2//在运算过程中,先/，5/2，两个都是整型，结果也是整型2，2+1.2就是结果，这里有转换成2.0+1.2//那怎么办，办法如下//把其中一个整型变成浮点型d = 1.2 + 5.0/2; //输出 3.2//d = 1.2 + (double)5/2; 这样也是可以的，但太麻烦，很少用吧...//d = 1.2 + (double)(5/2); ps:这是错误，和第8行运算一样的结果 求余% 就是求一个数除以另一个数得到它的余数，所以称为求余或取模。 123456int a = 10%3; //输出 1//注意，求余结果符号和除数用关a = -10%3; //输出 -1a = 10%-3; //输出 1a = -10%-3; //输出 -1 ~这里以前没写，忘了，现在加上 12345678对6取反int a = ~6;6 0000 0110补码 1111 1001反码 1111 1000再取反 1000 0111第一位是符号位，0代表整数，1代表负数，所以最后答案是-7 ++和- -自增是自己加1，自减是自己减1，但要注意放的位置。 123456//++和--都一样，以++为例int a1 = 2;int a2 = 2;int b1 = a1++; //b1 = 2 运算为 先b1 = a1, 然后a1 += 1int b2 = ++a2; //b2 = 3 运算为 先a += 1， 在b2 = a2 //最后结果a1和a2都为3 &amp;、|1234567891011121314151617 int a1 = 5, b1 = 3; int c1 = a1&amp;b1; //输出1/* * 与运算是真真为真，一真一假为假，假假为假 * 而这里的真是二进制的1，假为二进制的0 * 5的二进制为 0101 * 3的二进制为 0011 * 进行与运算 0001 所以答案为1 */ int a2 = 5, b2 = 3; int c2 = a2|b2; //输出7/* * |运算是真真为真，一真一假为真，假假为假 * 所以5|3 为 0101 * 0011 * 0111 答案为7 */ ^1234567891011121314151617 int a = 5, b = 3; System.out.println(a^b); //输出 6/* * 原理还是二进制 * 5的二进制：0101 * 3的二进制：0011 * 那么^之后：0110 就是6啦，一真一假为真 */ int a1 = 2, b1 = 3, c1 = 0; if(a1&gt;2 ^ (c1++)&gt;=0) &#123; //a1&gt;2假，(c1++)&gt;=0真 System.out.println(c1); //输出c1为 1 &#125; if(a1==2^b1==3) &#123; System.out.println(&quot;有输出吗?&quot;); //没有输出 &#125; 当然，还有一个!，但是在java中，!只进行表达式运算，而表达式计算的结果为true或false，也就是获得一个布尔值。而其它语言，像C/C++布尔值可以用0表示false，非0表示true，进行简单的运算。 &lt;&lt;和&gt;&gt;左移一位是乘2，左移两位是乘4……以此类推。右移一位是除以2，右移两位是除以4……以此类推。通常在乘2或除以2，建议用&lt;&lt;和&gt;&gt;，效率上要比*和/快一点。 12345678910 int a = 1&lt;&lt;2; //输出 a为4/* * 1的二进制是0001，把1左移两位，变成0100，变成了4 */ int b = 8&gt;&gt;3; //同理，1000右移三位，变成0001 //当然不是移一个数，是整体的移动，下面以7为例 //0111&lt;&lt;1 ---&gt; 1110 变为 14 7*2=14 //0111&gt;&gt;1 ---&gt; 0011 变为 3 7/2=3 进制表示 “世界上只有10中人，一种是懂二进制，另一种是不懂二进制”。 二进制由0和1组成，而我们的代码最终也会变成二进制运行，计算机也是以二进制进行工作，网络信息也是以二进制在物理层传输。所以二进制对我们来不会很陌生。 初次之外，我们还有八进制、十六进制和常用的10进制，让我们用代码表示。 12345678910//都表示输入10这个数int a1 = 10; //写代码默认十进制 十进制:0 1 2 3 4 5 6 7 8 9int a2 = 0b1010; //二进制表示10，前面加0b/0B 二进制:0 1int a3 = 012; //八进制表示10, 前面加0就行 八进制:0 1 2 3 4 5 6 7 int a4 = 0xA; //十六进制表示10，前面加0x 十六进制:0 1 2 3 4 5 6 7 8 9 a b c d e f//那么如何输出各进制的10呢?System.out.println(Integer.toBinaryString(10)); //二进制System.out.println(Integer.toOctalString(10)); //八进制System.out.println(10); //额...十进制System.out.println(Integer.toHexString(10)); //十六进制 以上就是本次总结，本来还想写很多，把常用语句也记录上，那样就会太长了，只能等下一篇文章了。如有不足之处，请在下方评论区留言，谢谢您的来访~ ~ ~下次见。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客记]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[博客搭建好了，让我这个小萌新说点什么吧，如有不足，各位多多包涵 为什么要搭建博客搭建博客每个人都应该有自己的理由，我的理由是学的东西挺多了，时间一长就忘记了。不想在纸上做笔记，怕弄丢了，而且有新的发现不能在原有的基础上修改，越改越乱。在电脑上也写了一点代码，时间一长也不知道是干啥用的，有的还不容易找到。所有想写点博客，有思路的写，把学习过程写的明明白白。哈哈哈~。当然，也是为了提升自己嘛，耳边总会响起一句话：“你想成为什么样的人？”。我不知道会成为什么样的人，只要还是像当初那样热爱就行。 你要用这个博客干啥我还只是一个萌新，还有很多东西尚未了解，写不出大佬那样条条有序，严谨的代码。所以写写自己的学习笔记，一些对自己难题的解决分享，说通俗点就是随便写写，把自己的收获分享给大家，当然可能会出现很多错误，也希望各位大佬能严格指出。哈哈哈~。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
